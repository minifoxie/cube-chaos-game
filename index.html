<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CubeChaos - Sobrecarga CÃ³smica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body { 
            background: radial-gradient(circle at center, #0a0a1a 0%, #000010 100%);
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #f0f0f0; 
            overflow: hidden; 
            position: relative;
            touch-action: none;
        }
        
        canvas { 
            background: radial-gradient(circle at center, #0a0a2a 0%, #1a1a4a 100%);
            display: none; /* Inicia oculto */
            border-radius: 10px; 
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.5);
        }
        
        .ui-modal { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.92); 
            backdrop-filter: blur(12px); 
            display: none; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            text-align: center; 
            opacity: 0; 
            transition: opacity 0.5s ease; 
            z-index: 100; 
            padding: 20px;
        }

        .ui-modal[style*="display: flex"] {
            opacity: 1;
        }
        
        .modal-content { 
            padding: 30px; 
            border-radius: 15px; 
            width: 90%; 
            max-width: 950px;
            background: rgba(20, 30, 60, 0.95);
            border: 2px solid rgba(100, 180, 255, 0.7);
            box-shadow: 0 0 40px rgba(0, 150, 255, 0.8);
            transform: scale(0.9);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .ui-modal[style*="display: flex"] .modal-content {
            transform: scale(1);
            opacity: 1;
        }
        
        h1, h2, h3 { 
            margin: 10px 0; 
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.9);
            letter-spacing: 1px;
            font-weight: 700;
        }
        
        #upgrade-choices { 
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            justify-content: center; 
            gap: 20px; 
            margin-top: 20px; 
            flex-wrap: wrap; 
        }
        
        .upgrade-card, .cheat-card, .achievement-card { 
            background: rgba(30, 40, 80, 0.95);
            border: 2px solid #4a5a9a; 
            border-radius: 12px; 
            padding: 20px; 
            width: 100%;
            min-height: 160px;
            cursor: pointer; 
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4); 
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .upgrade-card:hover, .cheat-card:hover, .achievement-card:hover { 
            transform: translateY(-10px) scale(1.05);
            border-color: #8a8aff; 
            box-shadow: 0 0 30px rgba(138, 138, 255, 0.9);
            background: rgba(40, 50, 90, 0.95);
        }
        
        .upgrade-card h3, .cheat-card h3, .achievement-card h3 { 
            margin-top: 0; 
            font-size: 1.2em; 
            color: #ffcc00;
            border-bottom: 1px solid rgba(255, 204, 0, 0.3);
            padding-bottom: 8px;
            margin-bottom: 10px;
        }
        
        .upgrade-card p, .cheat-card p, .achievement-card p { 
            font-size: 0.95em; 
            color: #ccc; 
            margin-top: 8px;
            line-height: 1.4;
            flex-grow: 1;
        }
        
        .card-rarity-common { border-left: 6px solid #ffffff; }
        .card-rarity-uncommon { border-left: 6px solid #4caf50; }
        .card-rarity-rare { border-left: 6px solid #2196f3; }
        .card-rarity-epic { border-left: 6px solid #9c27b0; }
        .card-rarity-legendary { border-left: 6px solid #ff9800; }
        
        .achievement-common { border-left: 6px solid #ffffff; }
        .achievement-uncommon { border-left: 6px solid #4caf50; }
        .achievement-rare { border-left: 6px solid #2196f3; }
        .achievement-epic { border-left: 6px solid #9c27b0; }
        .achievement-legendary { border-left: 6px solid #ff9800; }
        
        .modal-button { 
            padding: 15px 30px; 
            font-size: 1.2em; 
            background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%);
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            margin-top: 20px; 
            transition: all 0.3s ease;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: 600;
            min-width: 220px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-button:hover:not(:disabled) { 
            background: linear-gradient(135deg, #66bb6a 0%, #388e3c 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }
         .modal-button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        #game-over-screen, #victory-modal { display: none; }
        #upgrade-modal .modal-content {
            width: 90%;
            max-width: 1000px;
        }
        #upgrade-modal-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(200, 220, 255, 0.8);
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.7);
            z-index: 5;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        #cheatMenuButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(200, 50, 50, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none;
        }
        
        #settingsButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(150, 100, 250, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none; /* Hidden by default */
        }
        
        #cheatMenuButton:hover {
            background: rgba(220, 70, 70, 0.95);
            transform: scale(1.05);
        }
        
        #settingsButton:hover {
            background: rgba(170, 130, 255, 0.95);
        }
        
        #cheat-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 40, 80, 0.97);
            border-radius: 12px;
            padding: 25px;
            width: 340px;
            display: none;
            z-index: 110;
            box-shadow: 0 0 30px rgba(255, 85, 85, 0.6);
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #ff5555;
        }
        #cheat-features-confirmation-modal, #delete-data-confirmation-modal, #restart-confirmation-modal, #return-to-menu-confirmation-modal {
            z-index: 120;
        }

        #badges-modal .modal-content, #records-modal .modal-content, #info-modal .modal-content, #changelog-modal .modal-content {
            border: 2px solid #4caf50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            width: 90%;
            max-width: 1100px;
        }
        
        #settings-modal .modal-content {
            border: 2px solid #9c27b0;
            box-shadow: 0 0 30px rgba(156, 39, 176, 0.6);
            width: 90%;
            max-width: 800px;
        }
        
        .cheat-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #555;
            padding-bottom: 15px;
        }
        
        .cheat-section h3 {
            color: #ff5555;
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1em;
        }
        
        .cheat-option {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            align-items: center;
        }
        
        .cheat-option label {
            flex: 1;
            text-align: left;
            font-size: 14px;
        }
        
        .cheat-option input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
        }
        
        .cheat-option input[type="number"] {
            width: 70px;
            padding: 6px;
            background: #2a2a4a;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }
        
        .cheat-button {
            background: linear-gradient(135deg, #ff5555 0%, #cc0000 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .cheat-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 85, 85, 0.5);
        }
        
        .platform {
            background: #5a6a9a;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(100, 150, 255, 0.6);
        }
        
        .joystick-container {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        .blood-splatter {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle, rgba(200,0,0,0.8) 0%, rgba(150,0,0,0) 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .damage-zone {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            background: rgba(255, 138, 101, 0.5);
            box-shadow: 0 0 15px #ff8a65;
            border: 2px solid #ff5722;
        }
        
        #cheat-cards-list {
            max-height: 300px;
            overflow-y: auto;
            flex-direction: column;
            gap: 12px;
        }
        
        #achievements-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
            max-height: 55vh;
            overflow-y: auto;
            padding: 10px;
        }
        .achievement-card .reward-info {
            font-size: 0.9em;
            color: #8a8aff;
            margin-top: 8px;
            border-top: 1px dashed rgba(138, 138, 255, 0.3);
            padding-top: 8px;
        }

        #pauseButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: rgba(50, 150, 250, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            font-size: 1.2em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none;
        }
        #pauseButton:hover {
            background: rgba(70, 170, 255, 0.95);
            transform: scale(1.05);
        }
        .cheat-card, .achievement-card {
            width: 100%;
            padding: 15px;
            text-align: left;
        }
        .pet {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #ff4081;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff4081;
            z-index: 10;
        }
        
        .lightning {
            position: absolute;
            pointer-events: none;
            z-index: 25; 
            background: linear-gradient(to bottom, rgba(255,255,255,0.8) 0%, rgba(255,255,100,0.8) 30%, rgba(255,200,0,0.8) 100%);
            opacity: 0;
            animation: lightningFlash 0.3s linear;
        }
        
        @keyframes lightningFlash {
            0% { opacity: 0; width: 4px; }
            10% { opacity: 1; width: 6px; }
            100% { opacity: 0; width: 2px; }
        }
        
        .laser-beam {
            position: absolute;
            pointer-events: none;
            z-index: 26; 
            background: linear-gradient(to right, rgba(255,0,0,0.8) 0%, rgba(255,100,100,0.8) 50%, rgba(255,0,0,0.8) 100%);
            box-shadow: 0 0 15px rgba(255,0,0,0.8);
            opacity: 0;
            animation: laserFade 0.4s linear;
        }
        
        @keyframes laserFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #achievement-notification-container {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }
        
        .achievement-notification {
            background: rgba(40, 50, 90, 0.95);
            border: 2px solid #ffcc00;
            border-radius: 10px;
            padding: 15px;
            width: 350px;
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.7);
            display: flex;
            align-items: center;
            animation: slideInOut 4s forwards;
            pointer-events: all;
        }
        
        @keyframes slideInOut {
            0% { transform: translateX(-110%); }
            15% { transform: translateX(0); }
            85% { transform: translateX(0); }
            100% { transform: translateX(-110%); }
        }
        
        .achievement-icon {
            width: 50px;
            height: 50px;
            background: gold;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #333;
            flex-shrink: 0;
        }
        
        .achievement-text h4 {
            color: #ffcc00;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        
        .achievement-text p {
            color: #ccc;
            font-size: 14px;
        }
        
        .achievement-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ffcc00;
            color: #333;
            font-weight: bold;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .achievement-card.unlocked { 
             border-color: #ffcc00; 
             background: rgba(50, 60, 110, 0.95);
        }
        
        .achievement-card.unlocked h3,
        .achievement-card.unlocked p {
            color: #ffdd44 !important;
        }
        
        .achievement-card.unlocked .conquista-text {
            color: #ffcc00 !important;
        }
        
        .achievement-counter-badge {
            display: inline-block;
            margin-left: 10px;
            padding: 3px 10px;
            font-size: 0.8em;
            font-weight: bold;
            background-color: #ffcc00;
            color: #333;
            border-radius: 12px;
            line-height: 1;
        }

        .setting-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .setting-option:last-child {
            border-bottom: none;
        }
        
        .setting-option label {
            flex: 1;
            text-align: left;
            font-size: 16px;
        }
        
        .setting-option input[type="range"] {
            width: 150px;
        }
        
        .setting-option input[type="checkbox"], .setting-option select {
            width: 20px;
            height: 20px;
        }
        .setting-option select {
            width: 150px;
            height: auto;
            padding: 5px;
            background: #2a2a4a;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }

        .graphics-presets {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .preset-button {
            padding: 8px 16px;
            background-color: #4a5a9a;
            border: 1px solid #6a7abc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .preset-button:hover {
            background-color: #8a8aff;
            border-color: #ffcc00;
        }
        .delete-data-button {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
            border: 1px solid #ff8a80;
            padding: 10px 20px;
        }
        .delete-data-button:hover {
             background: linear-gradient(135deg, #ef5350 0%, #d32f2f 100%);
        }

        
        .game-title {
            font-size: 4.5em;
            color: #ffcc00;
            text-shadow: 0 0 20px rgba(255, 204, 0, 0.7);
            margin-bottom: 5px; 
            letter-spacing: 4px;
            text-transform: uppercase;
            animation: titleGlow 2s infinite alternate;
            background: linear-gradient(45deg, #ffcc00, #ff9900);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 204, 0, 0.9), 0 0 60px rgba(255, 204, 0, 0.7); }
        }

        #splash-text, #splash-text-nickname {
            color: #ffffff;
            font-style: italic;
            margin-bottom: 20px;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            min-height: 20px; 
        }
        
        .character-selection {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .character-card {
            background: rgba(40, 50, 90, 0.8);
            border-radius: 15px;
            padding: 20px;
            width: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #4a5a9a;
            text-align: center;
        }
        
        .character-card:hover {
            transform: translateY(-10px);
            border-color: #8a8aff;
            box-shadow: 0 0 30px rgba(138, 138, 255, 0.7);
        }
        
        .character-card.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.7);
            transform: scale(1.05);
        }
        
        .character-icon {
            width: 100px;
            height: 100px;
            margin: 0 auto 15px;
            border-radius: 50%;
            background: #5a6a9a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        
        .character-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffcc00;
        }
        
        .character-description {
            font-size: 0.9em;
            color: #ccc;
        }
        
        .meta-progression {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .progression-item {
            background: rgba(40, 50, 90, 0.8);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            min-width: 120px;
        }
        
        .progression-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffcc00;
            margin: 5px 0;
        }
        
        .progression-label {
            font-size: 0.9em;
            color: #ccc;
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
        }
        
        .damage-indicator {
            position: absolute;
            color: #ff5555;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
            pointer-events: none;
            z-index: 15;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        #ingame-info-display {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto; 
            transform: none; 
            text-align: right;
            background: rgba(0,0,0,0.4);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 14px;
            color: #ccc;
            z-index: 10;
        }

        #game-timer-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.4);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            color: #f0f0f0;
            z-index: 10;
        }

        #ingame-info-display span {
            color: white;
            font-weight: bold;
            margin: 0 8px;
        }

        .wave-indicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
            z-index: 10;
        }
        
        .boss-warning {
            position: absolute;
            top: 30%;
            left: 0;
            right: 0;
            text-align: center;
            color: #ff5555;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            animation: pulseWarning 1s infinite;
            z-index: 20;
            display: none;
        }
        
        @keyframes pulseWarning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .tutorial-content {
            max-width: 800px;
            background: rgba(30, 40, 80, 0.95);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid #4caf50;
        }
        
        .tutorial-section {
            margin-bottom: 25px;
        }
        
        .tutorial-section h3 {
            color: #4caf50;
            margin-bottom: 10px;
        }
        
        .tutorial-controls {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        
        .control-item {
            text-align: center;
        }
        
        .control-icon {
            width: 60px;
            height: 60px;
            background: rgba(100, 180, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-size: 24px;
        }
        
        #play-button {
            position: relative;
            z-index: 5;
        }

        #customization-modal .modal-content, #permanent-upgrades-modal .modal-content {
            max-width: 900px;
        }

        .customization-container {
            display: block;
            margin-top: 20px;
        }

        .customization-sections {
            flex: 1;
        }
        
        .customization-tabs, .info-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 2px solid #8a8aff;
            padding-bottom: 10px;
        }

        .customization-tabs button, .info-tabs button {
            padding: 10px 15px;
            background-color: rgba(50, 60, 100, 0.8);
            color: #ccc;
            border: 1px solid #4a5a9a;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .customization-tabs button.active,
        .customization-tabs button:hover,
        .info-tabs button.active,
        .info-tabs button:hover {
            background-color: #8a8aff;
            color: white;
            border-color: #ffcc00;
        }

        .customization-options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .customization-options-grid::-webkit-scrollbar, .permanent-upgrades-list::-webkit-scrollbar, #info-content-panel::-webkit-scrollbar, #changelog-content::-webkit-scrollbar, #achievements-list::-webkit-scrollbar {
            width: 8px;
        }
        .customization-options-grid::-webkit-scrollbar-track, .permanent-upgrades-list::-webkit-scrollbar-track, #info-content-panel::-webkit-scrollbar-track, #changelog-content::-webkit-scrollbar-track, #achievements-list::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .customization-options-grid::-webkit-scrollbar-thumb, .permanent-upgrades-list::-webkit-scrollbar-thumb, #info-content-panel::-webkit-scrollbar-thumb, #changelog-content::-webkit-scrollbar-thumb, #achievements-list::-webkit-scrollbar-thumb {
            background: #8a8aff;
            border-radius: 4px;
        }
        .customization-options-grid::-webkit-scrollbar-thumb:hover, .permanent-upgrades-list::-webkit-scrollbar-thumb:hover, #info-content-panel::-webkit-scrollbar-thumb:hover, #changelog-content::-webkit-scrollbar-thumb:hover, #achievements-list::-webkit-scrollbar-thumb:hover {
            background: #ffcc00;
        }


        .customization-item {
            background-color: rgba(40, 50, 90, 0.7);
            border: 2px solid #4a5a9a;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 150px;
        }

        .customization-item:hover {
            border-color: #ffcc00;
            transform: translateY(-5px);
        }

        .customization-item.equipped {
            border-color: #4caf50;
            box-shadow: 0 0 15px #4caf50;
        }
         .customization-item.locked {
            opacity: 0.7;
            background-color: rgba(20,30,50,0.7);
        }
        .customization-item.locked .item-name {
            font-style: italic;
        }

        .item-preview {
            width: 60px;
            height: 60px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin: 0 auto 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #6070b0;
            overflow: hidden;
        }
        .item-preview canvas {
            display: block;
        }
        .item-preview-emoji {
             font-size: 36px;
             line-height: 60px;
        }
        
        .item-name {
            font-size: 0.9em;
            color: #eee;
            margin-bottom: 5px;
            word-wrap: break-word;
            flex-grow: 1;
        }

        .item-button-container {
            margin-top: 5px;
        }

        .item-button {
            width: 100%;
            padding: 8px 5px;
            font-size: 0.8em;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color: 0.2s;
        }

        .buy-button { background-color: #ffc107; color: #333; }
        .buy-button:hover { background-color: #ffca28; }
        .equip-button { background-color: #2196f3; color: white; }
        .equip-button:hover { background-color: #42a5f5; }
        .unequip-button { background-color: #78909c; color: white; }
        .unequip-button:hover { background-color: #90a4ae; }
        .equipped-button { background-color: #4caf50; color: white; cursor: not-allowed; }
        .achievement-lock-button { background-color: #b0bec5; color: #37474f; font-size: 0.7em; cursor: help; }


        #customization-coins {
            font-size: 1.2em;
            color: #ffcc00;
            margin-top: 15px;
            text-align: right;
            padding-right: 10px;
        }
        .customization-footer {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
        }

        #permanent-upgrades-modal .modal-content {
            max-width: 700px;
        }
        .permanent-upgrades-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            max-height: 50vh;
            overflow-y: auto;
            padding: 10px;
        }
        .permanent-upgrade-item {
            background-color: rgba(30, 40, 80, 0.9);
            border: 1px solid #4a5a9a;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .permanent-upgrade-info {
            text-align: left;
        }
        .permanent-upgrade-info h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 5px;
        }
        .permanent-upgrade-info p {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 5px;
        }
        .permanent-upgrade-info .upgrade-level {
            font-size: 0.8em;
            color: #4caf50;
        }
        .permanent-upgrade-action button {
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
        }
         .permanent-upgrade-action button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #nickname-modal .modal-content {
            max-width: 500px;
        }
        #nickname-modal { z-index: 150; }
        #nickname-input {
            width: 100%;
            padding: 15px;
            margin: 20px 0;
            font-size: 1.2em;
            text-align: center;
            background-color: rgba(0,0,0,0.3);
            border: 2px solid #8a8aff;
            color: white;
            border-radius: 8px;
        }
        #nickname-error {
            color: #ff5555;
            min-height: 20px;
        }
        
        #main-menu-modal .modal-content {
             background: none;
             border: none;
             box-shadow: none;
             overflow: visible;
             align-items: stretch; 
             justify-content: stretch;
             max-width: 1200px;
        }
        
        .main-menu-layout {
            display: flex;
            justify-content: space-between;
            align-items: center; 
            gap: 20px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .main-menu-left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
            width: 25%;
        }
        
        .main-menu-center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .main-menu-right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            width: 25%;
            text-align: center;
        }
        
        #main-menu-nickname {
            color: #ffcc00;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 0 0 10px #ffcc00;
            margin-bottom: 10px;
            text-align: left;
            width: 100%;
        }

        #characterPreviewCanvas {
            width: 200px;
            height: 200px;
            background: rgba(10, 20, 40, 0.7);
            border-radius: 15px;
            border: 2px solid #8a8aff;
            box-shadow: 0 0 20px rgba(138, 138, 255, 0.5);
            animation: floatPreview 4s ease-in-out infinite;
        }
        @keyframes floatPreview {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        #main-menu-coins-display {
            margin-bottom: 25px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2em;
            color: #ffcc00;
            font-weight: bold;
            border: 1px solid #ffcc00;
            width: 100%;
            text-align: center;
        }
        .main-menu-button {
            padding: 15px 20px;
            font-size: 1.1em;
            font-weight: 600;
            color: #e0e0e0;
            background: transparent;
            border: 2px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(135deg, #6a1b9a, #8a8aff);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            width: 100%; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-menu-button:hover {
            color: white;
            border-image-source: linear-gradient(135deg, #8a8aff, #ffcc00);
            transform: scale(1.05);
            text-shadow: 0 0 10px white;
        }
        .main-menu-button.play-button {
            padding: 25px 20px;
            font-size: 1.5em;
            border-image-source: linear-gradient(135deg, #4caf50, #81c784);
        }
        .main-menu-button.play-button:hover {
            border-image-source: linear-gradient(135deg, #81c784, #ffeb3b);
        }
        
        .main-menu-left-panel .game-title {
            text-align: left;
        }

        #best-record-display {
            background: rgba(40, 50, 90, 0.8);
            border: 2px solid #ffcc00;
            border-radius: 15px;
            padding: 20px;
            width: 100%;
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.5);
        }
        #best-record-display h3 {
            color: #ffcc00;
            margin-top: 0;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 10px;
        }
        #best-record-display p {
            font-size: 1em;
            margin: 8px 0;
            color: #ccc;
        }
        #best-record-display span {
            font-weight: bold;
            color: white;
        }
        #records-modal .modal-content {
            width: 90%;
            max-width: 1200px; 
        }

        #records-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }
        #records-table th, #records-table td {
            padding: 12px;
            border: 1px solid #4a5a9a;
            text-align: center;
        }
        #records-table th {
            background-color: rgba(40, 50, 90, 0.95);
            color: #ffcc00;
        }
        #records-list-container {
             max-height: 60vh;
             overflow-y: auto;
        }
         #records-list-container::-webkit-scrollbar { width: 8px; }
         #records-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
         #records-list-container::-webkit-scrollbar-thumb { background: #4caf50; border-radius: 4px; }

         .selection-footer-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
            margin-top: 20px;
         }
        
        #info-content-panel, #changelog-content {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            max-height: 55vh;
            overflow-y: auto;
            text-align: left;
        }
        .info-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .info-card {
            background-color: rgba(40,50,90,0.8);
            border: 1px solid #6070b0;
            border-radius: 8px;
            padding: 15px;
        }
        .info-card h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
        .info-card p, #changelog-content p, .info-section p {
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.5;
        }
        .info-card .rarity {
            font-style: italic;
            margin-top: 10px;
            text-align: right;
            font-weight: bold;
        }
        .info-section {
            margin-bottom: 20px;
        }
        .info-section h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
         #changelog-content ul {
            list-style-position: inside;
            padding-left: 10px;
        }
         #changelog-content li {
            margin-bottom: 8px;
        }
        #changelog-content h4 {
            color: #4caf50;
            margin-top: 15px;
        }
        #changelog-content h3 {
            color: #ffcc00;
            margin-top: 25px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
        #changelog-content h3:first-child {
            margin-top: 0;
        }
        .info-card ul {
            list-style-position: inside; padding-left: 10px; margin-top: 8px;
        }
        .info-card li {
             margin-bottom: 5px;
        }

        #ingame-cards-ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            max-height: 40vh;
            background-color: rgba(10, 20, 40, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            border: 1px solid rgba(138, 138, 255, 0.5);
            padding: 10px;
            z-index: 50;
            overflow-y: auto;
            display: none;
        }
        #ingame-cards-ui::-webkit-scrollbar { width: 6px; }
        #ingame-cards-ui::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        #ingame-cards-ui::-webkit-scrollbar-thumb { background: #8a8aff; border-radius: 3px;}
        .ingame-card-item {
            color: #eee;
            font-size: 14px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(138, 138, 255, 0.2);
        }
        .ingame-card-item:last-child {
            border-bottom: none;
        }
        .ingame-card-item .count {
            color: #ffcc00;
            font-weight: bold;
            margin-left: 8px;
        }

    </style>
</head>
<body>
    <!-- Fundo de estrelas -->
    <div class="stars" id="stars"></div>

    <!-- Container para notificaÃ§Ãµes de conquista -->
    <div id="achievement-notification-container"></div>
    
    <canvas id="gameCanvas"></canvas>
    
    <!-- Elementos de UI do jogo -->
    <div id="ingame-info-display" style="display: none;"></div>
    <div id="game-timer-display" style="display: none;">Tempo: 00:00</div>
    <div class="wave-indicator" id="wave-indicator">Onda: 0 | Inimigos: 0</div>
    <div class="boss-warning" id="boss-warning">CHEFE IMINENTE!</div>
    <div id="ingame-cards-ui"></div>
    
    <!-- BotÃµes de UI -->
    <button id="cheatMenuButton">Cheat Menu</button>
    <button id="settingsButton">Settings</button>
    <button id="pauseButton">ââ</button>
    
    <!-- Menu de Cheats -->
    <div id="cheat-menu">
        <button class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;" id="cheat-close">Ã</button>
        <h2>CHEAT MENU</h2>
        <div class="cheat-section">
            <h3>Jogador</h3>
            <div class="cheat-option"><label>Imortalidade:</label><input type="checkbox" id="immortality-cheat"></div>
            <div class="cheat-option"><label>Auto Disparo:</label><input type="checkbox" id="auto-fire-cheat"></div>
            <div class="cheat-option"><label>Velocidade:</label><input type="number" id="player-speed" value="7"></div>
            <div class="cheat-option"><label>Dano:</label><input type="number" id="player-damage" value="5"></div>
        </div>
        <div class="cheat-section">
            <h3>Inimigos</h3>
            <div class="cheat-option"><label>Congelar Inimigos:</label><input type="checkbox" id="freeze-enemies"></div>
            <div class="cheat-option"><label>Dano aos Inimigos:</label><input type="number" id="enemy-damage" value="10"></div>
        </div>
        <div class="cheat-section">
            <h3>Gameplay</h3>
            <div class="cheat-option"><label>EXP InstantÃ¢neo:</label><input type="checkbox" id="instant-exp"></div>
            <div class="cheat-option"><label>Pulos Infinitos:</label><input type="checkbox" id="infinite-jumps"></div>
            <div class="cheat-option"><label>Ir para a Onda:</label><input type="number" id="set-wave" min="1" max="100" value="1"></div>
            <div class="cheat-option"><label>Limite de Cartas:</label><input type="number" id="max-stacks" min="1" max="200" value="50"></div>
        </div>
        <div class="cheat-section">
            <h3>Cartas</h3>
            <div id="cheat-cards-list"></div>
            <button class="cheat-button" id="add-all-cards">Usar todas as cartas</button>
        </div>
        <button class="cheat-button" id="apply-cheats">Aplicar Cheats</button>
        <button class="cheat-button" id="reset-cheats">Resetar Cheats</button>
    </div>
    
    <!-- Menu de Conquistas -->
    <div id="badges-modal" class="ui-modal">
        <div class="modal-content">
            <button id="badges-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">Ã</button>
            <h2>CONQUISTAS</h2>
            <p>Desbloqueie badges completando desafios!</p>
            <div id="achievements-list"></div>
            <button class="modal-button" id="close-badges" style="margin-top: 20px;">Fechar</button>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div id="changelog-modal" class="ui-modal">
        <div class="modal-content">
            <button id="changelog-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">Ã</button>
            <h2>Notas de AtualizaÃ§Ã£o</h2>
            <div id="changelog-content">
                <h3>[v7.9] â Resgate e LiberaÃ§Ã£o (Melhoria da Comunidade)</h3>
                <ul>
                    <li><strong>Sistema de Resgate de Inimigos Aprimorado:</strong> Atendendo ao feedback, o sistema anti-frustraÃ§Ã£o foi redesenhado para ser mais dinÃ¢mico.
                        <ul>
                            <li>Agora, em vez de serem destruÃ­dos, os inimigos presos sÃ£o puxados para o topo da tela e **imediatamente liberados** para atacar o jogador, garantindo que a aÃ§Ã£o nunca pare.</li>
                            <li>Inimigos sÃ£o **totalmente vulnerÃ¡veis a dano durante o processo de resgate**, corrigindo um bug que os tornava invulnerÃ¡veis enquanto eram puxados.</li>
                            <li>A lÃ³gica de eliminaÃ§Ã£o automÃ¡tica foi removida para favorecer uma experiÃªncia de jogo mais direta e focada no combate.</li>
                        </ul>
                    </li>
                    <li><strong>AtualizaÃ§Ã£o de VersÃ£o:</strong> A versÃ£o do jogo e do salvamento foi atualizada para `7.9` para incorporar as novas mudanÃ§as.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.8] â Sistema Anti-FrustraÃ§Ã£o e CorreÃ§Ãµes Gerais</h3>
                <ul>
                    <li><strong>Novo Sistema de Resgate de Inimigos:</strong> Implementado um novo sistema "Anti-FrustraÃ§Ã£o" para evitar que partidas fiquem travadas.
                        <ul>
                            <li>Se 1 inimigo permanecer vivo por mais de 5 segundos sem sofrer dano, ele serÃ¡ puxado gradualmente para o topo da tela.</li>
                            <li>Se 2 inimigos permanecerem vivos por mais de 10 segundos sem sofrer dano, ambos serÃ£o puxados.</li>
                            <li>Uma vez na Ã¡rea de resgate, se o inimigo nÃ£o for atingido em um novo intervalo de tempo (10s para 1 inimigo, 5s para 2 inimigos), ele serÃ¡ destruÃ­do automaticamente, permitindo que a onda prossiga.</li>
                            <li>Atacar um inimigo durante o processo de resgate cancela a aÃ§Ã£o e o devolve ao combate normal.</li>
                        </ul>
                    </li>
                    <li><strong>CorreÃ§Ã£o de Bugs:</strong> Realizada uma revisÃ£o geral no cÃ³digo para corrigir pequenas inconsistÃªncias e melhorar a estabilidade, garantindo que as mecÃ¢nicas das versÃµes anteriores funcionem como esperado.</li>
                    <li><strong>AtualizaÃ§Ã£o do Save:</strong> O formato de salvamento foi atualizado para a v7.8. Dados de versÃµes anteriores serÃ£o resetados para garantir compatibilidade com as novas mecÃ¢nicas.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.7] â CorreÃ§Ãµes CrÃ­ticas e Aprimoramentos Visuais</h3>
                <ul>
                    <li><strong>CorreÃ§Ã£o da Carta "Buraco Negro":</strong> O bug que fazia a carta "Buraco Negro" surgir no jogador em vez de no inimigo foi corrigido. Agora ela funciona conforme a descriÃ§Ã£o, criando um vÃ³rtice gravitacional no local do inimigo derrotado por acerto crÃ­tico, com todos os seus atributos (raio, duraÃ§Ã£o, dano) escalando corretamente.</li>
                    <li><strong>Melhoria no Resgate de Inimigos:</strong> O sistema de resgate de "inimigos fantasma" foi aperfeiÃ§oado. Agora, apenas inimigos comprovadamente fora da tela sÃ£o resgatados. Em vez de serem eliminados, eles sÃ£o puxados de forma gradual para o topo do cenÃ¡rio e sua IA Ã© reativada para que voltem a ser uma ameaÃ§a, tornando o jogo mais justo e dinÃ¢mico.</li>
                    <li><strong>ReorganizaÃ§Ã£o da UI em Jogo:</strong> O cronÃ´metro da partida agora tem uma posiÃ§Ã£o central e dedicada no topo da tela. O painel de informaÃ§Ãµes da partida foi movido para o canto superior direito para evitar sobreposiÃ§Ã£o. O botÃ£o "ConfiguraÃ§Ãµes" nÃ£o aparece mais incorretamente durante as partidas.</li>
                    <li><strong>Aprimoramentos Visuais de Cartas:</strong> Diversas cartas receberam novos ou melhores efeitos visuais para que seu impacto seja mais claro, incluindo rastros de fogo para "Catalisador", projÃ©teis translÃºcidos para "Balas Fantasma", e outros polimentos que enriquecem a experiÃªncia de jogo.</li>
                    <li><strong>VerificaÃ§Ã£o Geral de Funcionalidade:</strong> Foi realizada uma revisÃ£o completa para garantir que todas as cartas funcionam como descrito.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.6] â Polimento de Cartas e CorreÃ§Ãµes de Gameplay</h3>
                <ul>
                    <li><strong>ReformulaÃ§Ã£o da Carta "Buraco Negro":</strong> A carta lendÃ¡ria agora cria um buraco negro no local do inimigo derrotado por um acerto crÃ­tico, em vez de no jogador. O buraco negro puxa inimigos prÃ³ximos e causa dano contÃ­nuo (5% da vida mÃ¡xima a cada 0,5s). Acumular a carta aumenta a chance de criaÃ§Ã£o, o raio, a duraÃ§Ã£o, o dano e a frequÃªncia do dano.</li>
                    <li><strong>Melhorias Visuais e DinÃ¢micas em Todas as Cartas:</strong> Cada carta no jogo recebeu aprimoramentos em seus efeitos visuais e de jogabilidade para tornar cada escolha mais impactante e Ãºnica. Exemplos incluem:
                        <ul>
                            <li><strong>Catalisador:</strong> ProjÃ©teis agora tÃªm um rastro de fogo visÃ­vel.</li>
                            <li><strong>Agilidade:</strong> Deixa um rastro de vento mais denso.</li>
                            <li><strong>VisÃ£o Apurada:</strong> Cria um pulso de foco visual no jogador.</li>
                            <li><strong>Balas Fantasma:</strong> ProjÃ©teis ficam translÃºcidos.</li>
                            <li><strong>Ricochete:</strong> ProjÃ©teis mudam de cor e buscam inimigos apÃ³s ricochetear.</li>
                            <li>E muitas outras melhorias em todas as raridades!</li>
                        </ul>
                    </li>
                    <li><strong>CorreÃ§Ã£o do "Inimigo Fantasma":</strong> Implementado um sistema de seguranÃ§a para lidar com inimigos que ficam presos fora da tela. Se 1 a 3 inimigos restarem por mais de 3 segundos, eles sÃ£o movidos para o centro da tela. Se nÃ£o sofrerem dano por mais 10 segundos, sÃ£o eliminados automaticamente, permitindo que a onda prossiga.</li>
                    <li><strong>CorreÃ§Ã£o da FunÃ§Ã£o "Reiniciar Partida":</strong> Reiniciar uma partida agora cria uma nova instÃ¢ncia de jogo de forma limpa, usando as mesmas configuraÃ§Ãµes (HerÃ³i, Dificuldade, etc.) da partida anterior, sem causar aceleraÃ§Ã£o ou outros bugs. As escolhas aleatÃ³rias (ð²) sÃ£o mantidas.</li>
                    <li><strong>ReduÃ§Ã£o do Intervalo entre Ondas:</strong> O tempo de espera entre as ondas foi reduzido de 5 para 2 segundos, tornando o ritmo do jogo mais rÃ¡pido e dinÃ¢mico.</li>
                    <li><strong>Melhoria no Menu de InformaÃ§Ãµes:</strong> As descriÃ§Ãµes de todas as cartas, inimigos e mecÃ¢nicas no menu de informaÃ§Ãµes foram expandidas para serem significativamente mais detalhadas e explicativas.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.5] â Estabilidade e CorreÃ§Ãµes de Bugs CrÃ­ticos</h3>
                <ul>
                    <li><strong>CorreÃ§Ã£o de Bug CrÃ­tico (ReinÃ­cio):</strong> Resolvido um bug grave que causava a aceleraÃ§Ã£o do jogo a cada vez que a partida era reiniciada pelo menu de pausa. O estado do jogo agora Ã© reiniciado corretamente.</li>
                    <li><strong>CorreÃ§Ã£o de Bug CrÃ­tico (Controles Mobile):</strong> Corrigido um bug que impedia o funcionamento dos joysticks e o movimento do personagem ao escolher o modo "Celular".</li>
                    <li><strong>CorreÃ§Ã£o de UI:</strong> O painel de informaÃ§Ãµes da partida (HerÃ³i, Dificuldade, etc.) agora Ã© exibido corretamente desde o inÃ­cio do jogo, sem a necessidade de reiniciar.</li>
                    <li><strong>Melhoria na LÃ³gica de Conquistas:</strong> Aprimorada a lÃ³gica de desbloqueio de certas conquistas de progressÃ£o para garantir que sejam concedidas de forma mais confiÃ¡vel.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.4] â Melhorias de UX e Gameplay</h3>
                <ul>
                    <li><strong>Novo Fluxo de SeleÃ§Ã£o:</strong> As telas de seleÃ§Ã£o de HerÃ³i e Dificuldade agora iniciam com a opÃ§Ã£o do meio prÃ©-selecionada, agilizando o inÃ­cio do jogo.</li>
                    <li><strong>OpÃ§Ã£o "AleatÃ³rio ð²":</strong> Adicionada uma nova opÃ§Ã£o de seleÃ§Ã£o "AleatÃ³rio" para HerÃ³i, Dificuldade e Modo de Jogo, para quem gosta de surpresas.</li>
                    <li><strong>ConfirmaÃ§Ã£o de Modo:</strong> A tela de seleÃ§Ã£o de Modo de Jogo agora possui um botÃ£o "Selecionar Modo" para iniciar a partida, evitando inÃ­cios acidentais.</li>
                    <li><strong>InformaÃ§Ãµes em Jogo:</strong> Um novo painel de UI exibe o HerÃ³i, Dificuldade, Modo e Dispositivo escolhidos durante a partida.</li>
                    <li><strong>Melhoria nos Recordes:</strong> O HistÃ³rico de Partidas agora registra e exibe o HerÃ³i, o Dispositivo e se alguma das escolhas foi feita de forma aleatÃ³ria.</li>
                    <li><strong>Escolha AleatÃ³ria de Cartas:</strong> Adicionado um botÃ£o "ð² Escolha aleatÃ³ria" na tela de aprimoramento para selecionar uma das cartas disponÃ­veis ao acaso.</li>
                    <li><strong>Menus de ConfirmaÃ§Ã£o:</strong> Implementados modais de confirmaÃ§Ã£o para as opÃ§Ãµes "Reiniciar Partida" e "Voltar ao Menu" na tela de pausa, evitando aÃ§Ãµes acidentais.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.3] â Chefes TemÃ¡ticos e Melhorias Gerais</h3>
                <ul>
                    <li><strong>Chefes TemÃ¡ticos:</strong> Cada cenÃ¡rio temÃ¡tico (Neve, Deserto, Floresta, etc.) agora possui um Chefe Ãºnico com habilidades e visuais exclusivos, que aparece a cada 5 ondas, aumentando a variedade dos desafios.</li>
                    <li><strong>TransiÃ§Ã£o de CenÃ¡rio Aprimorada:</strong> A mudanÃ§a de tema durante o jogo agora acontece de forma gradual, com uma transiÃ§Ã£o de cores suave, tornando a experiÃªncia mais imersiva.</li>
                    <li><strong>Rebalanceamento das Melhorias Permanentes:</strong> Os bÃ´nus de Vida, Dano, Moedas e Sorte foram significativamente aumentados para que a progressÃ£o seja mais impactante e recompensadora.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.2] â CosmÃ©ticos, Inimigos e CenÃ¡rios</h3>
                <ul>
                    <li><strong>ExpansÃ£o de CosmÃ©ticos:</strong> Adicionados mais de 20 novos itens cosmÃ©ticos, incluindo chapÃ©us, rostos, cores, gradientes e formas.</li>
                    <li><strong>Novos Tipos de Inimigos:</strong> Introduzidos 5 novos inimigos com habilidades Ãºnicas.</li>
                    <li><strong>CenÃ¡rios TemÃ¡ticos:</strong> A cada 5 ondas, o visual do jogo muda, ciclando entre 10 temas de cores diferentes.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.1] â +30 Conquistas e Novas OpÃ§Ãµes GrÃ¡ficas</h3>
                <ul>
                    <li><strong>Sistema de Conquistas Expandido:</strong> Adicionadas mais de 30 novas conquistas.</li>
                    <li><strong>ConfiguraÃ§Ãµes GrÃ¡ficas AvanÃ§adas:</strong> O menu de configuraÃ§Ãµes agora inclui mais opÃ§Ãµes para customizar a experiÃªncia visual.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.0] â UI de dificuldade e modos</h3>
                <ul>
                    <li><strong>Novos Menus de SeleÃ§Ã£o:</strong> Adicionados menus para escolher a Dificuldade e o Modo de Jogo.</li>
                </ul>
                 <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v6.9] â Rebalanceamento e +10 cartas</h3>
                <ul>
                    <li><strong>Rebalanceamento Geral:</strong> Muitas cartas baseadas em porcentagem foram rebalanceadas.</li>
                    <li><strong>+10 Novas Cartas:</strong> Adicionadas 10 novas cartas com mecÃ¢nicas Ãºnicas.</li>
                </ul>
                 <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v6.8] - Recordes e RevisÃ£o do Menu</h3>
                <ul>
                    <li><strong>Novo Sistema de Recordes.</strong></li>
                    <li><strong>RevisÃ£o do Menu Principal.</strong></li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Menu de ConfiguraÃ§Ãµes -->
    <div id="settings-modal" class="ui-modal">
        <div class="modal-content">
            <button id="settings-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">Ã</button>
            <h2>CONFIGURAÃÃES</h2>

            <div class="setting-option" style="flex-direction: column; align-items: stretch; border-bottom: none;">
                <label style="margin-bottom: 10px; text-align: center; color: #ffcc00;">Presets GrÃ¡ficos</label>
                <div class="graphics-presets">
                    <button class="preset-button" id="preset-low">Baixo</button>
                    <button class="preset-button" id="preset-medium">MÃ©dio</button>
                    <button class="preset-button" id="preset-high">Alto</button>
                </div>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            
            <div class="setting-option">
                <label>Sombras</label>
                <input type="checkbox" id="shadows-setting" checked>
            </div>
            <div class="setting-option">
                <label>Efeitos de Sangue</label>
                <input type="checkbox" id="blood-setting" checked>
            </div>
             <div class="setting-option">
                <label>Tremor de Tela</label>
                <input type="range" id="screenshake-intensity" min="0" max="10" value="8">
            </div>
            <div class="setting-option">
                <label>Intensidade de PartÃ­culas</label>
                <input type="range" id="particle-intensity" min="0" max="10" value="7">
            </div>
            <div class="setting-option">
                <label>Intensidade de Rastros</label>
                <input type="range" id="trail-intensity" min="0" max="10" value="7">
            </div>
            <div class="setting-option">
                <label>Intensidade Efeitos de Cartas</label>
                <input type="range" id="card-effect-intensity" min="0" max="10" value="8">
            </div>

            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                <label>Estilo do Nametag</label>
                <select id="nametag-style">
                    <option value="simple">Simples</option>
                    <option value="background">Com Fundo</option>
                </select>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                <label style="color: #ff5555; font-weight: bold;">Ativar Recursos de Cheat</label>
                <input type="checkbox" id="cheat-features-setting">
            </div>
            <div id="cheat-settings-container" style="display: none; padding-left: 20px; border-left: 2px solid #ff5555; margin-top: 10px;">
                <div class="setting-option">
                    <label>Definir Moedas:</label>
                    <input type="number" id="set-coins-input" style="width: 120px;">
                </div>
                 <div class="setting-option">
                    <label>Desbloquear Conquistas:</label>
                    <button class="cheat-button" id="unlock-all-achievements-btn" style="width: auto; margin-top:0;">Desbloquear</button>
                </div>
                 <div class="setting-option">
                    <label>Maximizar Melhorias:</label>
                    <button class="cheat-button" id="max-all-upgrades-btn" style="width: auto; margin-top:0;">Maximizar</button>
                </div>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                 <label style="color: #f44336; font-weight: bold;">Apagar Dados do Jogo</label>
                 <button class="modal-button delete-data-button" id="delete-data-btn">Apagar Dados</button>
            </div>

            <button class="modal-button" id="apply-settings" style="margin-top: 20px;">Aplicar e Fechar</button>
        </div>
    </div>
    
    <!-- MODAIS DO JOGO -->

    <!-- 1. Nickname Modal -->
    <div id="nickname-modal" class="ui-modal">
        <div class="modal-content">
            <h1 class="game-title">CubeChaos</h1>
            <div id="splash-text-nickname"></div>
            <h2>Defina seu Nickname</h2>
            <p>Seu nome de guerra para enfrentar as hordas!</p>
            <input type="text" id="nickname-input" placeholder="Entre 3 e 12 caracteres" maxlength="12">
            <div id="nickname-error"></div>
            <button id="confirm-nickname-button" class="modal-button">Confirmar</button>
        </div>
    </div>
    
    <!-- 2. Main Menu Modal -->
    <div id="main-menu-modal" class="ui-modal">
        <div class="modal-content">
            <div class="main-menu-layout">
                <!-- Painel Esquerdo (AÃ§Ãµes) -->
                <div class="main-menu-left-panel">
                    <h1 class="game-title">CubeChaos</h1>
                    <div id="main-menu-nickname"></div>
                    <div id="main-menu-coins-display">Moedas: <span id="main-menu-coins-value">0</span></div>
                    
                    <button id="play-button" class="main-menu-button play-button">â¶ï¸ Iniciar</button>
                    <button id="customize-character-button" class="main-menu-button">ð¨ Personalizar</button>
                    <button id="permanent-upgrades-button" class="main-menu-button">â¨ Melhorias</button>
                    <button id="show-badges-main" class="main-menu-button">
                        ð Conquistas <span id="main-menu-achievement-counter" class="achievement-counter-badge"></span>
                    </button>
                </div>
                
                <!-- Painel Central (Preview) -->
                <div class="main-menu-center-panel">
                    <canvas id="characterPreviewCanvas" width="200" height="200"></canvas>
                </div>
                
                <!-- Painel Direito (InformaÃ§Ãµes e Recordes) -->
                <div class="main-menu-right-panel">
                    <div id="best-record-display">
                        <h3>ð Melhor Recorde</h3>
                        <p>Onda: <span id="best-record-wave">--</span></p>
                        <p>Abates: <span id="best-record-kills">--</span></p>
                        <p>Tempo: <span id="best-record-time">--:--</span></p>
                    </div>
                    <button id="show-records-button" class="main-menu-button">ð HistÃ³rico de Partidas</button>
                    <button id="show-info-button" class="main-menu-button">â¹ï¸ InformaÃ§Ãµes</button>
                    <button id="tutorial-button" class="main-menu-button">ð Tutorial</button>
                    <button id="show-settings" class="main-menu-button">âï¸ ConfiguraÃ§Ãµes</button>
                    <button id="changelog-button" class="main-menu-button">ð Changelog [v7.9]</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. Records Modal -->
    <div id="records-modal" class="ui-modal">
        <div class="modal-content">
            <button id="records-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">Ã</button>
            <h2>HistÃ³rico de Partidas</h2>
            <p>Sua jornada de sobrevivÃªncia registrada, da melhor para a pior.</p>
            <div id="records-list-container">
                <table id="records-table">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>HerÃ³i</th>
                            <th>Dificuldade</th>
                            <th>Modo</th>
                            <th>Onda</th>
                            <th>Abates</th>
                            <th>Tempo</th>
                            <th>Dispositivo</th>
                        </tr>
                    </thead>
                    <tbody id="records-table-body"></tbody>
                </table>
            </div>
             <button class="modal-button" id="close-records" style="margin-top: 20px;">Fechar</button>
        </div>
    </div>

    <!-- 4. Info Modal -->
    <div id="info-modal" class="ui-modal">
        <div class="modal-content">
            <button id="info-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">Ã</button>
            <h2>InformaÃ§Ãµes do Jogo</h2>
             <div class="info-tabs">
                <button data-tab="info-cards" class="active">Cartas</button>
                <button data-tab="info-enemies">Inimigos</button>
                <button data-tab="info-scenarios">CenÃ¡rios</button>
                <button data-tab="info-tech">MecÃ¢nicas</button>
                <button data-tab="info-controls">Controles</button>
            </div>
            <div id="info-content-panel"></div>
        </div>
    </div>

    <div id="customization-modal" class="ui-modal">
        <div class="modal-content">
            <button class="cheat-button" id="back-to-main-menu-from-customization" style="position: absolute; top: 15px; right: 15px; width: auto; background: #78909c;">Voltar</button>
            <h2>Personalizar Personagem</h2>
            <div id="customization-coins" style="text-align: right; margin-bottom: 15px; font-size: 1.2em; color: #ffcc00;">Moedas: 0</div>
            <div class="customization-container">
                <div class="customization-sections">
                    <div class="customization-tabs">
                        <button data-tab="shapes" id="shapes-tab-button" class="active">Formas</button>
                        <button data-tab="hats" id="hats-tab-button">ChapÃ©us</button>
                        <button data-tab="colors" id="colors-tab-button">Cores</button>
                        <button data-tab="faces" id="faces-tab-button">Rostos</button>
                    </div>
                    <div id="shapes-options" class="customization-options-grid"></div>
                    <div id="hats-options" class="customization-options-grid" style="display: none;"></div>
                    <div id="colors-options" class="customization-options-grid" style="display: none;"></div>
                     <div id="faces-options" class="customization-options-grid" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="permanent-upgrades-modal" class="ui-modal">
        <div class="modal-content">
            <button class="cheat-button" id="back-to-main-menu-from-upgrades" style="position: absolute; top: 15px; right: 15px; width: auto; background: #78909c;">Voltar</button>
            <h2>Melhorias Permanentes</h2>
            <p>Use suas moedas para fortalecer seu personagem para sempre!</p>
            <div id="permanent-upgrades-coins" style="text-align: right; margin-bottom: 15px; font-size: 1.2em; color: #ffcc00;">Moedas: 0</div>
            
            <div class="permanent-upgrades-list" id="permanent-upgrades-list"></div>
        </div>
    </div>

    <!-- Modais de SeleÃ§Ã£o -->
    <div id="difficulty-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione a Dificuldade</h2>
            <p>A dificuldade afeta a forÃ§a dos inimigos e os seus atributos.</p>
            <div class="character-selection" id="difficulty-selection-cards">
                <div class="character-card" data-difficulty="easy">
                    <div class="character-icon">ð</div>
                    <div class="character-name">FÃ¡cil</div>
                    <div class="character-description">Inimigos mais fracos, jogador mais forte. Ideal para aprender.</div>
                </div>
                <div class="character-card" data-difficulty="normal">
                    <div class="character-icon">ð</div>
                    <div class="character-name">Normal</div>
                    <div class="character-description">A experiÃªncia balanceada.</div>
                </div>
                <div class="character-card" data-difficulty="hard">
                    <div class="character-icon">ð</div>
                    <div class="character-name">DifÃ­cil</div>
                    <div class="character-description">Um verdadeiro desafio cÃ³smico. Sem modificadores.</div>
                </div>
                <div class="character-card" data-difficulty="random">
                    <div class="character-icon">ð²</div>
                    <div class="character-name">AleatÃ³rio</div>
                    <div class="character-description">Deixe o caos decidir o seu destino.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-difficulty" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-difficulty" class="modal-button" disabled>Confirmar Dificuldade</button>
            </div>
        </div>
    </div>

    <div id="gamemode-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione o Modo de Jogo</h2>
            <p>AtÃ© onde vocÃª consegue chegar?</p>
            <div class="character-selection" id="gamemode-selection-cards">
                <div class="character-card" data-gamemode="waves">
                    <div class="character-icon">ð</div>
                    <div class="character-name">100 Ondas</div>
                    <div class="character-description">Sobreviva a 100 ondas para alcanÃ§ar a vitÃ³ria.</div>
                </div>
                <div class="character-card" data-gamemode="infinite">
                    <div class="character-icon">â¾ï¸</div>
                    <div class="character-name">Infinito</div>
                    <div class="character-description">Sobreviva o mÃ¡ximo que puder. NÃ£o hÃ¡ fim.</div>
                </div>
                <div class="character-card" data-gamemode="random">
                    <div class="character-icon">ð²</div>
                    <div class="character-name">AleatÃ³rio</div>
                    <div class="character-description">Uma surpresa a cada partida.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-gamemode" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-gamemode" class="modal-button" disabled>Selecionar Modo</button>
            </div>
        </div>
    </div>

    <div id="device-selection-modal" class="ui-modal">
        <div class="modal-content">
            <h1>Como vocÃª quer jogar?</h1>
            <div id="device-choices">
                <button id="desktop-button" class="modal-button">ð¥ï¸ Computador</button>
                <button id="mobile-button" class="modal-button">ð± Celular</button>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-device" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
            </div>
        </div>
    </div>

    <div id="device-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Confirmar Dispositivo</h2>
            <p id="confirmation-text">AtenÃ§Ã£o: ApÃ³s confirmar, esta escolha nÃ£o poderÃ¡ ser alterada nesta sessÃ£o.</p>
            <div id="device-choices">
                <button id="confirm-device-yes" class="modal-button">Sim, continuar</button>
                <button id="confirm-device-no" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">NÃ£o, voltar</button>
            </div>
        </div>
    </div>
    
    <div id="delete-data-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #f44336;">Apagar Todos os Dados?</h2>
            <p>Esta aÃ§Ã£o Ã© irreversÃ­vel e irÃ¡ apagar:</p>
            <ul style="list-style: none; padding: 10px; text-align: left; max-width: 300px; margin: 10px auto; background: rgba(0,0,0,0.2); border-radius: 5px;">
                <li>- Todas as Moedas</li>
                <li>- Todas as Conquistas</li>
                <li>- Todas as Melhorias Permanentes</li>
                <li>- Todos os Itens CosmÃ©ticos</li>
                <li>- Todo o HistÃ³rico de Partidas</li>
                <li>- Seu Nickname</li>
            </ul>
            <p>VocÃª tem certeza?</p>
            <div class="selection-footer-buttons">
                <button id="confirm-delete-data-yes" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Sim, apagar dados</button>
                <button id="confirm-delete-data-no" class="modal-button">NÃ£o, manter dados</button>
            </div>
        </div>
    </div>

    <div id="cheat-features-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff5555;">Ativar Recursos de Cheat?</h2>
            <p>Ativar esta opÃ§Ã£o lhe darÃ¡ acesso a configuraÃ§Ãµes que podem alterar fundamentalmente a experiÃªncia de jogo. Use por sua conta e risco!</p>
            <div class="selection-footer-buttons">
                <button id="confirm-cheat-features-yes" class="modal-button">Sim, ativar</button>
                <button id="confirm-cheat-features-no" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Cancelar</button>
            </div>
        </div>
    </div>
    
    <div id="character-selection-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione seu HerÃ³i</h2>
            <p>Escolha um personagem com habilidades Ãºnicas</p>
            
            <div class="character-selection" id="character-selection-cards">
                <div class="character-card" data-character="warrior">
                    <div class="character-icon">ð¡ï¸</div>
                    <div class="character-name">GuardiÃ£o</div>
                    <div class="character-description">+20% de vida, defesa aumentada</div>
                </div>
                
                <div class="character-card" data-character="archer">
                    <div class="character-icon">ð¹</div>
                    <div class="character-name">Atirador</div>
                    <div class="character-description">+30% de velocidade de ataque</div>
                </div>
                
                <div class="character-card" data-character="mage">
                    <div class="character-icon">ð®</div>
                    <div class="character-name">Mago</div>
                    <div class="character-description">Habilidades especiais recarregam mais rÃ¡pido</div>
                </div>
                <div class="character-card" data-character="random">
                    <div class="character-icon">ð²</div>
                    <div class="character-name">AleatÃ³rio</div>
                    <div class="character-description">Comece com um herÃ³i surpresa.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-character" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-character" class="modal-button" disabled>Confirmar HerÃ³i</button>
            </div>
        </div>
    </div>
    
    <div id="pause-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ffcc00;">JOGO PAUSADO</h2>
            <div style="display: flex; flex-direction: column; gap: 15px; align-items: center; margin-top: 30px;">
                 <button id="resume-game-button" class="modal-button">Retornar ao Jogo</button>
                 <button id="pause-restart-button" class="modal-button">Reiniciar Partida</button>
                 <button id="show-badges-pause" class="modal-button" style="background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%);">
                     ð Conquistas <span id="pause-menu-achievement-counter" class="achievement-counter-badge"></span>
                 </button>
                 <button id="return-to-menu-button" class="modal-button" style="background: linear-gradient(135deg, #ff9800 0%, #ef6c00 100%);">Voltar ao Menu</button>
            </div>
        </div>
    </div>

    <!-- Modais de ConfirmaÃ§Ã£o do Pause -->
    <div id="restart-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff9800;">Reiniciar Partida?</h2>
            <p>Todo o progresso desta partida serÃ¡ perdido.</p>
            <div class="selection-footer-buttons">
                <button id="confirm-restart-yes" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Sim, Reiniciar Partida</button>
                <button id="confirm-restart-no" class="modal-button">NÃ£o, Manter Partida</button>
            </div>
        </div>
    </div>

    <div id="return-to-menu-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff9800;">Voltar ao Menu Principal?</h2>
            <p>Sua partida atual serÃ¡ encerrada e os resultados salvos.</p>
            <div class="selection-footer-buttons">
                <button id="confirm-return-to-menu-yes" class="modal-button" style="background: linear-gradient(135deg, #ff9800 0%, #ef6c00 100%);">Voltar ao Menu</button>
                <button id="confirm-return-to-menu-no" class="modal-button">Permanecer no Jogo</button>
            </div>
        </div>
    </div>

    <div id="upgrade-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #4caf50;">NÃ­vel AlcanÃ§ado!</h2>
            <p>Escolha um aprimoramento:</p>
            <div id="upgrade-choices"></div>
            <div id="upgrade-modal-actions">
                <button id="roll-upgrades-button" class="modal-button" style="background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%); font-size: 1em;">Rolar (ð° 50)</button>
                <button id="random-upgrade-button" class="modal-button" style="background: linear-gradient(135deg, #9c27b0 0%, #6a1b9a 100%); font-size: 1em;">ð² Escolha aleatÃ³ria</button>
                <button id="skip-upgrade-button" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%); font-size: 1em;">NÃ£o pegar cartas</button>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen" class="ui-modal">
         <div class="modal-content">
            <h1 style="color: #f44336;">Fim de Jogo</h1>
            <h3 id="final-stats"></h3>
            <h3 id="game-over-details" style="color: #ccc; font-size: 1.1em;"></h3>
            <div class="meta-progression" style="margin: 20px 0;">
                <div class="progression-item">
                    <div class="progression-label">Onda AlcanÃ§ada</div>
                    <div class="progression-value" id="final-wave">0</div>
                </div>
                <div class="progression-item">
                    <div class="progression-label">Inimigos Derrotados</div>
                    <div class="progression-value" id="final-kills">0</div>
                </div>
                 <div class="progression-item">
                    <div class="progression-label">XP Total</div>
                    <div class="progression-value" id="final-xp">0</div>
                </div>
                <div class="progression-item">
                    <div class="progression-label">Moedas Ganhas</div>
                    <div class="progression-value" id="final-coins">0</div>
                </div>
            </div>
            <button id="return-to-menu-from-gameover" class="modal-button">Voltar ao Menu Principal</button>
        </div>
    </div>
    
    <div id="victory-modal" class="ui-modal">
         <div class="modal-content" style="border-color: #ffd700; box-shadow: 0 0 50px #ffd700;">
            <h1 style="color: #ffd700;">VITÃRIA!</h1>
            <h2>VocÃª conquistou o Caos CÃ³smico!</h2>
            <p>VocÃª sobreviveu a 100 ondas e provou ser o maior guerreiro. Como recompensa, vocÃª ganhou 250 moedas extras e uma conquista lendÃ¡ria!</p>
            <button id="return-to-menu-from-victory" class="modal-button" style="background: linear-gradient(135deg, #ffc107 0%, #ffa000 100%);">Voltar ao Menu Principal</button>
        </div>
    </div>
    
    <div class="controls-hint" id="controls-hint"></div>
    
    <div id="tutorial-modal" class="tutorial-overlay" style="display: none;">
        <div class="tutorial-content">
            <h2 style="color: #4caf50; margin-bottom: 20px;">Tutorial do CubeChaos</h2>
            
            <div class="tutorial-section">
                <h3>Objetivo do Jogo</h3>
                <p>Sobreviva ao maior nÃºmero possÃ­vel de ondas de inimigos. Derrote inimigos, colete XP e escolha aprimoramentos para se tornar mais forte.</p>
            </div>
            
            <div class="tutorial-section">
                <h3>Controles</h3>
                <div class="tutorial-controls">
                    <div class="control-item">
                        <div class="control-icon">ââ / A/D</div>
                        <div>Movimento</div>
                    </div>
                    <div class="control-item">
                        <div class="control-icon">ESPAÃO</div>
                        <div>Pular</div>
                    </div>
                    <div class="control-item">
                        <div class="control-icon">ð±ï¸ CLIQUE</div>
                        <div>Atirar</div>
                    </div>
                </div>
                 <p>Em dispositivos mÃ³veis, use os joysticks virtuais que aparecerÃ£o na tela.</p>
            </div>
            
            <div class="tutorial-section">
                <h3>Gameplay</h3>
                <p>â¢ Colete orbes de XP para subir de nÃ­vel e escolher novas cartas de aprimoramento.</p>
                <p>â¢ Fique atento aos chefes a cada 5 ondas, eles sÃ£o mais fortes e resistentes!</p>
                <p>â¢ Use moedas ganhas nas partidas para comprar personalizaÃ§Ãµes e melhorias permanentes no menu principal!</p>
            </div>
            
            <button id="close-tutorial" class="modal-button">Voltar</button>
        </div>
    </div>

<script>
// ===================================================================================
// 1. CONFIGURAÃÃES GLOBAIS E CONSTANTES AJUSTÃVEIS
// ===================================================================================
const CONFIG = {
    WIDTH: 1280, 
    HEIGHT: 720, 
    GRAVITY: 0.8,
    GROUND_SEGMENT_WIDTH: 8,
    GROUND_BASE_HEIGHT: 650,
    GROUND_ROUGHNESS: 0.015,
    GROUND_AMPLITUDE: 25,
    PLATFORM_COUNT: 7, 
    PLATFORM_WIDTH_MIN: 100,
    PLATFORM_WIDTH_MAX: 160,
    PLATFORM_HEIGHT: 20,
    PLATFORM_MIN_Y: 400, 
    PLATFORM_MAX_Y: 600, 
    PLATFORM_MIN_X_DIST: 180, 
    COLOR_ENEMY: '#f44336', 
    COLOR_PLAYER_PROJECTILE: '#ff9800', 
    COLOR_ENEMY_PROJECTILE: '#ff4081',
    STAR_COUNT: 400,
    PARTICLE_COUNT: 20,
    WAVE_SPAWN_COOLDOWN: 2000, 
    WAVE_ENEMY_MULTIPLIER: 1.5,
    COIN_DROP_CHANCE: 0.3, 
    WAVE_BONUS_COIN_MULTIPLIER: 2 
};

// Cores do CenÃ¡rio (v7.2)
const THEMES = {
    default: { name: "PadrÃ£o CÃ³smico", boss_type: 'boss_default', bg: ['#0a0a2a', '#1a1a4a'], ground: '#3a4a5a', ground_top: '#4a5a6a', platform: '#5a6a8a' },
    city: { name: "Cidade Noturna", boss_type: 'boss_city', bg: ['#2c3e50', '#485563'], ground: '#34495e', ground_top: '#7f8c8d', platform: '#95a5a6' },
    snow: { name: "Pico Nevado", boss_type: 'boss_snow', bg: ['#e0eafc', '#cfdef3'], ground: '#ffffff', ground_top: '#bdc3c7', platform: '#ecf0f1' },
    forest: { name: "Floresta Densa", boss_type: 'boss_forest', bg: ['#134e5e', '#71b280'], ground: '#5c4033', ground_top: '#6b8e23', platform: '#8fbc8f' },
    aurora: { name: "Aurora Boreal", boss_type: 'boss_aurora', bg: ['#0f2027', '#2c5364'], ground: '#1d2b3a', ground_top: '#526b86', platform: '#3e517a' },
    space: { name: "Vazio Sideral", boss_type: 'boss_space', bg: ['#000000', '#434343'], ground: '#2d3436', ground_top: '#636e72', platform: '#b2bec3' },
    water: { name: "Praia Tropical", boss_type: 'boss_water', bg: ['#1c92d2', '#f2fcfe'], ground: '#f0e68c', ground_top: '#ffd700', platform: '#add8e6' },
    desert: { name: "Deserto Ardente", boss_type: 'boss_desert', bg: ['#ffc371', '#ff5f6d'], ground: '#d2b48c', ground_top: '#cdaa7d', platform: '#f0e68c' },
    flowers: { name: "Campo Florido", boss_type: 'boss_flowers', bg: ['#f8b500', '#fceabb'], ground: '#4caf50', ground_top: '#8bc34a', platform: '#ffc0cb' },
    cave: { name: "Caverna de Cristal", boss_type: 'boss_cave', bg: ['#302b63', '#24243e'], ground: '#4a4a4a', ground_top: '#6b6b6b', platform: '#808080' },
};
let currentTheme = THEMES.default;
let frameColors = { ...THEMES.default };
let themeTransition = { active: false, progress: 0, duration: 3000, from: null, to: null };


// ConfiguraÃ§Ãµes visuais
const VISUAL_SETTINGS = {
    shadows: true,
    blood: true,
    screenShakeIntensity: 8,
    particleIntensity: 7,
    trailIntensity: 7,
    cardEffectIntensity: 8,
    nametagStyle: 'simple',
    cheatFeaturesEnabled: false,
};

// ===================================================================================
// 1.5. CUSTOMIZATION & METAPROGRESSION DATA
// ===================================================================================
let PLAYER_CUSTOMIZATION = {
    nickname: 'Jogador',
    ownedShapes: ['shape_square'],
    ownedHats: ['hat_none'],
    ownedColors: ['color_green_default'],
    ownedFaces: ['face_zero', 'face_smile'], 
    equippedShape: 'shape_square',
    equippedHat: 'hat_none',
    equippedColor: 'color_green_default',
    equippedFace: 'face_zero', 
};

let PLAYER_PERMANENT_UPGRADES = {}; 
let PLAYER_RECORDS = [];

// FunÃ§Ãµes de desenho para formas
function drawShapeSquare(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }
function drawShapeCircle(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x + w/2, y + h/2, Math.min(w,h)/2, 0, Math.PI * 2); ctx.fill(); }
function drawShapeTriangle(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x + w, y + h); ctx.lineTo(x, y + h); ctx.closePath(); ctx.fill(); }
function drawShapeStar(ctx, cx_offset, cy_offset, w, h, color) { 
    const spikes = 5, outerRadius = Math.min(w,h) / 2, innerRadius = outerRadius / 2;
    const cx = cx_offset + w/2, cy = cy_offset + h/2;
    let rot = Math.PI / 2 * 3, cur_x = cx, cur_y = cy, step = Math.PI / spikes;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        cur_x = cx + Math.cos(rot) * outerRadius; cur_y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(cur_x, cur_y); rot += step;
        cur_x = cx + Math.cos(rot) * innerRadius; cur_y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(cur_x, cur_y); rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
}
function drawShapePentagon(ctx, x, y, w, h, color) {
    const radius = Math.min(w, h) / 2; const cx = x + w / 2; const cy = y + h / 2;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
    for (let i = 1; i <= 5; i++) { ctx.lineTo(cx + radius * Math.cos(i * 2 * Math.PI / 5), cy + radius * Math.sin(i * 2 * Math.PI / 5)); }
    ctx.closePath(); ctx.fill();
}
function drawShapeHexagon(ctx, x, y, w, h, color) {
    const radius = Math.min(w, h) / 2; const cx = x + w / 2; const cy = y + h / 2;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx + radius, cy);
    for (let i = 1; i <= 6; i++) { ctx.lineTo(cx + radius * Math.cos(i * Math.PI / 3), cy + radius * Math.sin(i * Math.PI / 3)); }
    ctx.closePath(); ctx.fill();
}
function drawShapeGear(ctx, x, y, w, h, color) {
    const spikes = 8, outerRadius = Math.min(w,h) / 2, innerRadius = outerRadius * 0.7;
    const cx = x + w/2, cy = y + h/2; let rot = 0;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx, cy);
    for (let i = 0; i < spikes; i++) {
        rot = i * 2 * Math.PI / spikes;
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
        rot += Math.PI / (spikes * 2);
        ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
        rot += Math.PI / (spikes * 2);
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
    }
    ctx.closePath(); ctx.fill();
}
function drawShapeCross(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; const armWidth = w / 3;
    ctx.fillRect(x + armWidth, y, armWidth, h); ctx.fillRect(x, y + armWidth, w, armWidth);
}
function drawShapeDiamond(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x + w / 2, y); ctx.lineTo(x + w, y + h / 2);
    ctx.lineTo(x + w / 2, y + h); ctx.lineTo(x, y + h / 2); ctx.closePath(); ctx.fill();
}
function drawShapeHeart(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(x + w / 2, y + h / 4); ctx.arc(x + w / 4, y + h / 4, w / 4, 0, Math.PI, true);
    ctx.arc(x + w * 3 / 4, y + h / 4, w / 4, 0, Math.PI, true); ctx.lineTo(x + w / 2, y + h);
    ctx.closePath(); ctx.fill();
}
function drawShapeCapsule(ctx, x, y, w, h, color) {
    const r = h / 2; ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.arc(x + w - r, y + r, r, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(x + r, y + h); ctx.arc(x + r, y + r, r, Math.PI / 2, -Math.PI / 2); ctx.closePath(); ctx.fill();
}

function drawHatEmoji(ctx, playerX, playerY, playerW, playerH, emoji) {
    if (!emoji || emoji === "ð«") return;
    const hatSize = playerW * 0.7; ctx.font = `${hatSize}px Arial`; 
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const hatX = playerX + playerW / 2; const hatY = playerY - playerH * 0.1;
    ctx.fillText(emoji, hatX, hatY);
}
function drawPlayerFace(ctx, playerX, playerY, playerW, playerH, faceText, faceColor, facingDirection) {
    if (!faceText) return;
    ctx.fillStyle = faceColor;
    const baseFontSize = playerH * 0.25;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const lines = faceText.split('|');
    const lineHeight = baseFontSize * (lines.length > 1 ? 0.8 : 1);
    ctx.font = `bold ${lineHeight}px 'Courier New', monospace`;
    const totalTextHeight = lines.length * lineHeight;
    let startY = playerY + playerH / 2 - totalTextHeight / 2 + lineHeight / 2;
    const horizontalOffset = playerW * 0.05 * facingDirection;
    lines.forEach((line, index) => {
        ctx.fillText(line, playerX + playerW / 2 + (line.length === 1 ? horizontalOffset : 0) , startY + index * lineHeight);
    });
}

const SHAPES_CATALOG = [
    { id: 'shape_square', name: 'Quadrado', price: 0, asset: drawShapeSquare },
    { id: 'shape_circle', name: 'CÃ­rculo', price: 200, asset: drawShapeCircle },
    { id: 'shape_triangle', name: 'TriÃ¢ngulo', price: 200, asset: drawShapeTriangle },
    { id: 'shape_star', name: 'Estrela', price: 500, asset: drawShapeStar },
    { id: 'shape_diamond', name: 'Diamante', price: 600, asset: drawShapeDiamond },
    { id: 'shape_capsule', name: 'CÃ¡psula', price: 600, asset: drawShapeCapsule },
    { id: 'shape_heart', name: 'CoraÃ§Ã£o', asset: drawShapeHeart, unlockAchievement: 'heart_shape_unlock' },
    { id: 'shape_pentagon', name: 'PentÃ¡gono', asset: drawShapePentagon, unlockAchievement: 'pentagon_shape_unlock' },
    { id: 'shape_hexagon', name: 'HexÃ¡gono', asset: drawShapeHexagon, unlockAchievement: 'hexagon_shape_unlock' },
    { id: 'shape_gear', name: 'Engrenagem', asset: drawShapeGear, unlockAchievement: 'gear_shape_unlock' },
    { id: 'shape_cross', name: 'Cruz', asset: drawShapeCross, unlockAchievement: 'cross_shape_unlock' },
];

const HATS_CATALOG = [
    { id: 'hat_none', name: 'Nenhum', price: 0, emoji: "ð«" },
    { id: 'hat_party', name: 'ChapÃ©u de Sol', price: 250, emoji: "ð" },
    { id: 'hat_tophat', name: 'Cartola', price: 250, emoji: "ð©" },
    { id: 'hat_crown', name: 'Coroa', price: 1000, emoji: "ð" },
    { id: 'hat_idea', name: 'Ideia', price: 300, emoji: "ð­" },
    { id: 'hat_bell', name: 'Sino', price: 300, emoji: "ð" },
    { id: 'hat_balloon', name: 'BalÃ£o', price: 400, emoji: "ð" },
    { id: 'hat_clock', name: 'RelÃ³gio', price: 400, emoji: "â°" },
    { id: 'hat_sleep', name: 'Soneca', emoji: "ð¤", unlockAchievement: 'sleep_hat_unlock' },
    { id: 'hat_question', name: 'DÃºvida', emoji: "âï¸", unlockAchievement: 'question_hat_unlock' },
    { id: 'hat_bomb', name: 'BombÃ¡stico', emoji: "ð£", unlockAchievement: 'bomb_hat_unlock' },
    { id: 'hat_moneybag', name: 'Magnata', emoji: "ð°", unlockAchievement: 'money_face_unlock' },
    { id: 'hat_trophy', name: 'CampeÃ£o', emoji: "ð", unlockAchievement: 'win_hard' },
    { id: 'hat_gamer', name: 'Gamer', emoji: "ð¹", unlockAchievement: 'gamer_hat_unlock' },
    { id: 'hat_grad', name: 'Graduado', emoji: "ð", unlockAchievement: 'grad_hat_unlock' },
    { id: 'hat_rescue', name: 'Resgate', emoji: "â", unlockAchievement: 'rescue_hat_unlock' },
    { id: 'hat_box', name: 'Caixa', emoji: "ð¦", unlockAchievement: 'box_hat_unlock' },
    { id: 'hat_books', name: 'Leitor', emoji: "ð", unlockAchievement: 'books_hat_unlock' },
    { id: 'hat_coffee', name: 'Cafeinado', emoji: "âï¸", unlockAchievement: 'coffee_hat_unlock' },
];

const COLORS_CATALOG = [
    { id: 'color_green_default', name: 'Verde PadrÃ£o', price: 0, value: '#4caf50' },
    { id: 'color_red', name: 'Vermelho Fogo', price: 100, value: '#f44336' },
    { id: 'color_blue', name: 'Azul Celeste', price: 100, value: '#2196F3' },
    { id: 'color_yellow', name: 'Amarelo Solar', price: 100, value: '#FFEB3B' },
    { id: 'color_purple', name: 'Roxo MÃ­stico', price: 150, value: '#9C27B0' },
    { id: 'color_pink', name: 'Rosa Chiclete', price: 150, value: '#E91E63' },
    { id: 'color_cyan', name: 'Ciano', price: 120, value: '#00BCD4' },
    { id: 'color_orange', name: 'Laranja', price: 120, value: '#FF9800' },
    { id: 'color_lime', name: 'Lima', price: 120, value: '#CDDC39' },
    { id: 'color_indigo', name: 'Ãndigo', price: 180, value: '#3F51B5' },
    { id: 'color_teal', name: 'Verde-azulado', price: 180, value: '#009688' },
    { id: 'color_lava', name: 'Lava', value: ['#ff4800', '#ffb400'], unlockAchievement: 'lava_color_unlock' },
    { id: 'color_toxic', name: 'TÃ³xico', value: ['#7fff00', '#abff00'], unlockAchievement: 'toxic_color_unlock' },
    { id: 'color_ice', name: 'Gelo', value: ['#00ffff', '#ffffff'], unlockAchievement: 'ice_color_unlock' },
    { id: 'color_sunset', name: 'PÃ´r do Sol', value: ['#ff9800', '#f44336'], unlockAchievement: 'sunset_color_unlock' },
    { id: 'color_ocean', name: 'Oceano', value: ['#00BCD4', '#2196F3'], unlockAchievement: 'ocean_color_unlock' },
    { id: 'color_forest', name: 'Floresta', value: ['#4CAF50', '#8BC34A'], unlockAchievement: 'forest_color_unlock' },
    { id: 'color_aurora', name: 'Aurora', value: ['#9C27B0', '#00BCD4'], unlockAchievement: 'aurora_color_unlock' },
    { id: 'color_royal', name: 'Realeza', value: ['#673AB7', '#FFC107'], unlockAchievement: 'royal_color_unlock' },
    { id: 'color_void', name: 'Vazio', value: ['#212121', '#424242'], unlockAchievement: 'void_color_unlock' },
];

const FACES_CATALOG = [
    { id: 'face_zero', name: 'Zumbi', price: 0, text: "0_0" },
    { id: 'face_smile', name: 'Sorriso', price: 50, text: ":)" },
    { id: 'face_cat', name: 'Gatinho', price: 150, text: ":3" },
    { id: 'face_shrug', name: 'Indiferente', price: 250, text: "Â¯\\_ã_/Â¯" },
    { id: 'face_kiss', name: 'Beijinho', price: 250, text: "^3^" },
    { id: 'face_lenny', name: 'Lenny', price: 500, text: "(Í¡Â°ÍÊÍ¡Â°)" },
    { id: 'face_bear', name: 'Ursinho', text: "Êâ¢á´¥â¢Ê", unlockAchievement: 'bear_face_unlock' },
    { id: 'face_crying', name: 'ChorÃ£o', text: "T_T", unlockAchievement: 'crying_face_unlock' },
    { id: 'face_money', name: 'MilionÃ¡rio', text: "$o$", unlockAchievement: 'money_face_unlock' },
    { id: 'face_sad', name: 'Quase lÃ¡', text: ";-;", unlockAchievement: 'sad_face_unlock' },
    { id: 'face_uwu', name: 'Fofura', text: "UnU", unlockAchievement: 'uwu_face_unlock' },
    { id: 'face_dizzy', name: 'Tonto', text: "@q@", unlockAchievement: 'dizzy_face_unlock' },
    { id: 'face_rage', name: 'FÃºria', text: ">0<", unlockAchievement: 'rage_face_unlock' },
    { id: 'face_error', name: 'Erro 404', text: "#-#", unlockAchievement: 'error_face_unlock' },
];

const PERMANENT_UPGRADES_CATALOG = {
    'perm_hp': { name: 'Vitalidade CÃ³smica', description: '+5% Vida MÃ¡xima base por nÃ­vel.', maxLevel: 10, cost: (level) => 100 * Math.pow(level + 1, 1.6), effect: (level) => 1 + level * 0.05 },
    'perm_dmg': { name: 'ForÃ§a Bruta', description: '+2.5% Dano base por nÃ­vel.', maxLevel: 10, cost: (level) => 150 * Math.pow(level + 1, 1.7), effect: (level) => 1 + level * 0.025 },
    'perm_coins': { name: 'Sorte do Magnata', description: '+4% Moedas ganhas por nÃ­vel.', maxLevel: 10, cost: (level) => 200 * Math.pow(level + 1, 1.5), effect: (level) => 1 + level * 0.04 },
    'perm_luck': { name: 'Olho de Lince', description: '+1% Chance de crÃ­tico base por nÃ­vel.', maxLevel: 5, cost: (level) => 500 * Math.pow(level + 1, 1.9), effect: (level) => 0 + level * 0.01 },
};


const SPLASH_TEXTS = [
    "Agora com mais polÃ­gonos!",
    "Cuidado com os chefes!",
    "Colete todas as cartas!",
    "NÃ£o Ã© um bug, Ã© uma feature!",
    "Tente sobreviver!",
    "100% mais dinÃ¢mico!",
    "Experimente as melhorias permanentes!",
    "Visite o GitHub!",
    "Pressione P para pausar... Ah, nÃ£o, Ã© um botÃ£o!",
    "Mais de 4 lados!",
    "Splash text!",
];

// ===================================================================================
// 2. BANCO DE DADOS DE CONTEÃDO (UPGRADES, INIMIGOS E CONQUISTAS)
// ===================================================================================
const UPGRADES = {
    // COMMON
    'Catalyst': { name: 'Catalisador', description: 'Dano do ProjÃ©til +2. Adiciona uma aura de fogo.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.projectileDamage += 2; p.stats.catalyst.stacks++; }, scaling: 'Dano base do projÃ©til aumenta em 2. A aura de fogo ao redor do jogador e o rastro de fogo dos projÃ©teis se tornam mais intensos.' },
    'Growth': { name: 'Crescimento', description: 'Vida MÃ¡xima +10. Deixa um leve rastro verde.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.maxHp += 10; p.hp += 10; p.stats.growth.stacks++; }, scaling: 'Aumenta a Vida MÃ¡xima em 10. O jogador cresce ligeiramente em tamanho e o rastro de partÃ­culas verdes se torna mais denso.' },
    'Swift': { name: 'Agilidade', description: 'Velocidade de Movimento +5%. Deixa um rastro de vento.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.moveSpeed += (p.baseStats.moveSpeed * 0.05); p.stats.swift.stacks++; }, scaling: 'Aumenta a velocidade de movimento em 5% do valor base. O rastro de "vento" (partÃ­culas brancas) deixado ao se mover fica mais longo e espesso.' },
    'Resonance': { name: 'RessonÃ¢ncia', description: 'Velocidade de Ataque +8%. Deixa um rastro fantasma.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.attackSpeed *= 0.92; p.stats.resonance.stacks++; }, scaling: 'Reduz o tempo de recarga do ataque em 8% (multiplicativo). O nÃºmero de "fantasmas" (imagens residuais) que seguem o jogador aumenta.' },
    'Renew': { name: 'RenovaÃ§Ã£o', description: 'Cura 25% da vida mÃ¡xima instantaneamente.', rarity: 'common', maxStacks: 50, apply: p => { const healAmount = p.stats.maxHp * 0.25; p.hp = Math.min(p.stats.maxHp, p.hp + healAmount); if(VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(p.x + p.width/2, p.y + p.height/2, 30, 'lightgreen')); }, scaling: 'Cura instantaneamente 25% da sua Vida MÃ¡xima atual. O efeito visual da cura se torna mais forte a cada uso.' },

    // UNCOMMON
    'Eyesight': { name: 'VisÃ£o Apurada', description: 'Chance de CrÃ­tico +5%. Gera um brilho de foco.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.critChance += 0.05; p.stats.eyesight.stacks++; }, scaling: 'Aumenta a chance de acerto crÃ­tico em 5%. Um pulso de luz amarela emana do jogador, com frequÃªncia e intensidade crescentes.' },
    'Gush': { name: 'Impulso', description: '+1 Pulo extra. O pulo solta mais partÃ­culas.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.maxJumps++; }, scaling: 'Adiciona um pulo extra. A explosÃ£o de partÃ­culas ao pular se torna maior e mais colorida.' },
    'Charge': { name: 'Carga', description: 'Tamanho do ProjÃ©til +15%.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.projectileSize *= 1.15; }, scaling: 'Aumenta o tamanho dos projÃ©teis em 15% (multiplicativo). O projÃ©til se torna visivelmente maior.' },
    'Leech': { name: 'Sanguessuga', description: 'Concede 5% de Roubo de Vida, com efeito visual.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.lifesteal += 0.05; }, scaling: 'Converte 5% do dano causado em cura. PartÃ­culas vermelhas visÃ­veis viajam do inimigo atingido de volta para o jogador.' },
    'Magnetic Field': { name: 'Campo MagnÃ©tico', description: 'Aumenta o raio de atraÃ§Ã£o de XP. O campo se torna visÃ­vel.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.magneticField.range += 20; }, scaling: 'Aumenta o raio de coleta de XP e moedas em 20. Um anel azul translÃºcido ao redor do jogador indica a Ã¡rea de atraÃ§Ã£o, e ele se expande a cada acÃºmulo.' },
    'MultiShot': { name: 'Tiro MÃºltiplo', description: 'Adiciona +1 projÃ©til. A "arma" brilha mais forte.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.projectileCount++; }, scaling: 'Adiciona um projÃ©til extra a cada disparo, em um pequeno leque. Um brilho na ponta da "arma" do jogador fica mais intenso.' },
    'GhostBullets': { name: 'Balas Fantasma', description: 'ProjÃ©teis tÃªm 10% de chance de atravessar paredes. Aumenta a chance.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.ghostBullets.enabled = true; p.stats.ghostBullets.chance += 0.1; }, scaling: 'Concede 10% de chance de um projÃ©til se tornar "fantasma" e atravessar paredes. ProjÃ©teis fantasmas sÃ£o translÃºcidos e deixam um rastro etÃ©reo.' },

    // RARE
    'Precision': { name: 'PrecisÃ£o', description: 'Dano CrÃ­tico +25%. Acertos crÃ­ticos sÃ£o maiores e mais brilhantes.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.critDamage += 0.25; }, scaling: 'Aumenta o multiplicador de dano crÃ­tico em 25%. ProjÃ©teis crÃ­ticos se tornam maiores e a explosÃ£o de partÃ­culas no impacto Ã© mais violenta.' },
    'Rage': { name: 'FÃºria', description: 'Dano aumenta em 50% com vida baixa. Uma aura vermelha pulsa.', rarity: 'rare', maxStacks: 1, apply: p => { p.stats.rage.enabled = true; }, scaling: 'Quando sua vida estÃ¡ abaixo de 30%, vocÃª ganha 50% de dano adicional. Uma aura vermelha pulsante e agressiva aparece ao redor do jogador. NÃ£o acumula.' },
    'Barrier': { name: 'Barreira', description: 'Um escudo bloqueia o prÃ³ximo dano. Recarga -5%.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.barrier.enabled = true; p.stats.barrier.cooldown *= 0.95; }, scaling: 'Cria uma barreira que bloqueia um ataque. A recarga diminui em 5% (multiplicativo). Uma esfera ciano visÃ­vel protege o jogador quando a barreira estÃ¡ ativa.' },
    'Appraisal': { name: 'AvaliaÃ§Ã£o', description: '+1 opÃ§Ã£o de upgrade ao subir de nÃ­vel.', rarity: 'rare', maxStacks: 1, apply: p => { p.stats.upgradeChoices++; }, scaling: 'Aumenta o nÃºmero de escolhas de cartas ao subir de nÃ­vel de 3 para 4. NÃ£o acumula.' },
    'Blood Ritual': { name: 'Ritual SanguÃ­neo', description: 'Inimigos tÃªm +5% de chance de soltar um orbe de cura.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.bloodRitual.chance += 0.05; }, scaling: 'Adiciona 5% de chance de inimigos derrotados deixarem um orbe de cura (verde). A chance aumenta a cada acÃºmulo.' },
    'FrostNova': { name: 'Nova Congelante', description: 'Ao ser atingido, libera uma onda congelante. Aumenta a duraÃ§Ã£o.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.frostNova.enabled = true; p.stats.frostNova.duration += 200; }, scaling: 'Ao sofrer dano, emite uma onda que congela inimigos prÃ³ximos. A duraÃ§Ã£o do congelamento aumenta em 200ms. O efeito visual da explosÃ£o de gelo se torna maior.' },
    'VampiricExplosion': { name: 'ExplosÃ£o VampÃ­rica', description: 'Inimigos derrotados tÃªm 10% de chance de explodir, curando vocÃª em 2% da vida mÃ¡xima.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.vampiricExplosion.enabled = true; p.stats.vampiricExplosion.chance += 0.10; p.stats.vampiricExplosion.healPercent += 0.02; }, scaling: 'Adiciona 10% de chance de inimigos explodirem em energia vampÃ­rica, curando 2% da sua vida mÃ¡xima. A chance e a cura aumentam a cada acÃºmulo.' },
    'ShockwaveJump': { name: 'Salto Trovejante', description: 'Ao aterrissar, cria uma onda de choque que causa 5 de dano. Aumenta o dano e o raio.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.shockwaveJump.enabled = true; p.stats.shockwaveJump.damage += 5; p.stats.shockwaveJump.radius += 10; }, scaling: 'Cria uma onda de choque visÃ­vel ao aterrissar. Dano aumenta em 5 e o raio em 10.' },
    'GravityWell': { name: 'PoÃ§o Gravitacional', description: 'ProjÃ©teis tÃªm 10% de chance de criar um pequeno poÃ§o gravitacional ao atingir um inimigo.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.gravityWell.enabled = true; p.stats.gravityWell.chance += 0.1; }, scaling: 'Adiciona 10% de chance de um projÃ©til criar um vÃ³rtice roxo que puxa inimigos prÃ³ximos. AcÃºmulos aumentam a chance.' },
    
    // EPIC
    'LaserPet': { name: 'Pet de Combate', description: 'Invoca um pet que atira. Aumenta o dano do pet.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.laserPet.count = Math.min(6, (p.upgrades['LaserPet'] || 0) + 1); p.stats.laserPet.damage += 2; }, scaling: 'Invoca um pet orbital rosa que atira nos inimigos. Adiciona +1 pet e +2 de dano por carta, atÃ© um mÃ¡ximo de 6 pets.' },
    'Fragmentation+': { name: 'FragmentaÃ§Ã£o+', description: 'Inimigos explodem em +1 projÃ©til ao morrer.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.fragmentation.enabled = true; p.stats.fragmentation.count += 1; }, scaling: 'Inimigos derrotados explodem em uma rajada de projÃ©teis teleguiados. Adiciona +1 projÃ©til Ã  explosÃ£o.' },
    'Piercing': { name: 'PerfuraÃ§Ã£o', description: 'ProjÃ©teis atravessam +1 inimigo.', rarity: 'epic', maxStacks: 50, apply: p => {p.stats.piercing.enabled = true; p.stats.piercing.hits++;}, scaling: 'Permite que seus projÃ©teis atravessem um inimigo adicional. O projÃ©til deixa um rastro de dano visÃ­vel atravÃ©s dos inimigos perfurados.' },
    'Ricochet': { name: 'Ricochete', description: '+1 rebote para os projÃ©teis. Eles mudam de cor ao ricochetear.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.ricochet.enabled = true; p.stats.ricochet.maxBounces++; }, scaling: 'Permite que seus projÃ©teis ricocheteiem nas paredes. Adiciona +1 ricochete. ApÃ³s ricochetear, o projÃ©til muda de cor para ciano e busca o inimigo mais prÃ³ximo.' },
    'TempAlliance': { name: 'AlianÃ§a TemporÃ¡ria', description: '+5% de chance de converter inimigos. Aliados duram mais.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.tempAlliance.chance += 0.05; p.stats.tempAlliance.duration += 100; }, scaling: 'Adiciona 5% de chance de converter um inimigo derrotado para lutar ao seu lado. A duraÃ§Ã£o do aliado aumenta em 100ms. Aliados convertidos brilham em verde.' },
    'OrbitalShield': { name: 'Escudo Orbital', description: 'Cria um escudo orbital. Adiciona +1 a cada 3 nÃ­veis.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.orbitalShield.count = Math.floor((p.upgrades['OrbitalShield'] || 0) / 3) + 1; p.stats.orbitalShield.speed += 0.1; }, scaling: 'Cria um escudo ciano que orbita vocÃª e destrÃ³i projÃ©teis inimigos. A cada 3 acÃºmulos, um novo escudo Ã© adicionado e a velocidade de rotaÃ§Ã£o aumenta.' },
    'SingularityCore': { name: 'NÃºcleo de Singularidade', description: 'Emite um pulso de energia a cada 4 segundos, causando dano. Aumenta o dano e diminui o tempo.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.singularityCore.enabled = true; p.stats.singularityCore.damage += 8; p.stats.singularityCore.cooldown = Math.max(500, p.stats.singularityCore.cooldown * 0.95); }, scaling: 'Emite um pulso de energia roxa ao seu redor. Dano aumenta em 8 e a recarga diminui em 5% (multiplicativo).' },
    'HolyRetribution': { name: 'RetribuiÃ§Ã£o Divina', description: 'Ao ser atingido, invoca 2 raios de luz vingativos sobre inimigos aleatÃ³rios.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.holyRetribution.enabled = true; p.stats.holyRetribution.count += 2; }, scaling: 'Ao sofrer dano, raios de luz dourada caem do cÃ©u sobre os inimigos. Adiciona 2 raios por acÃºmulo.' },
    'MirageClones': { name: 'Clones de Miragem', description: 'A cada 10 segundos, cria 1 clone que atrai o fogo inimigo. Aumenta o nÃºmero de clones.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.mirageClones.enabled = true; p.stats.mirageClones.count += 1; }, scaling: 'Cria clones translÃºcidos de si mesmo que confundem os inimigos. Adiciona +1 clone por acÃºmulo.' },
    'OuroborosRounds': { name: 'MuniÃ§Ã£o Ouroboros', description: 'ProjÃ©teis que nÃ£o atingem nada por 2s tÃªm 10% de chance de retornar a vocÃª.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.ouroborosRounds.enabled = true; p.stats.ouroborosRounds.chance += 0.1; }, scaling: 'Adiciona 10% de chance de projÃ©teis perdidos retornarem, buscando o jogador. O projÃ©til muda de cor ao iniciar o retorno.' },

    // LEGENDARY
    'Black Hole': { name: 'Buraco Negro', description: '+5% de chance em acerto crÃ­tico de criar um buraco negro.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.blackHole.enabled = true; p.stats.blackHole.chance += 0.05; p.stats.blackHole.radius += 10; p.stats.blackHole.duration += 500; p.stats.blackHole.damagePercent += 0.01; p.stats.blackHole.tickRate *= 0.95; }, scaling: 'Chance de +5% em acerto crÃ­tico de criar um buraco negro no inimigo. Aumenta raio (+10), duraÃ§Ã£o (+0.5s), dano (+1% maxHP) e velocidade do dano (-5% intervalo).' },
    'Thunderbolt': { name: 'RelÃ¢mpago', description: 'A cada 5s, invoca +1 raio que atinge inimigos.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.thunderbolt.enabled = true; p.stats.thunderbolt.count++; }, scaling: 'A cada 5 segundos, um raio poderoso atinge um inimigo aleatÃ³rio. Adiciona +1 raio por acÃºmulo.' },
    'GlassCannon': { name: 'CanhÃ£o de Vidro', description: '+100% de dano, -50% de vida mÃ¡xima.', rarity: 'legendary', maxStacks: 1, apply: p => { p.stats.projectileDamage *= 2; p.stats.maxHp *= 0.5; p.hp = Math.min(p.hp, p.stats.maxHp); }, scaling: 'Dobra todo o seu dano, mas reduz sua vida mÃ¡xima pela metade. Seu personagem fica com uma aparÃªncia rachada e translÃºcida. NÃ£o acumula.' },
    'ChainLightning': { name: 'Corrente de Raios', description: 'ProjÃ©teis tÃªm +5% de chance de criar um raio para um inimigo prÃ³ximo. +1 salto.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.chainLightning.enabled = true; p.stats.chainLightning.chance += 0.05; p.stats.chainLightning.bounces++; }, scaling: 'Adiciona 5% de chance de um projÃ©til gerar uma corrente de raios que salta para outros inimigos. Adiciona +1 salto por acÃºmulo.' },
    'QuantumEntanglement': { name: 'Emaranhamento QuÃ¢ntico', description: 'O dano causado Ã© compartilhado em 5% para atÃ© 2 outros inimigos aleatÃ³rios.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.quantumEntanglement.enabled = true; p.stats.quantumEntanglement.sharePercent += 0.05; p.stats.quantumEntanglement.targets += 1; }, scaling: 'Compartilha 5% do dano com 1 alvo adicional. VÃ­nculos de energia roxa conectam os inimigos afetados. A porcentagem de dano e o nÃºmero de alvos aumentam.' },
    'TimeWarp': { name: 'Dobra Temporal', description: 'Acertos crÃ­ticos tÃªm 10% de chance de desacelerar todos os inimigos em 50% por 2s.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.timeWarp.enabled = true; p.stats.timeWarp.chance += 0.1; }, scaling: 'Adiciona 10% de chance de acertos crÃ­ticos ativarem uma desaceleraÃ§Ã£o global do tempo. Um filtro azul e distorÃ§Ã£o visual aparecem na tela durante o efeito.' },
};
const ORIGINAL_UPGRADES = JSON.parse(JSON.stringify(UPGRADES)); // For resetting max stacks

const ENEMY_TYPES = {
    // Minions
    'grunt': { name: 'Soldado', hp: 10, speed: 2, size: 30, color: '#f44336', attackCooldown: 2500, behavior: 'standard', expValue: 1, description: 'A unidade bÃ¡sica do exÃ©rcito inimigo. Fraco individualmente, mas perigoso em grandes nÃºmeros. Ataca o jogador diretamente.' },
    'grunt_mini': { name: 'Soldado Mini', hp: 5, speed: 2.5, size: 15, color: '#ff7961', attackCooldown: 2500, behavior: 'standard', expValue: 0, description: 'Um fragmento menor e mais rÃ¡pido de um inimigo maior. NÃ£o concede experiÃªncia.' },
    'tank': { name: 'Tanque', hp: 50, speed: 1, size: 50, color: '#d32f2f', attackCooldown: 4000, behavior: 'standard', expValue: 3, description: 'Lento, mas extremamente resistente. Seu corpo retangular Ã© projetado para absorver dano e proteger unidades mais fracas atrÃ¡s dele.' },
    'shooter': { name: 'Atirador', hp: 15, speed: 1.5, size: 35, color: '#ff8a80', attackCooldown: 1500, behavior: 'standard', expValue: 2, description: 'MantÃ©m distÃ¢ncia do jogador e dispara projÃ©teis de um cano lateral. Prioriza o posicionamento para atacar de longe.' },
    'flyer': { name: 'Voador', hp: 8, speed: 3, size: 25, color: '#ffaa00', attackCooldown: 3000, behavior: 'flying', expValue: 2, description: 'Ignora o terreno e voa diretamente em direÃ§Ã£o ao jogador. Sua forma triangular indica sua agilidade e dificuldade de ser atingido.' },
    'bomber': { name: 'Bombardeiro', hp: 25, speed: 1.2, size: 40, color: '#ff6600', attackCooldown: 5000, behavior: 'standard', expValue: 4, description: 'Solta projÃ©teis explosivos que causam dano em Ã¡rea. Uma luz piscante em seu corpo sinaliza um ataque iminente.' },
    'elite': { name: 'Elite Hexagonal', hp: 80, speed: 1.8, size: 45, color: '#ab47bc', attackCooldown: 1200, behavior: 'flying', expValue: 5, description: 'Uma versÃ£o voadora e aprimorada do Atirador. Ã rÃ¡pido, resistente e dispara com alta frequÃªncia, sendo uma grande ameaÃ§a.' },
    'bouncer': { name: 'Rebatedor', hp: 20, speed: 2.2, size: 30, color: '#4dd0e1', attackCooldown: 1800, behavior: 'standard', expValue: 3, description: 'Especialista em caos, dispara projÃ©teis que ricocheteiam nas paredes, tornando o campo de batalha imprevisÃ­vel e perigoso.' },
    'exploder': { name: 'Explosivo', hp: 30, speed: 1.5, size: 40, color: '#ffd54f', attackCooldown: 99999, behavior: 'kamikaze', expValue: 4, description: 'NÃ£o ataca. Em vez disso, corre em direÃ§Ã£o ao jogador e, ao ser derrotado, explode em uma cruz de energia estÃ¡tica que causa dano.' },
    'healer': { name: 'Curandeiro', hp: 40, speed: 1.2, size: 35, color: '#a5d6a7', attackCooldown: 3000, behavior: 'support', expValue: 5, description: 'Uma unidade de suporte vital. Tenta evitar o combate direto e emite pulsos de cura que regeneram a vida de todos os inimigos prÃ³ximos.' },
    'teleporter': { name: 'Saltador QuÃ¢ntico', hp: 15, speed: 2, size: 28, color: '#b39ddb', attackCooldown: 2000, behavior: 'teleporting', expValue: 4, description: 'Extremamente evasivo. Move-se de forma errÃ¡tica, teleportando-se em curtas distÃ¢ncias a cada poucos segundos, tornando-se um alvo difÃ­cil.' },
    'splitter': { name: 'Divisor', hp: 60, speed: 1, size: 55, color: '#90a4ae', attackCooldown: 5000, behavior: 'standard', expValue: 6, description: 'Um inimigo grande e lento. Ao ser derrotado, sua massa se divide em dois Soldados Mini, continuando a luta.' },
    
    // Bosses
    'boss_default': { name: 'Chefe PadrÃ£o', hp: 200, speed: 0.8, size: 80, color: '#e53935', attackCooldown: 1000, behavior: 'standard', expValue: 20, isBoss: true, description: 'O primeiro grande desafio. Um inimigo massivo com alta vida e dano, servindo como um teste de forÃ§a para o jogador.' },
    'boss_snow': { name: 'Lorde Glacial', hp: 250, speed: 0.7, size: 85, color: '#81d4fa', attackCooldown: 2000, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'frost_nova', specialCooldown: 8000, description: 'Um chefe do Ã¡rtico. Dispara projÃ©teis que podem congelar o jogador e, periodicamente, libera uma devastadora Nova de Gelo em Ã¡rea.' },
    'boss_forest': { name: 'AnciÃ£o da Floresta', hp: 300, speed: 0.6, size: 90, color: '#66bb6a', attackCooldown: 2500, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'summon_minions', specialCooldown: 10000, description: 'Um guardiÃ£o ancestral e resistente. Sua tÃ¡tica Ã© sobrecarregar o jogador, invocando hordas de Soldados para lutar ao seu lado.' },
    'boss_desert': { name: 'Elemental de Fogo', hp: 180, speed: 1.2, size: 75, color: '#ffa726', attackCooldown: 800, behavior: 'flying', expValue: 25, isBoss: true, specialAttack: 'fire_trail', specialCooldown: 5000, description: 'RÃ¡pido, aÃ©reo e agressivo. Persegue o jogador incansavelmente, deixando um rastro de chamas que causa dano contÃ­nuo.' },
    'boss_cave': { name: 'Golias de Cristal', hp: 400, speed: 0.5, size: 95, color: '#7e57c2', attackCooldown: 1500, behavior: 'standard', expValue: 30, isBoss: true, specialAttack: 'crystal_shot', specialCooldown: 6000, description: 'Uma fortaleza ambulante. Extremamente resistente, seus projÃ©teis se fragmentam em mÃºltiplos estilhaÃ§os ao atingir uma parede ou o jogador.' },
    'boss_city': { name: 'Sentinela Urbana', hp: 220, speed: 0.9, size: 80, color: '#78909c', attackCooldown: 900, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'laser_beam', specialCooldown: 7000, description: 'Um construto de precisÃ£o mortal. Periodicamente, dispara um feixe de laser horizontal que atravessa toda a tela, exigindo um pulo perfeito.' },
    'boss_aurora': { name: 'Espectro da Aurora', hp: 200, speed: 1.0, size: 80, color: '#9c27b0', attackCooldown: 1200, behavior: 'teleporting', expValue: 25, isBoss: true, specialAttack: 'clone', specialCooldown: 9000, description: 'Um mestre da ilusÃ£o. Teleporta-se pelo campo de batalha e cria clones de si mesmo para confundir e dividir a atenÃ§Ã£o do jogador.' },
    'boss_space': { name: 'Verme do Vazio', hp: 250, speed: 0.8, size: 85, color: '#616161', attackCooldown: 1300, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'gravity_pulse', specialCooldown: 8000, description: 'Manipulador da gravidade. Emite pulsos periÃ³dicos que puxam o jogador e seus projÃ©teis para perto, tornando a movimentaÃ§Ã£o difÃ­cil.' },
    'boss_water': { name: 'Kraken das MarÃ©s', hp: 280, speed: 0.7, size: 90, color: '#29b6f6', attackCooldown: 1800, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'geyser', specialCooldown: 6000, description: 'Controla a Ã¡gua para atacar. Invoca gÃªiseres de alta pressÃ£o que emergem do chÃ£o em locais aleatÃ³rios, pegando jogadores desatentos.' },
    'boss_flowers': { name: 'AbominaÃ§Ã£o Floral', hp: 200, speed: 0.9, size: 80, color: '#ec407a', attackCooldown: 1500, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'pollen_cloud', specialCooldown: 7000, description: 'Uma beleza mortal. Libera uma grande nuvem de pÃ³len que causa dano contÃ­nuo e obscurece a visÃ£o de quem estiver dentro dela.' },

};
const ACHIEVEMENTS = [
    // Kills
    { id: 'kills1', name: 'Primeiro Sangue', description: 'Mate seu primeiro inimigo.', rarity: 'common', target: 1, type: 'kills', reward: 5 },
    { id: 'kills50', name: 'CaÃ§ador Novato', description: 'Mate 50 inimigos.', rarity: 'common', target: 50, type: 'kills', reward: 10 },
    { id: 'kills250', name: 'CaÃ§ador Experiente', description: 'Mate 250 inimigos.', rarity: 'uncommon', target: 250, type: 'kills', reward: 25 },
    { id: 'kills1000', name: 'Exterminador', description: 'Mate 1000 inimigos em uma Ãºnica partida.', rarity: 'rare', target: 1000, type: 'kills', reward: 100 },
    
    // Waves & Survival
    { id: 'wave5', name: 'Sobrevivente', description: 'Sobreviva atÃ© a onda 5.', rarity: 'common', target: 5, type: 'wave', reward: 10 },
    { id: 'wave15', name: 'Veterano', description: 'Sobreviva atÃ© a onda 15.', rarity: 'uncommon', target: 15, type: 'wave', reward: 30 },
    { id: 'wave25', name: 'Lenda Viva', description: 'Sobreviva atÃ© a onda 25.', rarity: 'rare', target: 25, type: 'wave', reward: 75 },
    { id: 'cosmic_conqueror', name: 'Conquistador CÃ³smico', description: 'Chegue Ã  onda 101 e venÃ§a o jogo.', rarity: 'legendary', target: 101, type: 'wave', reward: 250 },
    { id: 'bosskiller1', name: 'Matador de Chefes', description: 'Derrote o primeiro chefe (Onda 5).', rarity: 'uncommon', target: 1, type: 'boss_kills', reward: 40 },
    
    // Gameplay Challenges
    { id: 'nodamage5', name: 'IntocÃ¡vel', description: 'Complete 5 ondas seguidas sem levar dano.', rarity: 'rare', target: 5, type: 'no_damage_waves', reward: 50 },
    { id: 'clutch', name: 'Por um Fio', description: 'Termine uma onda com menos de 10% de vida.', rarity: 'epic', target: 1, type: 'clutch_wave', reward: 70 },
    
    // Stats & Upgrades
    { id: 'level10', name: 'Poder Crescente', description: 'Alcance o nÃ­vel 10 em uma partida.', rarity: 'uncommon', target: 10, type: 'level', reward: 20 },
    { id: 'legendaryCard', name: 'Achado Raro', description: 'Obtenha sua primeira carta LendÃ¡ria.', rarity: 'rare', target: 1, type: 'collect_rarity', subtype: 'legendary', reward: 50 },
    
    // Meta Progression
    { id: 'firstpurchase', name: 'Primeira Compra', description: 'Compre seu primeiro item de personalizaÃ§Ã£o.', rarity: 'common', target: 1, type: 'first_purchase', reward: 10 },
    { id: 'spender', name: 'Gastador', description: 'Gaste um total de 1000 moedas.', rarity: 'uncommon', target: 1000, type: 'meta_spend', reward: 40 },
    
    // --- CONQUISTAS DE PERSONALIZAÃÃO (DINÃMICA) ---
    // HATS
    { id: 'gamer_hat_unlock', name: 'Aniquilador', description: 'Derrote 500 inimigos em uma Ãºnica partida.', rarity: 'uncommon', target: 500, type: 'kills', reward: 50, customizationReward: { type: 'hat', id: 'hat_gamer' } },
    { id: 'grad_hat_unlock', name: 'O Estudioso', description: 'Alcance o nÃ­vel 25 em uma partida.', rarity: 'rare', target: 25, type: 'level', reward: 100, customizationReward: { type: 'hat', id: 'hat_grad' } },
    { id: 'rescue_hat_unlock', name: 'IndestrutÃ­vel', description: 'Sobreviva a 3 ondas de chefes em uma partida.', rarity: 'rare', target: 3, type: 'boss_kills', reward: 150, customizationReward: { type: 'hat', id: 'hat_rescue' } },
    { id: 'box_hat_unlock', name: 'Colecionador de XP', description: 'Colete 100 orbes de XP em uma partida.', rarity: 'uncommon', target: 100, type: 'xp_orbs', reward: 50, customizationReward: { type: 'hat', id: 'hat_box' } },
    { id: 'books_hat_unlock', name: 'Mestre das Cartas', description: 'Tenha 10 cartas Ãºnicas diferentes em uma partida.', rarity: 'rare', target: 10, type: 'unique_cards', reward: 120, customizationReward: { type: 'hat', id: 'hat_books' } },
    { id: 'coffee_hat_unlock', name: 'Maratonista', description: 'Sobreviva por 15 minutos em uma Ãºnica partida.', rarity: 'epic', target: 900000, type: 'survival_time', reward: 200, customizationReward: { type: 'hat', id: 'hat_coffee' } },
    // COLORS
    { id: 'sunset_color_unlock', name: 'CrepÃºsculo', description: 'Derrote 50 inimigos do tipo Bombardeiro.', rarity: 'uncommon', target: 50, type: 'kill_type', subtype: 'bomber', reward: 60, customizationReward: { type: 'color', id: 'color_sunset' } },
    { id: 'ocean_color_unlock', name: 'Tsunami', description: 'Congele 100 inimigos com a Nova Congelante.', rarity: 'rare', target: 100, type: 'frozen_enemies', reward: 100, customizationReward: { type: 'color', id: 'color_ocean' } },
    { id: 'forest_color_unlock', name: 'GuardiÃ£o da Floresta', description: 'Cure 1000 de vida com Roubo de Vida ou Orbes de Cura.', rarity: 'uncommon', target: 1000, type: 'healing', reward: 75, customizationReward: { type: 'color', id: 'color_forest' } },
    { id: 'aurora_color_unlock', name: 'Luzes do Norte', description: 'Tenha um Pet de Combate e um Escudo Orbital ao mesmo tempo.', rarity: 'epic', target: 1, type: 'pet_and_shield', reward: 150, customizationReward: { type: 'color', id: 'color_aurora' } },
    { id: 'royal_color_unlock', name: 'Realeza', description: 'Gaste um total de 2500 moedas.', rarity: 'rare', target: 2500, type: 'meta_spend', reward: 100, customizationReward: { type: 'color', id: 'color_royal' } },
    { id: 'void_color_unlock', name: 'Abismo', description: 'Derrote 50 inimigos com Buracos Negros.', rarity: 'epic', target: 50, type: 'black_hole_kills', reward: 250, customizationReward: { type: 'color', id: 'color_void' } },
    // FACES
    { id: 'money_face_unlock', name: 'Magnata', description: 'Ganhe 500 moedas em uma Ãºnica partida.', rarity: 'rare', target: 500, type: 'coins_in_run', reward: 100, customizationReward: [{ type: 'face', id: 'face_money' }, { type: 'hat', id: 'hat_moneybag'}] },
    { id: 'sad_face_unlock', name: 'Quase lÃ¡', description: 'Morra em uma onda de chefe.', rarity: 'common', target: 1, type: 'death_on_boss_wave', reward: 20, customizationReward: { type: 'face', id: 'face_sad' } },
    { id: 'uwu_face_unlock', name: 'Amigo dos Animais', description: 'Tenha 6 pets de combate ao mesmo tempo.', rarity: 'epic', target: 6, type: 'stat_check', subtype: 'laserPet.count', reward: 150, customizationReward: { type: 'face', id: 'face_uwu' } },
    { id: 'dizzy_face_unlock', name: 'Ricocheteador', description: 'FaÃ§a 50 projÃ©teis rebaterem com la carta Ricochete.', rarity: 'uncommon', target: 50, type: 'ricochets', reward: 80, customizationReward: { type: 'face', id: 'face_dizzy' } },
    { id: 'rage_face_unlock', name: 'FÃºria ImplacÃ¡vel', description: 'Mate 20 inimigos enquanto estiver com o buff da carta FÃºria ativo.', rarity: 'rare', target: 20, type: 'rage_kills', reward: 90, customizationReward: { type: 'face', id: 'face_rage' } },
    { id: 'error_face_unlock', name: 'Quebrador de Limites', description: 'Cause mais de 1000 de dano em um Ãºnico acerto.', rarity: 'epic', target: 1000, type: 'single_hit_damage', reward: 200, customizationReward: { type: 'face', id: 'face_error' } },

    // --- CONQUISTAS DE FORMA (VFX E POLÃGONOS) ---
    { id: 'pentagon_shape_unlock', name: 'Penta-Kill', description: 'Mate 5 inimigos simultaneamente.', rarity: 'rare', target: 5, type: 'simultaneous_kills', reward: 150, customizationReward: { type: 'shape', id: 'shape_pentagon' } },
    { id: 'hexagon_shape_unlock', name: 'Muralha', description: 'Bloqueie 25 projÃ©teis com la Barreira em uma partida.', rarity: 'rare', target: 25, type: 'barrier_blocks', reward: 150, customizationReward: { type: 'shape', id: 'shape_hexagon' } },
    { id: 'gear_shape_unlock', name: 'Metralhadora', description: 'Alcance uma cadÃªncia de 10 tiros por segundo.', rarity: 'epic', target: 100, type: 'attack_speed_milestone', reward: 200, customizationReward: { type: 'shape', id: 'shape_gear' } },
    { id: 'cross_shape_unlock', name: 'Curandeiro', description: 'Cure um total de 2000 de vida em uma partida.', rarity: 'rare', target: 2000, type: 'healing', reward: 150, customizationReward: { type: 'shape', id: 'shape_cross' } },

    // --- NEW ACHIEVEMENTS (v7.1) ---
    // Difficulty / Mode
    { id: 'win_hard', name: 'Deus CÃ³smico', description: 'VenÃ§a o jogo (100 ondas) na dificuldade DifÃ­cil.', rarity: 'legendary', target: 1, type: 'win_condition', subtype: 'hard', reward: 500, customizationReward: { type: 'hat', id: 'hat_trophy' } },
    { id: 'wave50_infinite', name: 'Infinito e AlÃ©m', description: 'Alcance a onda 50 no modo Infinito.', rarity: 'epic', target: 50, type: 'wave_in_mode', subtype: 'infinite', reward: 200 },
    { id: 'wave20_hard', name: 'Sobrevivente Nato', description: 'Alcance a onda 20 no modo DifÃ­cil.', rarity: 'rare', target: 20, type: 'wave_in_difficulty', subtype: 'hard', reward: 150 },
    { id: 'win_no_commons', name: 'Purista', description: 'VenÃ§a o jogo (100 ondas) sem pegar nenhuma carta Comum.', rarity: 'epic', target: 1, type: 'win_condition_no_rarity', subtype: 'common', reward: 300 },
    { id: 'flawless_victory_easy', name: 'Passeio no Parque', description: 'VenÃ§a o jogo (100 ondas) no FÃ¡cil sem morrer.', rarity: 'uncommon', target: 1, type: 'win_no_deaths', subtype: 'easy', reward: 75 },

    // Card / Stat Combos
    { id: 'crit_master', name: 'Mestre do CrÃ­tico', description: 'Alcance 100% de chance de crÃ­tico em uma partida.', rarity: 'epic', target: 1.0, type: 'stat_milestone', subtype: 'critChance', reward: 150 },
    { id: 'health_tank', name: 'Tanque Imortal', description: 'Alcance 500 de Vida MÃ¡xima em uma partida.', rarity: 'rare', target: 500, type: 'stat_milestone', subtype: 'maxHp', reward: 100 },
    { id: 'glass_cannon_god', name: 'Deus de Vidro', description: 'VenÃ§a uma partida (100 ondas) com la carta CanhÃ£o de Vidro.', rarity: 'legendary', target: 1, type: 'win_with_card', subtype: 'GlassCannon', reward: 400 },
    { id: 'synergy_master', name: 'Mestre da Sinergia', description: 'Tenha Buraco Negro e PoÃ§o Gravitacional ao mesmo tempo.', rarity: 'epic', target: 1, type: 'card_combo', subtypes: ['Black Hole', 'GravityWell'], reward: 120 },
    { id: 'army_of_one', name: 'ExÃ©rcito de Um Homem SÃ³', description: 'Tenha 6 pets e 3 clones de miragem ao mesmo tempo.', rarity: 'epic', target: 1, type: 'card_combo', subtypes: ['LaserPet', 'MirageClones'], reward: 150 },
    { id: 'pacifist_wave', name: 'Onda Pacifista', description: 'Complete uma onda apÃ³s a onda 10 sem atirar (danos passivos permitidos).', rarity: 'rare', target: 1, type: 'no_shot_wave', reward: 100 },
    { id: 'stationary_threat', name: 'AmeaÃ§a EstacionÃ¡ria', description: 'Complete uma onda de chefe sem se mover horizontalmente.', rarity: 'epic', target: 1, type: 'no_move_boss_wave', reward: 180 },
    { id: 'reroll_addict', name: 'Viciado em Rolar', description: 'Use a opÃ§Ã£o de rolar cartas 5 vezes em uma Ãºnica partida.', rarity: 'uncommon', target: 5, type: 'rerolls_in_run', reward: 50 },
    { id: 'elite_conversion', name: 'ConversÃ£o de Elite', description: 'Converta um inimigo Elite com a AlianÃ§a TemporÃ¡ria.', rarity: 'rare', target: 1, type: 'convert_enemy_type', subtype: 'elite', reward: 90 },
    { id: 'boss_melter', name: 'Derretedor de Chefes', description: 'Derrote um chefe em menos de 10 segundos.', rarity: 'epic', target: 10000, type: 'fast_boss_kill', reward: 200 },
    
    // Meta / Collection
    { id: 'fashionista', name: 'Fashionista', description: 'Tenha todos os chapÃ©us.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'hats', reward: 100 },
    { id: 'shapeshifter', name: 'Metamorfo', description: 'Tenha todas as formas.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'shapes', reward: 100 },
    { id: 'chromatic', name: 'CromÃ¡tico', description: 'Tenha todas as cores.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'colors', reward: 100 },
    { id: 'expressive', name: 'Expressivo', description: 'Tenha todos os rostos.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'faces', reward: 100 },
    { id: 'max_out_perm', name: 'Mestre das Melhorias', description: 'Maximize uma melhoria permanente.', rarity: 'epic', target: 1, type: 'max_perm_upgrade', reward: 250 },
    { id: 'big_spender', name: 'Grande Gastador', description: 'Gaste um total de 5000 moedas.', rarity: 'rare', target: 5000, type: 'meta_spend', reward: 150 },
    { id: 'ten_wins', name: 'CampeÃ£o Consistente', description: 'VenÃ§a 10 partidas no total (qualquer dificuldade).', rarity: 'epic', target: 10, type: 'total_wins', reward: 200 },
    { id: 'first_hard_kill', name: 'Batismo de Fogo', description: 'Derrote seu primeiro inimigo na dificuldade DifÃ­cil.', rarity: 'uncommon', target: 1, type: 'first_kill_difficulty', subtype: 'hard', reward: 50 },
    { id: 'one_hp_wonder', name: 'Maravilha de 1 HP', description: 'Termine uma onda com exatamente 1 de HP.', rarity: 'epic', target: 1, type: 'one_hp_clutch', reward: 120 },
    { id: 'combo_wombo', name: 'Wombo Combo', description: 'Mate 15 inimigos em menos de 2 segundos.', rarity: 'legendary', target: 15, type: 'multi_kill_in_time', reward: 300 },
    { id: 'from_the_brink', name: 'Ã Beira do Abismo', description: 'Comece uma onda com menos de 10% de vida e termine com mais de 90%.', rarity: 'epic', target: 1, type: 'comeback_wave', reward: 150 },
    { id: 'specialist_common', name: 'Especialista Comum', description: 'Acumule 10 stacks de qualquer carta comum.', rarity: 'uncommon', target: 10, type: 'stack_rarity', subtype: 'common', reward: 60 },
    { id: 'specialist_epic', name: 'Especialista Ãpico', description: 'Acumule 5 stacks de qualquer carta Ã©pica.', rarity: 'rare', target: 5, type: 'stack_rarity', subtype: 'epic', reward: 130 },
    { id: 'untouchable_boss', name: 'Chefe IntocÃ¡vel', description: 'Derrote um chefe sem levar dano durante a onda dele.', rarity: 'epic', target: 1, type: 'no_damage_boss_wave', reward: 220 },
    { id: 'all_rounder', name: 'Generalista', description: 'Tenha pelo menos uma carta de cada raridade em uma partida.', rarity: 'rare', target: 1, type: 'all_rarities_in_run', reward: 100 },
    
    // --- NEW ACHIEVEMENTS (v7.2) ---
    { id: 'heart_shape_unlock', name: 'Amor Ã  Vida', description: 'Cure 5000 de vida no total.', rarity: 'rare', target: 5000, type: 'total_healing', reward: 150, customizationReward: { type: 'shape', id: 'shape_heart' } },
    { id: 'sleep_hat_unlock', name: 'ImÃ³vel', description: 'Sobreviva a 3 ondas apÃ³s a onda 10 sem se mover.', rarity: 'epic', target: 3, type: 'stationary_waves', reward: 150, customizationReward: { type: 'hat', id: 'hat_sleep' } },
    { id: 'question_hat_unlock', name: 'Indeciso', description: 'Role as cartas de upgrade 10 vezes em uma Ãºnica partida.', rarity: 'rare', target: 10, type: 'rerolls_in_run', reward: 100, customizationReward: { type: 'hat', id: 'hat_question' } },
    { id: 'bomb_hat_unlock', name: 'ReaÃ§Ã£o em Cadeia', description: 'Mate 50 inimigos com a explosÃ£o dos inimigos Explosivos.', rarity: 'uncommon', target: 50, type: 'exploder_kills', reward: 75, customizationReward: { type: 'hat', id: 'hat_bomb' } },
    { id: 'bear_face_unlock', name: 'Amigo da Natureza', description: 'Sobreviva a 10 ondas no cenÃ¡rio de Floresta.', rarity: 'uncommon', target: 10, type: 'survival_in_theme', subtype: 'forest', reward: 50, customizationReward: { type: 'face', id: 'face_bear' } },
    { id: 'crying_face_unlock', name: 'Pobre e Derrotado', description: 'Morra enquanto possui mais de 1000 moedas na partida.', rarity: 'uncommon', target: 1000, type: 'death_with_coins', reward: 50, customizationReward: { type: 'face', id: 'face_crying' } },
    { id: 'lava_color_unlock', name: 'Infernal', description: 'Sobreviva a 10 ondas no cenÃ¡rio de Deserto.', rarity: 'rare', target: 10, type: 'survival_in_theme', subtype: 'desert', reward: 100, customizationReward: { type: 'color', id: 'color_lava' } },
    { id: 'toxic_color_unlock', name: 'Anti-Suporte', description: 'Derrote 25 inimigos Curandeiros.', rarity: 'rare', target: 25, type: 'kill_type', subtype: 'healer', reward: 100, customizationReward: { type: 'color', id: 'color_toxic' } },
    { id: 'ice_color_unlock', name: 'Calafrio', description: 'Sobreviva a 10 ondas no cenÃ¡rio de Neve.', rarity: 'rare', target: 10, type: 'survival_in_theme', subtype: 'snow', reward: 100, customizationReward: { type: 'color', id: 'color_ice' } },

    // Ultimate
    { id: 'ultimate', name: 'Conquista Suprema', description: 'Desbloqueie todas as outras conquistas.', rarity: 'legendary', unlocked: false, target: 1, type: 'all', reward: 500 }
];


// ===================================================================================
// 3. GERENCIADOR DO JOGO E VARIÃVEIS GLOBAIS
// ===================================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.WIDTH; 
canvas.height = CONFIG.HEIGHT;

// Elementos da UI
const characterPreviewCanvas = document.getElementById('characterPreviewCanvas');
const previewCtx = characterPreviewCanvas.getContext('2d');
const achievementNotificationContainer = document.getElementById('achievement-notification-container');
const nicknameModal = document.getElementById('nickname-modal');
const nicknameInput = document.getElementById('nickname-input');
const nicknameError = document.getElementById('nickname-error');
const confirmNicknameButton = document.getElementById('confirm-nickname-button');

const mainMenuModal = document.getElementById('main-menu-modal');
const mainMenuNickname = document.getElementById('main-menu-nickname');
const mainMenuCoinsValue = document.getElementById('main-menu-coins-value');

const changelogModal = document.getElementById('changelog-modal');
const changelogButton = document.getElementById('changelog-button');
const changelogCloseButton = document.getElementById('changelog-close');

const upgradeModal = document.getElementById('upgrade-modal');
const rollUpgradesButton = document.getElementById('roll-upgrades-button');
const randomUpgradeButton = document.getElementById('random-upgrade-button');
const skipUpgradeButton = document.getElementById('skip-upgrade-button');

const gameOverScreen = document.getElementById('game-over-screen');
const victoryModal = document.getElementById('victory-modal');
const controlsHint = document.getElementById('controls-hint');
const cheatMenu = document.getElementById('cheat-menu');
const badgesModal = document.getElementById('badges-modal');
const settingsModal = document.getElementById('settings-modal');
const infoModal = document.getElementById('info-modal');
const cheatMenuButton = document.getElementById('cheatMenuButton');
const settingsButton = document.getElementById('settingsButton');
const cheatCardsList = document.getElementById('cheat-cards-list');
const achievementsList = document.getElementById('achievements-list');
const addAllCardsButton = document.getElementById('add-all-cards');
const applyCheatsButton = document.getElementById('apply-cheats');
const resetCheatsButton = document.getElementById('reset-cheats');
const cheatCloseButton = document.getElementById('cheat-close');
const badgesCloseButton = document.getElementById('badges-close');
const settingsCloseButton = document.getElementById('settings-close');
const infoCloseButton = document.getElementById('info-close');
const closeBadgesButton = document.getElementById('close-badges');
const returnToMenuFromGameOverButton = document.getElementById('return-to-menu-from-gameover');
const returnToMenuFromVictoryButton = document.getElementById('return-to-menu-from-victory');
const showBadgesMainButton = document.getElementById('show-badges-main');
const showSettingsButton = document.getElementById('show-settings');
const showInfoButton = document.getElementById('show-info-button');
const applySettingsButton = document.getElementById('apply-settings');
const showBadgesPauseButton = document.getElementById('show-badges-pause');
const tutorialButton = document.getElementById('tutorial-button');
const tutorialModal = document.getElementById('tutorial-modal');
const closeTutorialButton = document.getElementById('close-tutorial');
const waveIndicator = document.getElementById('wave-indicator');
const bossWarning = document.getElementById('boss-warning');
const ingameCardsUI = document.getElementById('ingame-cards-ui');
const ingameInfoDisplay = document.getElementById('ingame-info-display');
const gameTimerDisplay = document.getElementById('game-timer-display');
const cheatFeaturesConfirmationModal = document.getElementById('cheat-features-confirmation-modal');
const confirmCheatFeaturesYes = document.getElementById('confirm-cheat-features-yes');
const confirmCheatFeaturesNo = document.getElementById('confirm-cheat-features-no');
const cheatFeaturesSettingCheckbox = document.getElementById('cheat-features-setting');
const cheatSettingsContainer = document.getElementById('cheat-settings-container');
const deleteDataButton = document.getElementById('delete-data-btn');
const deleteDataConfirmationModal = document.getElementById('delete-data-confirmation-modal');
const confirmDeleteDataYes = document.getElementById('confirm-delete-data-yes');
const confirmDeleteDataNo = document.getElementById('confirm-delete-data-no');


const customizeCharacterButton = document.getElementById('customize-character-button');
const customizationModal = document.getElementById('customization-modal');
const customizationCoinsDisplay = document.getElementById('customization-coins');
const backToMainMenuFromCustomizationButton = document.getElementById('back-to-main-menu-from-customization');
const shapesTabButton = document.getElementById('shapes-tab-button');
const hatsTabButton = document.getElementById('hats-tab-button');
const colorsTabButton = document.getElementById('colors-tab-button');
const facesTabButton = document.getElementById('faces-tab-button');
const shapesOptionsContainer = document.getElementById('shapes-options');
const hatsOptionsContainer = document.getElementById('hats-options');
const colorsOptionsContainer = document.getElementById('colors-options');
const facesOptionsContainer = document.getElementById('faces-options');
const permanentUpgradesButton = document.getElementById('permanent-upgrades-button');
const permanentUpgradesModal = document.getElementById('permanent-upgrades-modal');
const permanentUpgradesListContainer = document.getElementById('permanent-upgrades-list');
const permanentUpgradesCoinsDisplay = document.getElementById('permanent-upgrades-coins');
const backToMainMenuFromUpgradesButton = document.getElementById('back-to-main-menu-from-upgrades');
const recordsModal = document.getElementById('records-modal');
const showRecordsButton = document.getElementById('show-records-button');
const recordsCloseButton = document.getElementById('records-close');
const closeRecordsButton = document.getElementById('close-records');
const recordsTableBody = document.getElementById('records-table-body');
const backFromCharacterButton = document.getElementById('back-from-character');
const backFromDeviceButton = document.getElementById('back-from-device');

// New Modals v7.0
const difficultyModal = document.getElementById('difficulty-modal');
const gamemodeModal = document.getElementById('gamemode-modal');
const difficultySelectionCards = document.getElementById('difficulty-selection-cards');
const gamemodeSelectionCards = document.getElementById('gamemode-selection-cards');
const confirmDifficultyButton = document.getElementById('confirm-difficulty');
const backFromDifficultyButton = document.getElementById('back-from-difficulty');
const backFromGamemodeButton = document.getElementById('back-from-gamemode');
const confirmGamemodeButton = document.getElementById('confirm-gamemode');

// Pause Menu Confirmation Modals (v7.4)
const restartConfirmationModal = document.getElementById('restart-confirmation-modal');
const confirmRestartYes = document.getElementById('confirm-restart-yes');
const confirmRestartNo = document.getElementById('confirm-restart-no');
const returnToMenuConfirmationModal = document.getElementById('return-to-menu-confirmation-modal');
const confirmReturnToMenuYes = document.getElementById('confirm-return-to-menu-yes');
const confirmReturnToMenuNo = document.getElementById('confirm-return-to-menu-no');

// Estado global do jogo
let gameManager = {
    controlScheme: null,
    chosenDevice: null,
    running: false,
    paused: false,
    gameOver: false,
    victory: false,
    wave: 0,
    waveState: 'COOLDOWN',
    waveTimer: CONFIG.WAVE_SPAWN_COOLDOWN,
    killsThisRun: 0,
    bossKillsThisRun: 0,
    totalExpThisRun: 0,
    xpOrbsCollected: 0,
    coinsInRun: 0,
    gameTime: 0,
    noDamageWaves: 0,
    shotsFiredThisWave: 0,
    jumpsThisRun: 0,
    frozenEnemiesThisRun: 0,
    healingDoneThisRun: 0,
    blackHoleKillsThisRun: 0,
    ricochetsThisRun: 0,
    rageKillsThisRun: 0,
    simultaneousKills: 0,
    barrierBlocks: 0,
    exploderKillsThisRun: 0,
    stationaryWaveCount: 0,
    difficulty: 'normal',
    gameMode: 'waves',
    isDifficultyRandom: false,
    isGameModeRandom: false,
    isCharacterRandom: false,
    achievements: JSON.parse(JSON.stringify(ACHIEVEMENTS)), // Deep copy
    stats: {
        coins: 0, 
        totalSpent: 0,
        totalWins: 0,
        totalHealing: 0,
        firstPurchaseMade: false,
        character: 'warrior',
        killCounts: {},
        criticalHitsThisRun: 0,
        rerollsThisRun: 0,
        deathsThisRun: 0,
    },
    runFlags: {
        playerMovedHorizontally: false,
        tookDamageThisWave: false,
        hpAtWaveStart: 0,
        multiKillTimer: 0,
        multiKillCounter: 0,
        bossSpawnTime: 0,
        currentThemeName: 'default',
        wavesInCurrentTheme: 0,
    },
    cheats: {
        immortality: false, autoFire: false, playerSpeed: 7, playerDamage: 5,
        freezeEnemies: false, enemyDamage: 10, instantExp: false, infiniteJumps: false
    },
    timeWarp: { active: false, timer: 0 } // For TimeWarp card
};

// VariÃ¡veis de jogo
let player; 
let groundPath = [];
let platforms = [];
let enemies = [];
let projectiles = [];
let particles = [];
let expOrbs = [];
let floatingTexts = [];
let blackHoles = [];
let orbitalShields = [];
let coins = []; 
let mirageClones = [];
let gravityWells = [];
let damageZones = [];

let keys = {}, mouse = { x: 0, y: 0, down: false };
let lastTime = 0, screenShake = { duration: 0, magnitude: 0 };
let movementJoystick, shootingJoystick;
let bloodSplatters = [];
let lastDamageWave = -1;
let previousScreen = null;
let previewAnimationId = null;
let gameLoopId = null; 

// ===================================================================================
// 4. CLASSES DE OBJETOS DO JOGO (MELHORADAS)
// ===================================================================================

class Platform {
    constructor(x, y, width) {
        this.x = x; this.y = y; this.width = width; this.height = CONFIG.PLATFORM_HEIGHT;
    }
    draw(ctx) {
        ctx.fillStyle = frameColors.platform;
        ctx.shadowColor = '#8a8aff';
        ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

class Entity {
    constructor(x, y, width, height, color) { 
        this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; 
        this.vx = 0; this.vy = 0; this.active = true; 
    }
}

class Player extends Entity {
    constructor(x, y) {
        const initialColor = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor)?.value || '#4caf50';
        super(x, y, 40, 60, initialColor);
        this.initStats();
        this.onGround = false; this.wasOnGround = false; this.jumps = 0; this.attackTimer = 0; this.invincibleTimer = 0; 
        this.scale = { x: 1, y: 1 }; this.jumpInputSustained = false; this.facingDirection = 1; this.onPlatform = false;
        this.lastAutoFireTime = 0;
        this.upgrades = {}; // e.g. {'Catalyst': 2}
        this.vfx = { // Visual Effects State
            damageAuraOpacity: 0,
            speedTrail: [],
            attackSpeedTrail: [],
            critGlow: 0,
            muzzleGlow: 0,
            isGlass: false,
        };
    }

    initStats() { 
        const baseStats = {
            hp: 100,
            damage: 5,
            moveSpeed: 7,
            jumpForce: 20,
            attackSpeed: 250,
            critChance: 0.05
        };

        const permHpBonus = PERMANENT_UPGRADES_CATALOG['perm_hp'].effect(PLAYER_PERMANENT_UPGRADES['perm_hp'] || 0);
        const permDmgBonus = PERMANENT_UPGRADES_CATALOG['perm_dmg'].effect(PLAYER_PERMANENT_UPGRADES['perm_dmg'] || 0);
        const permLuckBonus = PERMANENT_UPGRADES_CATALOG['perm_luck'].effect(PLAYER_PERMANENT_UPGRADES['perm_luck'] || 0);
        
        let finalHp = baseStats.hp * permHpBonus;
        let finalDmg = baseStats.damage * permDmgBonus;
        let finalSpeed = baseStats.moveSpeed;
        let finalAttackSpeed = baseStats.attackSpeed;
        let finalCritChance = baseStats.critChance + permLuckBonus;

        if (gameManager.difficulty === 'easy') { finalHp *= 1.3; finalDmg *= 1.3; } 
        else if (gameManager.difficulty === 'normal') { finalHp *= 1.15; finalDmg *= 1.1; }

        this.baseStats = { moveSpeed: finalSpeed };
        this.hp = finalHp; 
        this.exp = 0; this.level = 1; this.expToNextLevel = 10; 
        
        this.stats = { 
            maxHp: finalHp, moveSpeed: finalSpeed, jumpForce: baseStats.jumpForce, maxJumps: 1, 
            attackSpeed: finalAttackSpeed, projectileDamage: finalDmg,
            projectileSize: 5, projectileCount: 1, critChance: finalCritChance, critDamage: 1.5, lifesteal: 0, 
            upgradeChoices: 3, 
            catalyst: { stacks: 0 },
            growth: { stacks: 0 },
            swift: { stacks: 0 },
            resonance: { stacks: 0 },
            eyesight: { stacks: 0 },
            barrier: { enabled: false, cooldown: 15000, timer: 0, active: true }, 
            rage: { enabled: false }, 
            thunderbolt: { enabled: false, cooldown: 5000, timer: 5000, count: 0, damage: 20 },
            fragmentation: { enabled: false, count: 0 },
            piercing: { enabled: false, hits: 1 },
            blackHole: { enabled: false, chance: 0, radius: 80, duration: 3000, damagePercent: 0.05, tickRate: 500 },
            laserPet: { count: 0, attackSpeed: 2000, damage: 15 },
            bloodRitual: { chance: 0 },
            ricochet: { enabled: false, chance: 1, maxBounces: 0 },
            tempAlliance: { chance: 0, duration: 3000, healBonus: 0.05 },
            frostNova: { enabled: false, duration: 2000 },
            chainLightning: { enabled: false, chance: 0, bounces: 0, damageMultiplier: 0.5 },
            orbitalShield: { count: 0, speed: 1 },
            magneticField: { enabled: true, range: 150 },
            vampiricExplosion: { enabled: false, chance: 0, healPercent: 0 },
            shockwaveJump: { enabled: false, damage: 0, radius: 0 },
            gravityWell: { enabled: false, chance: 0, radius: 50, duration: 1000 },
            singularityCore: { enabled: false, damage: 0, cooldown: 4000, timer: 4000 },
            holyRetribution: { enabled: false, count: 0, damage: 15 },
            mirageClones: { enabled: false, count: 0, cooldown: 10000, timer: 10000, duration: 5000 },
            ouroborosRounds: { enabled: false, chance: 0 },
            quantumEntanglement: { enabled: false, sharePercent: 0, targets: 0 },
            timeWarp: { enabled: false, chance: 0, duration: 2000 },
            ghostBullets: { enabled: false, chance: 0 },
        };
        
        if (gameManager.stats.character === 'warrior') { this.stats.maxHp *= 1.2; } 
        else if (gameManager.stats.character === 'archer') { this.stats.attackSpeed *= 0.7; }
        this.hp = this.stats.maxHp;
        
        this.applyAllCheats();
    }

    applyAllCheats() {
        if (gameManager.cheats.immortality) this.hp = 99999;
        this.stats.moveSpeed = gameManager.cheats.playerSpeed;
        this.stats.projectileDamage += (gameManager.cheats.playerDamage - 5);
        if (gameManager.cheats.infiniteJumps) this.stats.maxJumps = 999;
    }

    update(deltaTime) {
        this.wasOnGround = this.onGround || this.onPlatform;
        const initialX = this.x;

        if (gameManager.cheats.autoFire && this.attackTimer <= 0) {
            this.autoShoot();
        } else if (gameManager.controlScheme === 'desktop') {
            if (keys['a'] || keys['ArrowLeft']) { this.vx = -this.stats.moveSpeed; this.facingDirection = -1; gameManager.runFlags.playerMovedHorizontally = true; }
            else if (keys['d'] || keys['ArrowRight']) { this.vx = this.stats.moveSpeed; this.facingDirection = 1; gameManager.runFlags.playerMovedHorizontally = true; }
            else this.vx = 0;
            
            if (mouse.down && this.attackTimer <= 0) {
                this.shoot();
            }
        } else if (gameManager.controlScheme === 'mobile' && movementJoystick && shootingJoystick) {
            this.vx = movementJoystick.deltaX * this.stats.moveSpeed;
            if (this.vx !== 0) { this.facingDirection = Math.sign(this.vx); gameManager.runFlags.playerMovedHorizontally = true; }
            if (movementJoystick.deltaY < -0.75 && !this.jumpInputSustained) { this.jump(); this.jumpInputSustained = true; }
            if (movementJoystick.deltaY > -0.5) this.jumpInputSustained = false;
            
            if (shootingJoystick.active && this.attackTimer <= 0) {
                this.shoot();
            }
        }
       
        this.vy += CONFIG.GRAVITY; this.x += this.vx; this.y += this.vy; this.onGround = false; this.onPlatform = false;
        
        if (Math.abs(this.x - initialX) < 0.1) {
            // Player hasn't moved horizontally this frame
        } else {
            gameManager.runFlags.playerMovedHorizontally = true;
        }

        const groundY = getGroundHeightAt(this.x + this.width / 2);
        if (this.y + this.height > groundY && this.vy >= 0) { 
            this.y = groundY - this.height; this.vy = 0; this.onGround = true; this.jumps = 0; 
            if (!this.wasOnGround && this.stats.shockwaveJump.enabled) this.createShockwave();
        }
        
        for (const platform of platforms) {
            if (this.y + this.height > platform.y && this.y + this.height < platform.y + this.vy + 2 &&
                this.x + this.width > platform.x && this.x < platform.x + platform.width && this.vy >= 0) {
                this.y = platform.y - this.height; this.vy = 0; this.onPlatform = true; this.jumps = 0;
                if (!this.wasOnGround && this.stats.shockwaveJump.enabled) this.createShockwave();
            }
        }
        
        if (this.x < 0) this.x = 0; if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

        if (this.attackTimer > 0) this.attackTimer -= deltaTime;
        if (this.invincibleTimer > 0) this.invincibleTimer -= deltaTime;
        if ((this.onGround || this.onPlatform) && this.vy === 0) { this.scale.y = 1; this.scale.x = 1; }
        
        this.updateSpecialEffects(deltaTime);
        this.updateVFX(deltaTime);

        if (this.stats.magneticField.enabled) {
            [...expOrbs, ...coins].forEach(item => {
                const dx = this.x + this.width/2 - item.x; const dy = this.y + this.height/2 - item.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < this.stats.magneticField.range) { 
                    item.vx = (item.vx * 0.9) + (dx/dist * 8 * 0.1); item.vy = (item.vy * 0.9) + (dy/dist * 8 * 0.1);
                }
            });
        }
        if (gameManager.cheats.instantExp && this.exp < this.expToNextLevel) this.addExp(1, false);
    }
    
    updateSpecialEffects(deltaTime) {
        if (this.stats.thunderbolt.enabled) {
            this.stats.thunderbolt.timer -= deltaTime;
            if (this.stats.thunderbolt.timer <= 0) {
                this.stats.thunderbolt.timer = this.stats.thunderbolt.cooldown;
                for (let i = 0; i < this.stats.thunderbolt.count; i++) {
                    const validTargets = enemies.filter(e => e.active && !e.isAlly);
                    if (validTargets.length > 0) {
                        const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                        if(target) createLightningStrike(target.x + target.width/2, target.y + target.height/2, this.stats.thunderbolt.damage);
                    }
                }
            }
        }
        while (this.stats.laserPet.count > 0 && orbitalShields.filter(s => s.isPet).length < this.stats.laserPet.count) {
             orbitalShields.push(new OrbitalShield(this, true));
        }
        while (this.stats.orbitalShield.count > 0 && orbitalShields.filter(s => !s.isPet).length < this.stats.orbitalShield.count) {
             orbitalShields.push(new OrbitalShield(this, false));
        }
        if (this.stats.orbitalShield.count > 0 && this.stats.laserPet.count > 0) checkAchievement('pet_and_shield', 1);

        if (this.stats.singularityCore.enabled) {
            this.stats.singularityCore.timer -= deltaTime;
            if (this.stats.singularityCore.timer <= 0) {
                this.stats.singularityCore.timer = this.stats.singularityCore.cooldown;
                const pX = this.x + this.width / 2;
                const pY = this.y + this.height / 2;
                if(VISUAL_SETTINGS.cardEffectIntensity > 0) particles.push(...createParticleBurst(pX, pY, 30, 'rgba(156, 39, 176, 0.7)'));
                enemies.forEach(e => {
                    if (e.active && !e.isAlly) {
                        const dist = Math.hypot(e.x - pX, e.y - pY);
                        if (dist < 100) {
                            e.takeDamage(this.stats.singularityCore.damage);
                        }
                    }
                });
            }
        }

        if (this.stats.mirageClones.enabled) {
            this.stats.mirageClones.timer -= deltaTime;
            if (this.stats.mirageClones.timer <= 0) {
                this.stats.mirageClones.timer = this.stats.mirageClones.cooldown;
                for (let i = 0; i < this.stats.mirageClones.count; i++) {
                    const cloneX = this.x + (Math.random() - 0.5) * 200;
                    const cloneY = this.y;
                    mirageClones.push(new MirageClone(cloneX, cloneY, this.width, this.height, this.stats.mirageClones.duration));
                }
            }
        }
    }

    updateVFX(deltaTime) {
        const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
        const trailIntensity = VISUAL_SETTINGS.trailIntensity / 10;

        if (this.stats.catalyst.stacks > 0) { this.vfx.damageAuraOpacity = Math.min(0.1 + this.stats.catalyst.stacks * 0.05, 0.6) * effectIntensity; } 
        else { this.vfx.damageAuraOpacity = 0; }

        if (this.stats.swift.stacks > 0 && this.vx !== 0) {
            for (let i = 0; i < this.stats.swift.stacks * trailIntensity; i++) {
                if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width / 2, this.y + this.height * Math.random(), -this.vx * 0.1, (Math.random() - 0.5) * 2, Math.random() * 2, 'rgba(255,255,255,0.5)', 300));
            }
        }
        
        if (this.stats.growth.stacks > 0 && trailIntensity > 0 && Math.random() > 0.8) {
             if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, 0, 0, Math.random() * 3 + 1, 'rgba(76, 175, 80, 0.5)', 500));
        }

        if (this.stats.resonance.stacks > 0 && trailIntensity > 0) {
            this.vfx.attackSpeedTrail.push({x: this.x, y: this.y, alpha: 1.0, w: this.width, h: this.height, dir: this.facingDirection});
            if (this.vfx.attackSpeedTrail.length > 5 * this.stats.resonance.stacks * trailIntensity) { this.vfx.attackSpeedTrail.shift(); }
        }
        this.vfx.attackSpeedTrail.forEach(t => t.alpha -= 0.05);
        this.vfx.attackSpeedTrail = this.vfx.attackSpeedTrail.filter(t => t.alpha > 0);
        
        if (this.stats.eyesight.stacks > 0 && effectIntensity > 0) {
            this.vfx.critGlow += deltaTime;
            if (this.vfx.critGlow > (3000 / this.stats.eyesight.stacks) / effectIntensity) {
                 this.vfx.critGlow = 0;
                 if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width/2, this.y, 0, -1, 15 * effectIntensity, 'rgba(255, 255, 0, 0.8)', 200));
            }
        }

        if (this.vfx.muzzleGlow > 0) { this.vfx.muzzleGlow -= deltaTime * 0.01; }
    }
    
    shoot(angleOverride = null) {
        gameManager.shotsFiredThisWave++;
        let angle;
        
        if (angleOverride !== null) {
            angle = angleOverride;
        } else if (gameManager.controlScheme === 'desktop') {
            angle = Math.atan2(mouse.y - (this.y + this.height / 2), mouse.x - (this.x + this.width / 2));
        } else { // mobile
            if (!shootingJoystick || !shootingJoystick.active) return;
            angle = shootingJoystick.angle;
        }

        for (let i = 0; i < this.stats.projectileCount; i++) {
            const spreadAngle = angle + (i - (this.stats.projectileCount-1)/2) * 0.2; let damage = this.stats.projectileDamage;
            const isCrit = Math.random() < this.stats.critChance;
            if(isCrit) {
                damage *= this.stats.critDamage; gameManager.stats.criticalHitsThisRun++;
                if (this.stats.timeWarp.enabled && Math.random() < this.stats.timeWarp.chance) {
                    gameManager.timeWarp.active = true;
                    gameManager.timeWarp.timer = this.stats.timeWarp.duration;
                }
            }
            if (this.stats.rage.enabled && this.hp < this.stats.maxHp * 0.3) damage *= 1.5;
            checkAchievement('single_hit_damage', damage);
            
            const pStats = JSON.parse(JSON.stringify(this.stats)); // Pass a copy of stats to projectile
            projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, Math.cos(spreadAngle) * 15, Math.sin(spreadAngle) * 15, damage, isCrit, this.stats.projectileSize, CONFIG.COLOR_PLAYER_PROJECTILE, true, pStats));
        }
        this.attackTimer = this.stats.attackSpeed;
        if(this.stats.attackSpeed < 100) checkAchievement('attack_speed_milestone', this.stats.attackSpeed);
        this.vfx.muzzleGlow = 1;
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createMuzzleFlash(this.x + this.width/2, this.y + this.height/2, angle, 10));
    }

    autoShoot() {
        const validEnemies = enemies.filter(e => e.active && !e.isAlly);
        if (validEnemies.length === 0) return;

        let closestEnemy = null;
        let min_dist = Infinity;
        validEnemies.forEach(e => {
            const dist = Math.hypot(this.x - e.x, this.y - e.y);
            if (dist < min_dist) {
                min_dist = dist;
                closestEnemy = e;
            }
        });

        if (closestEnemy) {
            const angle = Math.atan2((closestEnemy.y + closestEnemy.height / 2) - (this.y + this.height / 2), (closestEnemy.x + closestEnemy.width / 2) - (this.x + this.width / 2));
            this.shoot(angle);
            this.lastAutoFireTime = Date.now();
        }
    }

    jump() { 
        if (this.jumps < (gameManager.cheats.infiniteJumps ? 100 : this.stats.maxJumps)) { 
            this.vy = -this.stats.jumpForce; this.onGround = false; this.jumps++; gameManager.jumpsThisRun++;
            this.scale.y = 0.7; this.scale.x = 1.3; 
            const playerColorData = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor);
            const playerColor = Array.isArray(playerColorData.value) ? playerColorData.value[0] : playerColorData.value;
            if (VISUAL_SETTINGS.particleIntensity > 0) {
                particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height, 10 + (this.upgrades['Gush'] || 0) * 5, playerColor));
                particles.push(...createJumpDust(this.x + this.width/2, this.y + this.height, 15));
            }
        } 
    }
    
    draw(ctx) { 
        ctx.save(); 
        if (this.invincibleTimer > 0) {
            ctx.globalAlpha = Math.abs(Math.sin(Date.now() / 50));
        }
        
        this.drawVFX(ctx);

        const centerX = this.x + this.width / 2; 
        const centerY = this.y + this.height / 2;
        
        ctx.translate(centerX, centerY); 
        ctx.scale(this.scale.x, this.scale.y); 
        ctx.translate(-centerX, -centerY); 
        
        renderCharacter(ctx, this.x, this.y, this.width, this.height, this.facingDirection, this.vfx.isGlass);
        
        ctx.restore(); 
        ctx.shadowBlur = 0; 
    }

    drawVFX(ctx) {
        this.vfx.attackSpeedTrail.forEach(trail => {
            ctx.save();
            ctx.globalAlpha = trail.alpha * 0.3 * (VISUAL_SETTINGS.trailIntensity / 7);
            renderCharacter(ctx, trail.x, trail.y, trail.w, trail.h, trail.dir, this.vfx.isGlass);
            ctx.restore();
        });

        if (this.vfx.damageAuraOpacity > 0) {
            ctx.save();
            const grad = ctx.createRadialGradient(this.x + this.width/2, this.y + this.height/2, this.width/2, this.x + this.width/2, this.y + this.height/2, this.width);
            grad.addColorStop(0, 'rgba(255, 60, 0, 0.5)');
            grad.addColorStop(1, 'rgba(255, 150, 0, 0)');
            ctx.fillStyle = grad;
            ctx.globalAlpha = Math.random() * 0.5 + this.vfx.damageAuraOpacity;
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        if (this.vfx.muzzleGlow > 0) {
            const stacks = this.upgrades['MultiShot'] || 0;
            const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
            ctx.save();
            ctx.globalAlpha = this.vfx.muzzleGlow;
            ctx.fillStyle = '#ffcc00';
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = (5 + stacks * 5) * effectIntensity;
            ctx.beginPath();
            const muzzleX = this.x + this.width/2 + (this.facingDirection * (this.width / 2));
            const muzzleY = this.y + this.height/2;
            ctx.arc(muzzleX, muzzleY, (5 + stacks * 2) * effectIntensity, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        const magStacks = this.upgrades['Magnetic Field'] || 0;
        if (magStacks > 0) {
            ctx.save();
            ctx.strokeStyle = `rgba(100, 180, 255, ${0.1 + magStacks * 0.02})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.stats.magneticField.range, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        if(this.stats.rage.enabled && this.hp < this.stats.maxHp * 0.3) {
            ctx.save();
            const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
            ctx.globalAlpha = (0.3 + Math.sin(Date.now() / 100) * 0.2) * effectIntensity;
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20 * effectIntensity;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        if(this.stats.barrier.enabled && this.stats.barrier.active) {
            ctx.save();
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    takeDamage(amount) { 
        if (gameManager.cheats.immortality || this.invincibleTimer > 0) return;
        lastDamageWave = gameManager.wave; gameManager.noDamageWaves = 0; gameManager.runFlags.tookDamageThisWave = true;
        
        if (this.stats.barrier.enabled && this.stats.barrier.active) {
            this.stats.barrier.active = false; this.stats.barrier.timer = this.stats.barrier.cooldown;
            gameManager.barrierBlocks++; checkAchievement('barrier_blocks', gameManager.barrierBlocks);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height/2, 20, 'cyan'));
            floatingTexts.push(new FloatingText('ESCUDO!', this.x + this.width/2, this.y, '#00ffff', 20));
            if (gameManager.waveState === 'SPAWNING' && enemies.some(e => e.isBoss)) { checkAchievement('barrier_boss_hit', 1); }
            return;
        }
        
        this.hp -= amount; this.invincibleTimer = 500; screenShake = { duration: 200, magnitude: VISUAL_SETTINGS.screenShakeIntensity }; 
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width / 2, this.y + this.height / 2, 20, 'red'));
        if (VISUAL_SETTINGS.blood) createBloodSplatter(this.x + this.width/2, this.y + this.height/2, amount * 2);
        createDamageIndicator(this.x + this.width/2, this.y, amount);
        
        if (this.stats.frostNova.enabled) {
            let frozenCount = 0;
            enemies.forEach(e => {
                const dx = e.x - this.x, dy = e.y - this.y;
                if(Math.sqrt(dx*dx + dy*dy) < 150) { 
                    e.isFrozen = true; frozenCount++;
                    setTimeout(() => e.isFrozen = false, this.stats.frostNova.duration); 
                }
            });
            if (frozenCount > 0) {
                gameManager.frozenEnemiesThisRun += frozenCount;
                checkAchievement('frozen_enemies', gameManager.frozenEnemiesThisRun);
            }
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 30, '#00ffff'));
        }
        
        if (this.stats.holyRetribution.enabled) {
            for(let i=0; i < this.stats.holyRetribution.count; i++) {
                const validTargets = enemies.filter(e => e.active && !e.isAlly);
                if (validTargets.length > 0) {
                    const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                    if(target) createHolyBeam(target.x + target.width/2, this.stats.holyRetribution.damage);
                }
            }
        }

        if (this.hp <= 0) { 
            this.hp = 0; if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createDeathExplosion(this.x + this.width/2, this.y + this.height/2, 50));
            if (gameManager.wave % 5 === 0) checkAchievement('death_on_boss_wave', 1);
            checkAchievement('death_with_coins', gameManager.coinsInRun);
            gameManager.stats.deathsThisRun++;
            gameManager.gameOver = true;
        } 
    }
    
    addExp(amount, fromOrb=true) { 
        if (fromOrb) gameManager.xpOrbsCollected++; checkAchievement('xp_orbs', gameManager.xpOrbsCollected);
        this.exp += amount; gameManager.totalExpThisRun += amount;
        while (this.exp >= this.expToNextLevel) { this.exp -= this.expToNextLevel; this.levelUp(); } 
    }
    
    levelUp() { 
        this.level++; this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5); this.hp = this.stats.maxHp; 
        checkAchievement('level', this.level);
        gameManager.paused = true; showUpgradeScreen(); 
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height/2, 50, 'gold')); 
        floatingTexts.push(new FloatingText(`NÃVEL ${this.level}!`, canvas.width/2, canvas.height/2, 'gold', 40));
    }
    
    addCoin(amount) {
        const coinGainBonus = PERMANENT_UPGRADES_CATALOG['perm_coins'].effect(PLAYER_PERMANENT_UPGRADES['perm_coins'] || 0);
        const finalAmount = Math.ceil(amount * coinGainBonus);
        gameManager.stats.coins += finalAmount;
        gameManager.coinsInRun += finalAmount;
        checkAchievement('coins_in_run', gameManager.coinsInRun);
        floatingTexts.push(new FloatingText(`+${finalAmount} Moedas`, this.x + this.width/2, this.y, '#ffd700', 20));
        updateMetaProgression(); 
    }

    addUpgrade(upgradeKey) {
        const upgrade = UPGRADES[upgradeKey]; if (!upgrade) return;
        const currentStacks = this.upgrades[upgradeKey] || 0;
        if (upgrade.maxStacks && currentStacks >= upgrade.maxStacks) return; 
        
        upgrade.apply(this); this.upgrades[upgradeKey] = (this.upgrades[upgradeKey] || 0) + 1;
        
        if (upgradeKey === 'GlassCannon') this.vfx.isGlass = true;
        
        const a_data = { rarity: upgrade.rarity };
        checkAchievement('collect_rarity', a_data);
        checkAchievement('unique_cards', Object.keys(this.upgrades).length);
        if(upgradeKey === 'LaserPet') checkAchievement('stat_check', {'subtype': 'laserPet.count', 'value': this.stats.laserPet.count});
        
        checkAchievement('stat_milestone', { subtype: 'critChance', value: this.stats.critChance });
        checkAchievement('stat_milestone', { subtype: 'maxHp', value: this.stats.maxHp });
        checkAchievement('stack_rarity', { rarity: upgrade.rarity, stacks: this.upgrades[upgradeKey] });
        checkAchievement('card_combo', this.upgrades);
        checkAchievement('all_rarities_in_run', 1);

        updateIngameCardsUI();
    }

    createShockwave() {
        const pX = this.x + this.width / 2;
        const pY = this.y + this.height;
        const { damage, radius } = this.stats.shockwaveJump;
        if(VISUAL_SETTINGS.cardEffectIntensity > 0) particles.push(...createShockwaveEffect(pX, pY, radius));
        enemies.forEach(e => {
            if (e.active && !e.isAlly && e.y + e.height > pY - 20) { // On the ground
                const dist = Math.abs(e.x - pX);
                if (dist < radius) {
                    e.takeDamage(damage);
                }
            }
        });
    }
}

class Enemy extends Entity { 
    constructor(x, y, type) { 
        const d = ENEMY_TYPES[type]; super(x, y, d.size, d.size, d.color); 
        this.type = type;

        let hpMultiplier = 1.0; let damageMultiplier = 1.0; let cooldownMultiplier = 1.0;
        if (gameManager.difficulty === 'easy') { hpMultiplier = 0.5; damageMultiplier = 0.5; cooldownMultiplier = 1.5; } 
        else if (gameManager.difficulty === 'normal') { hpMultiplier = 0.75; damageMultiplier = 0.9; }

        this.maxHp = d.hp * (1 + (gameManager.wave - 1) * 0.1) * hpMultiplier; 
        this.hp = this.maxHp; 
        this.speed = d.speed; 
        this.shootCooldown = d.attackCooldown * cooldownMultiplier; 
        this.shootTimer = Math.random() * this.shootCooldown; 
        this.damageValue = (d.type === 'bomber' ? 20 : 10) * damageMultiplier;

        this.behavior = d.behavior; 
        this.targetY = CONFIG.PLATFORM_MIN_Y + Math.random() * (CONFIG.PLATFORM_MAX_Y - CONFIG.PLATFORM_MIN_Y);
        this.expValue = d.expValue; this.isBoss = d.isBoss || false; this.isFrozen = false; this.isAlly = false; 
        this.allyTimer = 0;
        this.specialAttack = d.specialAttack;
        this.specialCooldown = d.specialCooldown || 0;
        this.specialTimer = this.specialCooldown;
        this.behaviorTimer = Math.random() * 3000 + 2000;
        
        // v7.8+ - Anti-Frustration System
        this.lastDamageTime = 0;
        this.isBeingRescued = false;
    } 
    update(dt, p) { 
        if (gameManager.cheats.freezeEnemies || this.isFrozen) return; 

        // MODIFIED [v7.9]: LÃ³gica de resgate simplificada.
        if (this.isBeingRescued) {
            const targetX = CONFIG.WIDTH / 2;
            const targetY = 150;
            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 20) {
                const pullSpeed = 5;
                this.x += (dx / dist) * pullSpeed;
                this.y += (dy / dist) * pullSpeed;
            } else {
                // Chegou ao destino. Libere o inimigo para sua IA normal.
                this.isBeingRescued = false;
            }
            return; // Interrompe o resto da IA enquanto estÃ¡ sendo puxado.
        }


        if (this.isAlly) {
            this.allyTimer -= dt; if (this.allyTimer <= 0) { this.die(true); return; }
            let closestEnemy = null; let min_dist = Infinity;
            enemies.forEach(e => {
                if(e !== this && !e.isAlly) {
                    const dist = Math.hypot(this.x - e.x, this.y - e.y);
                    if (dist < min_dist) { min_dist = dist; closestEnemy = e; }
                }
            });
            if (closestEnemy) {
                const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                this.x += Math.cos(angle) * this.speed * 0.7; this.y += Math.sin(angle) * this.speed * 0.7;
                this.shootTimer -= dt;
                if (this.shootTimer <= 0) { this.shoot(closestEnemy, true); this.shootTimer = this.shootCooldown * 1.5; }
            }
            return;
        }

        let target = p;
        if(mirageClones.length > 0 && !this.isAlly) {
            let closestDist = Math.hypot(this.x - p.x, this.y - p.y);
            let closestTarget = p;
            mirageClones.forEach(clone => {
                const dist = Math.hypot(this.x - clone.x, this.y - clone.y);
                if(dist < closestDist) {
                    closestDist = dist;
                    closestTarget = clone;
                }
            });
            target = closestTarget;
        }
        
        this.behaviorTimer -= dt;
        if(this.behaviorTimer <= 0) {
            if(this.behavior === 'teleporting') {
                const oldX = this.x, oldY = this.y;
                this.x = target.x + (Math.random() - 0.5) * 300; this.y = target.y + (Math.random() - 0.5) * 200;
                if (VISUAL_SETTINGS.particleIntensity > 0) {
                    particles.push(...createParticleBurst(oldX, oldY, 20, this.color, 0.5));
                    particles.push(...createParticleBurst(this.x, this.y, 20, this.color));
                }
                this.behaviorTimer = 3000;
            }
            if(this.behavior === 'support') { // Healer
                enemies.forEach(e => {
                    if (e !== this && !e.isAlly && e.hp < e.maxHp && Math.hypot(this.x - e.x, this.y - e.y) < 100) {
                        e.hp = Math.min(e.maxHp, e.hp + 10);
                        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new LifestealParticle(this.x, this.y, e, '#4caf50'));
                    }
                });
                this.behaviorTimer = 2500;
            }
        }
        
        const angle = Math.atan2(target.y - this.y, target.x - this.x);
        if (this.behavior === 'flying' || this.behavior === 'teleporting') {
            this.x += Math.cos(angle) * this.speed * 0.5; this.y += Math.sin(angle) * this.speed * 0.5;
        } else if (this.behavior !== 'support') {
            this.vx = Math.cos(angle) * this.speed * 0.5; this.vy += CONFIG.GRAVITY; this.x += this.vx; this.y += this.vy;
            const groundY = getGroundHeightAt(this.x + this.width / 2);
            if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; }
        }
        if (this.shootTimer > 0) this.shootTimer -= dt; 
        if(this.shootTimer <= 0 && this.type !== 'exploder' && target === p){ this.shoot(p, false); this.shootTimer = this.shootCooldown; } 
        if(this.isBoss){ this.specialTimer -= dt; if(this.specialTimer <= 0) { this.useSpecialAttack(p); this.specialTimer = this.specialCooldown; }}
    } 
    draw(ctx){ 
        ctx.fillStyle = this.isAlly ? '#4caf50' : this.color; if(this.isFrozen) ctx.fillStyle = '#add8e6';
        if(this.isAlly) {
            ctx.save();
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
        }
        ctx.shadowColor = this.isAlly ? '#4caf50' : this.color; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0; 
        
        // Custom shapes
        switch(this.type) {
            case 'tank': ctx.fillRect(this.x, this.y, this.width * 1.2, this.height * 0.8); break;
            case 'flyer': drawShapeTriangle(ctx, this.x, this.y, this.width, this.height, ctx.fillStyle); break;
            case 'elite': drawShapeHexagon(ctx, this.x, this.y, this.width, this.height, ctx.fillStyle); break;
            default: ctx.fillRect(this.x, this.y, this.width, this.height); break;
        }

        // Custom details
        if(this.type === 'healer' && Math.floor(Date.now()/200) % 2 === 0) {
             ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 5, 0, Math.PI*2); ctx.fill();
        }
        if(this.type === 'shooter' || this.type === 'bouncer') {
            const facing = (player.x > this.x) ? 1 : -1;
            ctx.fillStyle = 'black';
            ctx.fillRect(this.x + (facing > 0 ? this.width : -10), this.y + this.height/2 - 2, 10, 4);
        }
        if(this.type === 'bomber' && Math.floor(Date.now()/500) % 2 === 0) {
             ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 5, 0, Math.PI*2); ctx.fill();
        }
        if(this.isBoss) {
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + 10, this.y - 10); ctx.lineTo(this.x + 20, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width - 10, this.y - 10); ctx.lineTo(this.x + this.width - 20, this.y); ctx.fill();
        }
        if(this.isAlly) ctx.restore();

        ctx.shadowBlur = 0; 
        if(this.hp < this.maxHp){ 
            ctx.fillStyle='#555'; ctx.fillRect(this.x, this.y-10, this.width, 5); 
            ctx.fillStyle='red'; ctx.fillRect(this.x, this.y-10, this.width*(this.hp/this.maxHp), 5); 
        } 
        if (this.isBoss) { ctx.fillStyle = 'gold'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('CHEFE', this.x + this.width/2, this.y - 15); }
    } 
    shoot(target, isAllyShot){ 
        const a = Math.atan2((target.y + target.height/2) - (this.y + this.height/2), (target.x + target.width/2) - (this.x + this.width/2));
        const color = isAllyShot ? '#00ff00' : CONFIG.COLOR_ENEMY_PROJECTILE;
        const damage = isAllyShot ? 10 : this.damageValue;
        const pStats = this.type === 'bouncer' ? {ricochet: {enabled: true, maxBounces: 2, chance: 1}} : {};
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createMuzzleFlash(this.x + this.width/2, this.y + this.height/2, a, 5));
        projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height/2, Math.cos(a)*8, Math.sin(a)*8, damage, false, 5, color, isAllyShot, pStats)); 
    } 
    useSpecialAttack(target){
        switch(this.specialAttack) {
            case 'frost_nova':
                damageZones.push(new DamageZone(this.x, this.y, this.size * 3, this.size * 3, 500, 5, true, 'rgba(173, 216, 230, 0.5)'));
                player.isFrozen = true;
                setTimeout(() => { player.isFrozen = false; }, 2000);
                break;
            case 'summon_minions':
                for(let i=0; i<3; i++) {
                    enemies.push(new Enemy(this.x + (i-1)*50, this.y - 20, 'grunt'));
                }
                break;
            case 'fire_trail':
                damageZones.push(new DamageZone(this.x, this.y, this.width, this.height, 3000, 2, false, 'rgba(255, 69, 0, 0.5)'));
                break;
            case 'laser_beam':
                damageZones.push(new DamageZone(0, this.y, CONFIG.WIDTH, 20, 1500, 25, false, 'rgba(255, 0, 0, 0.6)'));
                break;
            case 'pollen_cloud':
                 damageZones.push(new DamageZone(this.x - 50, this.y - 50, 100, 100, 4000, 1, true, 'rgba(255, 220, 120, 0.3)'));
                 break;
            case 'crystal_shot':
                 for(let i=0; i < 5; i++){
                    const angle = Math.atan2(target.y - this.y, target.x - this.x) + (i - 2) * 0.3;
                    projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height/2, Math.cos(angle)*6, Math.sin(angle)*6, this.damageValue * 0.7, false, 4, this.color, false, {}));
                 }
                 break;
        }
    }
    takeDamage(am, byPlayer=true, fromBlackHole=false){ 
        // MODIFIED [v7.9]: Simplificado para sempre atualizar o tempo e cancelar o resgate.
        this.isBeingRescued = false;
        this.lastDamageTime = gameManager.gameTime;

        if (this.isAlly && byPlayer) { this.die(false); return; }
        if (this.isAlly && !byPlayer) return; 
        
        this.hp -= am; 
        
        if (byPlayer && player.stats.quantumEntanglement.enabled) {
            const sharedDamage = am * player.stats.quantumEntanglement.sharePercent;
            const otherEnemies = enemies.filter(e => e.active && !e.isAlly && e !== this);
            for(let i=0; i < player.stats.quantumEntanglement.targets && otherEnemies.length > 0; i++) {
                const targetIndex = Math.floor(Math.random() * otherEnemies.length);
                const target = otherEnemies.splice(targetIndex, 1)[0];
                target.takeDamage(sharedDamage, false);
                createDamageIndicator(target.x + target.width/2, target.y, sharedDamage);
                if (VISUAL_SETTINGS.cardEffectIntensity > 0) createTetherEffect(this.x, this.y, target.x, target.y, 'rgba(156, 39, 176, 0.7)');
            }
        }

        if(VISUAL_SETTINGS.blood) createBloodSplatter(this.x + this.width/2, this.y + this.height/2, am * 5); 
        createDamageIndicator(this.x + this.width/2, this.y, am); this.vy = -5; 
        if (VISUAL_SETTINGS.particleIntensity > 0) {
            for (let i = 0; i < am * 2; i++) particles.push(new BloodParticle(this.x+this.width/2, this.y+this.height/2, (Math.random()-0.5)*3, (Math.random()-0.5)*3 - 2, Math.random()*3+2, '#ff0000', 2000)); 
        }
        if (byPlayer && player.stats.lifesteal > 0) {
            const heal = am * player.stats.lifesteal;
            player.hp = Math.min(player.stats.maxHp, player.hp + heal);
            gameManager.healingDoneThisRun += heal; gameManager.stats.totalHealing += heal;
            checkAchievement('healing', gameManager.healingDoneThisRun); checkAchievement('total_healing', gameManager.stats.totalHealing);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new LifestealParticle(this.x + this.width/2, this.y + this.height/2, player));
        }
        if(this.hp<=0){ 
            if (fromBlackHole) gameManager.blackHoleKillsThisRun++; checkAchievement('black_hole_kills', gameManager.blackHoleKillsThisRun);
            if (player.stats.rage.enabled && player.hp < player.stats.maxHp * 0.3) gameManager.rageKillsThisRun++; checkAchievement('rage_kills', gameManager.rageKillsThisRun);
            this.die(false); 
        } 
    }
    
    die(wasAlly) {
        if (!this.active) return; this.active = false;
        
        if (this.type === 'exploder' && !wasAlly) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            damageZones.push(new DamageZone(0, centerY - 5, CONFIG.WIDTH, 10, 2000, 15)); // Horizontal
            damageZones.push(new DamageZone(centerX - 5, 0, 10, CONFIG.HEIGHT, 2000, 15)); // Vertical
            gameManager.exploderKillsThisRun++;
            checkAchievement('exploder_kills', gameManager.exploderKillsThisRun);
        }
        if (this.type === 'splitter' && !wasAlly) {
            enemies.push(new Enemy(this.x - 10, this.y, 'grunt_mini'));
            enemies.push(new Enemy(this.x + 10, this.y, 'grunt_mini'));
        }
        
        if (wasAlly) {
            const healAmount = player.stats.maxHp * player.stats.tempAlliance.healBonus;
            player.hp = Math.min(player.stats.maxHp, player.hp + healAmount);
            gameManager.healingDoneThisRun += healAmount; checkAchievement('healing', gameManager.healingDoneThisRun);
            floatingTexts.push(new FloatingText(`+${Math.round(healAmount)}`, player.x, player.y, '#00ff00'));
        } else {
            if (player && player.stats.tempAlliance && Math.random() < player.stats.tempAlliance.chance) {
                this.active = true; this.isAlly = true; this.hp = this.maxHp / 2; this.allyTimer = player.stats.tempAlliance.duration; 
                checkAchievement('convert_enemy_type', this.type);
                return;
            }
            
            gameManager.killsThisRun++; 
            checkAchievement('kills', gameManager.killsThisRun);
            checkAchievement('first_kill_difficulty', { difficulty: gameManager.difficulty, kills: gameManager.killsThisRun });
            gameManager.runFlags.multiKillCounter++; gameManager.runFlags.multiKillTimer = 2000;
            checkAchievement('multi_kill_in_time', gameManager.runFlags.multiKillCounter);

            if(gameManager.stats.killCounts[this.type]) gameManager.stats.killCounts[this.type]++; else gameManager.stats.killCounts[this.type] = 1;
            checkAchievement('kill_type', { subtype: this.type, count: gameManager.stats.killCounts[this.type] });
            if (this.isBoss) { gameManager.bossKillsThisRun++; checkAchievement('boss_kills', gameManager.bossKillsThisRun); checkAchievement('fast_boss_kill', Date.now() - gameManager.runFlags.bossSpawnTime); }
            if (Math.random() < CONFIG.COIN_DROP_CHANCE) coins.push(new Coin(this.x + this.width/2, this.y + this.height/2));
            if (player && player.stats.bloodRitual.chance > 0 && Math.random() < player.stats.bloodRitual.chance) {
                expOrbs.push(new ExpOrb(this.x + this.width/2, this.y + this.height/2, 10, true));
            }
            expOrbs.push(new ExpOrb(this.x+this.width/2, this.y+this.height/2, this.expValue));

            if (player.stats.vampiricExplosion.enabled && Math.random() < player.stats.vampiricExplosion.chance) {
                const healAmount = player.stats.maxHp * player.stats.vampiricExplosion.healPercent;
                player.hp = Math.min(player.stats.maxHp, player.hp + healAmount);
                gameManager.healingDoneThisRun += healAmount;
                checkAchievement('healing', gameManager.healingDoneThisRun);
                if (VISUAL_SETTINGS.particleIntensity > 0) {
                    particles.push(...createParticleBurst(this.x, this.y, 20, 'rgba(255, 0, 0, 0.7)'));
                    particles.push(new LifestealParticle(this.x, this.y, player));
                }
            }
        }
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x+this.width/2, this.y+this.height/2, CONFIG.PARTICLE_COUNT, this.color)); 
    }
}

class Projectile extends Entity { 
    constructor(x, y, vx, vy, d, c, s, co, isPlayer, pStats, l=5000) { 
        super(x, y, s, s, co); this.vx=vx; this.vy=vy; this.damage=d; this.isPlayer=isPlayer; 
        this.isCrit=c; this.lifetime=l; this.trail=[]; 
        this.pStats = pStats;
        this.hitCount = 0;
        this.maxHitCount = this.pStats.piercing?.enabled ? this.pStats.piercing.hits : 1;
        this.ricochetBouncesLeft = this.pStats.ricochet?.enabled ? this.pStats.ricochet.maxBounces : 0;
        this.returning = false;
        this.isGhost = this.pStats.ghostBullets?.enabled && Math.random() < this.pStats.ghostBullets.chance;
    } 
    update(dt){ 
        if(VISUAL_SETTINGS.trailIntensity > 0) {
            this.trail.push({x:this.x, y:this.y}); if(this.trail.length > 10 * (VISUAL_SETTINGS.trailIntensity / 7)) this.trail.shift(); 
        }
        this.x+=this.vx; this.y+=this.vy; this.lifetime-=dt; 
        
        if (this.isPlayer && this.pStats.ouroborosRounds?.enabled && this.lifetime < 3000 && !this.returning && this.hitCount === 0) {
            if (Math.random() < this.pStats.ouroborosRounds.chance) {
                this.returning = true;
                this.lifetime = 5000;
            }
        }

        if (this.returning) {
            const dx = player.x + player.width/2 - this.x; const dy = player.y + player.height/2 - this.y;
            const dist = Math.hypot(dx, dy); if (dist < player.width) { this.active = false; }
            const speed = Math.hypot(this.vx, this.vy);
            this.vx = (dx/dist) * speed; this.vy = (dy/dist) * speed;
        }

        if(this.lifetime<=0) this.active = false;
        
        if (this.pStats.ricochet?.enabled && this.ricochetBouncesLeft > 0) {
            if ((this.x <= 0 && this.vx < 0) || (this.x >= canvas.width && this.vx > 0)) {
                this.vx *= -1; this.ricochetBouncesLeft--; this.color = '#add8e6'; if(this.isPlayer) this.aimAtNearestEnemy(); gameManager.ricochetsThisRun++; checkAchievement('ricochets', gameManager.ricochetsThisRun);
            }
            if ((this.y <= 0 && this.vy < 0) || (this.y + this.vy > getGroundHeightAt(this.x))) {                this.vy *= -1; this.ricochetBouncesLeft--; this.color = '#add8e6'; if(this.isPlayer) this.aimAtNearestEnemy(); gameManager.ricochetsThisRun++; checkAchievement('ricochets', gameManager.ricochetsThisRun);
            }
        } else if (!this.isGhost) {
             if(this.x<0 || this.x>canvas.width || this.y<0 || this.y>canvas.height) this.active = false;
        }
    } 
    
    aimAtNearestEnemy() {
        let closest = null, min_dist = Infinity;
        enemies.forEach(e => {
            if (e.active && !e.isAlly) {
                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                if (dist < min_dist) { min_dist = dist; closest = e; }
            }
        });
        if (closest) {
            const angle = Math.atan2(closest.y - this.y, closest.x - this.x); const speed = Math.hypot(this.vx, this.vy);
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        }
    }

    draw(ctx){ 
        const trailColor = (this.pStats.ricochet?.enabled && this.ricochetBouncesLeft < this.pStats.ricochet.maxBounces) ? '#add8e6' : this.color;
        const critStacks = (player?.upgrades['Precision'] || 0);
        const critSize = this.isCrit ? 1 + critStacks * 0.1 : 1;
        const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
        
        // Efeito de fogo para 'Catalyst'
        if (this.isPlayer && this.pStats.catalyst?.stacks > 0) {
             if(VISUAL_SETTINGS.trailIntensity > 0) particles.push(new Particle(this.x, this.y, 0, 0, this.width * 2, 'rgba(255,100,0,0.2)', 200));
        }
        
        ctx.globalAlpha = this.isGhost ? 0.5 : 1;

        if (VISUAL_SETTINGS.trailIntensity > 0) {
            for(let i=0;i<this.trail.length;i++){ 
                const t=this.trail[i], r=i/this.trail.length; 
                ctx.beginPath(); ctx.arc(t.x,t.y,this.width*r*critSize,0,Math.PI*2); ctx.fillStyle=trailColor; ctx.globalAlpha=r*0.5 * (this.isGhost ? 0.5 : 1) * (VISUAL_SETTINGS.trailIntensity / 7); ctx.fill(); 
            } 
        }
        ctx.globalAlpha=this.isGhost ? 0.5 : 1; ctx.fillStyle=this.color; ctx.shadowColor=this.color; 
        ctx.shadowBlur=this.isCrit && VISUAL_SETTINGS.shadows ? (30 + critStacks * 5) * effectIntensity : 0; 
        ctx.beginPath(); ctx.arc(this.x, this.y, this.width * critSize, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0; 
        ctx.globalAlpha = 1;
    } 
}

class Particle extends Entity { 
    constructor(x,y,vx,vy,s,c,l) { super(x,y,s,s,c); this.vx=vx; this.vy=vy; this.lifespan=l; this.initialLifespan=l; } 
    update(dt){ this.x+=this.vx; this.y+=this.vy; this.vy+=CONFIG.GRAVITY*0.1; this.lifespan-=dt; if(this.lifespan<=0) this.active=false; } 
    draw(ctx){ const a=this.lifespan/this.initialLifespan; ctx.globalAlpha=a; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.width*a,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; } 
}

class LifestealParticle extends Particle {
    constructor(startX, startY, target, color = 'rgba(255, 80, 80, 0.8)') {
        super(startX, startY, 0, 0, 5, color, 1000);
        this.target = target;
    }
    update(dt) {
        if (!this.target) { this.active = false; return; }
        const dx = (this.target.x + this.target.width / 2) - this.x;
        const dy = (this.target.y + this.target.height / 2) - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 10) { this.active = false; return; }
        this.vx = dx / dist * 10;
        this.vy = dy / dist * 10;
        super.update(dt);
    }
}

class BloodParticle extends Particle { 
    constructor(x, y, vx, vy, s, c, l) { super(x, y, vx, vy, s, c, l); } 
    update(dt) { this.x += this.vx; this.y += this.vy; this.vy += CONFIG.GRAVITY * 0.5; this.lifespan -= dt; if (this.lifespan <= 0) this.active = false; } 
}

class FloatingText { 
    constructor(t,x,y,c,s=20){ this.text=t; this.x=x; this.y=y; this.color=c; this.size=s; this.vy=-2; this.lifespan=1000; this.active=true; } 
    update(dt){ this.y+=this.vy; this.lifespan-=dt; if(this.lifespan<=0) this.active=false; } 
    draw(ctx){ ctx.save(); ctx.globalAlpha=this.lifespan/1000; ctx.fillStyle=this.color; ctx.font=`bold ${this.size}px 'Segoe UI'`; ctx.textAlign='center'; ctx.shadowColor='black'; ctx.shadowBlur=8; ctx.fillText(this.text,this.x,this.y); ctx.restore(); } 
}

class ExpOrb extends Entity { 
    constructor(x,y,v,h=false){ 
        const s=h?12:8, c=h?'lightgreen':'#ffd700'; super(x,y,s,s,c); this.value=v; this.isHeal=h; this.vy = -3; this.vx = (Math.random() - 0.5) * 2;
    } 
    update(dt,p){ 
        if(!this.isHeal) this.vy += CONFIG.GRAVITY * 0.3; this.x += this.vx; this.y += this.vy;
        const groundY = getGroundHeightAt(this.x);
        if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; this.vx *= 0.8; }
        const dist=Math.hypot(p.x+p.width/2-this.x, p.y+p.height/2-this.y); 
        if(dist < p.width/2 + 5){ 
            this.active=false; 
            if(this.isHeal){
                const healAmount = 10;
                p.hp=Math.min(p.stats.maxHp,p.hp+healAmount);
                gameManager.healingDoneThisRun += healAmount; checkAchievement('healing', gameManager.healingDoneThisRun);
                floatingTexts.push(new FloatingText('+10 HP', this.x, this.y, '#00ff00', 20));
            } 
            else { p.addExp(this.value); floatingTexts.push(new FloatingText(`+${this.value} XP`, this.x, this.y, '#ffd700', 20)); } 
        } 
    } 
    draw(ctx){ ctx.fillStyle=this.color; ctx.shadowColor=this.color; ctx.shadowBlur=VISUAL_SETTINGS.shadows ? 15 : 0; ctx.beginPath(); ctx.arc(this.x,this.y,this.width,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; } 
}

class Coin extends Entity {
    constructor(x, y) {
        super(x, y, 10, 10, '#ffd700'); this.value = 1; this.rotation = Math.random() * Math.PI * 2; this.vy = -3; this.vx = (Math.random() - 0.5) * 2;
    }
    update(dt, p) {
        this.rotation += dt * 0.005; this.vy += CONFIG.GRAVITY * 0.3; this.x += this.vx; this.y += this.vy;
        const groundY = getGroundHeightAt(this.x);
        if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; this.vx *= 0.8; }
        if (player) { const dist = Math.hypot(p.x + p.width/2 - this.x, p.y + p.height/2 - this.y); if (dist < p.width/2) { this.active = false; p.addCoin(this.value); } }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(this.rotation);
        ctx.fillStyle = this.color; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.beginPath(); ctx.arc(0, 0, this.width, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', 0, 1); 
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class BlackHole { 
    constructor(x, y, stats) { 
        this.x = x; this.y = y;
        this.radius = stats.radius; this.duration = stats.duration;
        this.damagePercent = stats.damagePercent; this.tickRate = stats.tickRate;
        this.timer = this.duration; this.tickTimer = this.tickRate;
        this.active = true; this.glowTimer = 0; this.kills = 0;
    } 
    update(dt) { 
        this.timer -= dt; this.tickTimer -= dt;
        if (this.timer <= 0) { 
            this.active = false; 
            checkAchievement('black_hole_multikill', this.kills);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 50, '#9c27b0')); 
            return; 
        } 

        let doDamage = false;
        if(this.tickTimer <= 0) {
            doDamage = true;
            this.tickTimer = this.tickRate;
        }

        enemies.forEach(e => { 
            if (e.active && !e.isAlly) { 
                const dx = this.x - (e.x + e.width/2); const dy = this.y - (e.y + e.height/2); 
                const dist = Math.hypot(dx, dy); 
                if (dist < this.radius * 2.5) { 
                    const force = 1.5 * (1 - dist/(this.radius * 2.5)); 
                    e.x += (dx/dist) * force; e.y += (dy/dist) * force; 
                    if (dist < this.radius * 0.8 && doDamage) {
                        const hpBefore = e.hp;
                        const damage = e.maxHp * this.damagePercent;
                        e.takeDamage(damage, true, true);
                        if (e.hp <= 0 && hpBefore > 0) { this.kills++; }
                    }
                } 
            } 
        }); 
    } 
    draw(ctx) { 
        const lifeRatio = this.timer / this.duration;
        const currentRadius = this.radius * Math.sin(Math.PI * (1 - lifeRatio)); // Grow and shrink
        ctx.save();
        ctx.globalAlpha = 0.8 * lifeRatio; 
        
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentRadius);
        grad.addColorStop(0, 'rgba(0,0,0,1)');
        grad.addColorStop(0.7, 'rgba(156, 39, 176, 0.5)');
        grad.addColorStop(1, 'rgba(156, 39, 176, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, currentRadius, 0, Math.PI*2); 
        ctx.fill(); 
        ctx.restore();
    } 
}

class OrbitalShield {
    constructor(player, isPet) {
        this.player = player; this.isPet = isPet; this.radius = isPet ? 8 : 12; this.color = isPet ? '#ff4081' : '#00ffff';
        this.orbitRadius = 80; this.angle = Math.random() * Math.PI * 2; this.active = true; this.shootTimer = isPet ? player.stats.laserPet.attackSpeed : 0;
    }
    update(dt) {
        if (!this.player || !this.player.active) { this.active = false; return; }
        const speed = this.isPet ? 2 : this.player.stats.orbitalShield.speed; this.angle += speed * dt * 0.001;
        const allOrbitals = orbitalShields.filter(o => o.active && o.isPet === this.isPet);
        const myIndex = allOrbitals.indexOf(this); const total = allOrbitals.length > 0 ? allOrbitals.length : 1;
        const angleOffset = (2 * Math.PI / total) * myIndex;
        this.x = this.player.x + this.player.width/2 + Math.cos(this.angle + angleOffset) * this.orbitRadius;
        this.y = this.player.y + this.player.height/2 + Math.sin(this.angle + angleOffset) * this.orbitRadius;
        if (this.isPet) {
            this.shootTimer -= dt;
            if (this.shootTimer <= 0 && enemies.length > 0) {
                 let closest = null, min_dist = Infinity;
                 const validTargets = enemies.filter(e => e.active && !e.isAlly);
                 validTargets.forEach(e => {
                     const dist = Math.hypot(this.x - e.x, this.y - e.y); if (dist < min_dist) { min_dist = dist; closest = e; }
                 });
                 if (closest) {
                     const a = Math.atan2(closest.y - this.y, closest.x - this.x);
                     projectiles.push(new Projectile(this.x, this.y, Math.cos(a)*10, Math.sin(a)*10, this.player.stats.laserPet.damage, false, 3, this.color, true, {}));
                     this.shootTimer = this.player.stats.laserPet.attackSpeed;
                 }
            }
        } else {
            projectiles.forEach(p => {
                if (p.active && !p.isPlayer && Math.hypot(this.x - p.x, this.y - p.y) < this.radius + p.width) {
                    p.active = false; if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 10, this.color));
                }
            });
        }
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class MirageClone extends Entity {
    constructor(x, y, w, h, duration) {
        super(x, y, w, h, 'rgba(0, 150, 255, 0.5)');
        this.duration = duration;
        this.timer = duration;
    }
    update(dt) {
        this.timer -= dt;
        if (this.timer <= 0) {
            this.active = false;
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = (this.timer / this.duration) * 0.5 * (VISUAL_SETTINGS.cardEffectIntensity / 10);
        renderCharacter(ctx, this.x, this.y, this.width, this.height, 1, false);
        ctx.restore();
    }
}

class GravityWell {
    constructor(x, y, radius, duration) { this.x = x; this.y = y; this.radius = radius; this.duration = duration; this.timer = this.duration; this.active = true; } 
    update(dt) {
        this.timer -= dt; if (this.timer <= 0) { this.active = false; return; }
        enemies.forEach(e => {
            if (e.active && !e.isAlly) {
                const dx = this.x - (e.x + e.width/2); const dy = this.y - (e.y + e.height/2); const dist = Math.hypot(dx, dy);
                if (dist < this.radius) { const force = 0.2 * (1 - dist/this.radius); e.x += (dx/dist) * force; e.y += (dy/dist) * force; }
            }
        });
    }
    draw(ctx) {
        ctx.save(); ctx.globalAlpha = (this.timer / this.duration) * 0.5 * (VISUAL_SETTINGS.cardEffectIntensity / 10); ctx.fillStyle = '#9c27b0';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 - (this.timer / this.duration)), 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
}

class DamageZone {
    constructor(x, y, width, height, duration, damage, isCircle = false, color = 'rgba(255, 0, 0, 0.4)') {
        this.x = x; this.y = y; this.width = width; this.height = height; this.duration = duration;
        this.damage = damage; this.isCircle = isCircle; this.color = color; this.active = true;
        this.hitCooldown = 500; this.hitTimer = 0;
    }
    update(dt) {
        this.duration -= dt; if(this.duration <= 0) this.active = false;
        this.hitTimer -= dt;
        if(this.hitTimer <= 0) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            if (player) {
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                let collided = false;
                if (this.isCircle) {
                    const dist = Math.hypot(centerX - playerCenterX, centerY - playerCenterY);
                    if (dist < this.width / 2 + player.width / 2) collided = true;
                } else {
                    if (player.x < this.x + this.width && player.x + player.width > this.x &&
                        player.y < this.y + this.height && player.y + player.height > this.y) {
                        collided = true;
                    }
                }
                if (collided) {
                    player.takeDamage(this.damage);
                    this.hitTimer = this.hitCooldown;
                }
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = (this.duration / 500) * 0.7; // Fade out effect
        ctx.fillStyle = this.color;
        if(this.isCircle) {
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        ctx.restore();
    }
}

// FunÃ§Ãµes para criaÃ§Ã£o de partÃ­culas e efeitos
function createParticleBurst(x,y,c,co, alpha = 1){ 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; let b=[]; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const count = Math.floor(c * intensityFactor);
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2, s=Math.random()*5+2, vx=Math.cos(a)*s, vy=Math.sin(a)*s, si=Math.random()*3+1, l=Math.random()*800+400; const p = new Particle(x,y,vx,vy,si,co,l); p.alpha = alpha; b.push(p); } return b; 
}
function createMuzzleFlash(x, y, angle, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { const a = angle + (Math.random() - 0.5) * 0.3, s = Math.random() * 5 + 3, z = Math.random() * 2 + 1; p.push(new Particle(x, y, Math.cos(a) * s, Math.sin(a) * s, z, CONFIG.COLOR_PLAYER_PROJECTILE, 300)); } return p; 
}
function createTrailParticles(x, y, count, color) { 
    if (VISUAL_SETTINGS.trailIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.trailIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { p.push(new Particle(x + (Math.random() - 0.5) * 20, y, (Math.random()-0.5)*1, Math.random()*2, Math.random() * 2 + 1, color, 1000)); } return p; 
}
function createJumpDust(x, y, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { p.push(new Particle(x + (Math.random() - 0.5) * 30, y, (Math.random()-0.5)*3, -Math.random()*2, Math.random() * 3 + 2, '#8a8ac0', 800)); } return p; 
}
function createDeathExplosion(x, y, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { const a = Math.random() * Math.PI * 2, s = Math.random() * 5 + 2; p.push(new Particle(x, y, Math.cos(a) * s, Math.sin(a) * s, Math.random() * 4 + 2, '#ff5555', 1500)); } return p; 
}
function createBloodSplatter(x, y, amount) { 
    if (!VISUAL_SETTINGS.blood) return; const s = document.createElement('div'); 
    s.className = 'blood-splatter'; const z = Math.min(200, 20 + amount * 3); s.style.width = `${z}px`; s.style.height = `${z}px`; s.style.left = `${x}px`; s.style.top = `${y}px`; 
    document.body.appendChild(s); bloodSplatters.push({element: s, time: 2000}); 
}
function createDamageIndicator(x, y, amount) {
    const indicator = document.createElement('div'); indicator.className = 'damage-indicator'; indicator.textContent = `-${Math.round(amount)}`; indicator.style.left = `${x}px`; indicator.style.top = `${y}px`;
    document.body.appendChild(indicator); setTimeout(() => { indicator.remove(); }, 1000);
}
function createLightningStrike(x, y, damage) {
    if (VISUAL_SETTINGS.cardEffectIntensity <= 0) return; const lightning = document.createElement('div');
    lightning.className = 'lightning'; lightning.style.left = `${x}px`; lightning.style.top = '0'; lightning.style.height = `${y}px`;
    document.body.appendChild(lightning);
    enemies.forEach(e => { if (e.active && Math.abs(e.x + e.width/2 - x) < 30 && e.y < y) e.takeDamage(damage, false); });
    setTimeout(() => { lightning.remove(); }, 300);
}
function createHolyBeam(x, damage) {
    if (VISUAL_SETTINGS.cardEffectIntensity <= 0) return;
    const beamY = getGroundHeightAt(x);
    const beam = document.createElement('div');
    beam.className = 'lightning'; // Re-use lightning CSS, change color
    beam.style.background = 'linear-gradient(to bottom, rgba(255,255,255,0.9) 0%, rgba(255,255,224,0.9) 100%)';
    beam.style.left = `${x}px`; beam.style.top = '0'; beam.style.height = `${beamY}px`;
    document.body.appendChild(beam);
    enemies.forEach(e => { if (e.active && Math.abs(e.x + e.width/2 - x) < 30) e.takeDamage(damage, false); });
    setTimeout(() => { beam.remove(); }, 300);
}
function createShockwaveEffect(x, y, radius) {
    if (VISUAL_SETTINGS.particleIntensity <= 0) return [];
    const p = [];
    for(let i=0; i < radius / 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        p.push(new Particle(x, y, Math.cos(angle) * i * 0.1, 0, 3, 'rgba(255, 255, 255, 0.5)', 300));
    }
    return p;
}
function createTetherEffect(x1, y1, x2, y2, color) {
    // This effect is best drawn directly on canvas for one frame
    floatingTexts.push({
        draw: (ctx) => {
            ctx.save(); ctx.globalAlpha = 0.5; ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.restore();
        },
        update: function(dt) { this.lifespan -= dt; if (this.lifespan <= 0) this.active = false; },
        lifespan: 100, active: true
    });
}

// ===================================================================================
// 5. FUNÃÃES DE LÃGICA DO JOGO (INCLUINDO CONQUISTAS E RECORDES)
// ===================================================================================

function startGame(restart = false) {
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
    gameManager.running = false;
    stopMainMenuAnimations();
    
    if (!restart) {
        if (gameManager.isCharacterRandom) {
            const characters = ['warrior', 'archer', 'mage'];
            gameManager.stats.character = characters[Math.floor(Math.random() * characters.length)];
        }
        if (gameManager.isDifficultyRandom) {
            const difficulties = ['easy', 'normal', 'hard'];
            gameManager.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
        }
        if (gameManager.isGameModeRandom) {
            const modes = ['waves', 'infinite'];
            gameManager.gameMode = modes[Math.floor(Math.random() * modes.length)];
        }
    }

    document.querySelectorAll('.ui-modal').forEach(modal => modal.style.display = 'none');
    canvas.style.display = 'block'; 
    pauseButton.style.display = 'block'; 
    if(VISUAL_SETTINGS.cheatFeaturesEnabled) cheatMenuButton.style.display = 'block';
    settingsButton.style.display = 'none';
    ingameCardsUI.style.display = 'block';
    ingameInfoDisplay.style.display = 'block';
    gameTimerDisplay.style.display = 'block';
    
    controlsHint.textContent = gameManager.controlScheme === 'desktop' ? 'Controles: A/D ou Setas para mover, EspaÃ§o para pular, Mouse para atirar' : 'Controles: Use os joysticks para mover e atirar';
    
    Object.assign(gameManager, { 
        running: true, 
        paused: false, gameOver: false, victory: false,
        killsThisRun: 0, bossKillsThisRun: 0,
        gameTime: 0, wave: 0, waveState: 'COOLDOWN', waveTimer: CONFIG.WAVE_SPAWN_COOLDOWN, 
        noDamageWaves: 0, totalExpThisRun: 0, jumpsThisRun: 0, xpOrbsCollected: 0, coinsInRun: 0,
        frozenEnemiesThisRun: 0, healingDoneThisRun: 0, blackHoleKillsThisRun: 0, ricochetsThisRun: 0,
        rageKillsThisRun: 0, simultaneousKills: 0, barrierBlocks: 0, stationaryWaveCount: 0
    });
    gameManager.stats.killCounts = {}; gameManager.stats.criticalHitsThisRun = 0; gameManager.stats.rerollsThisRun = 0; gameManager.stats.deathsThisRun = 0;
    
    groundPath = generateSmoothGround(); platforms = generatePlatforms();
    enemies = []; projectiles = []; particles = []; expOrbs = []; floatingTexts = [];
    blackHoles = []; orbitalShields = []; coins = []; mirageClones = []; gravityWells = []; damageZones = [];
    player = new Player(canvas.width / 2, 500);
    updateIngameCardsUI();
    updateIngameInfoDisplay();

    lastTime = performance.now(); lastDamageWave = -1;
    
    if (gameManager.controlScheme === 'mobile') {
        movementJoystick = new JoystickController(150, CONFIG.HEIGHT - 150, 80, 40, '255, 255, 255');
        shootingJoystick = new JoystickController(CONFIG.WIDTH - 150, CONFIG.HEIGHT - 150, 80, 40, '255, 152, 0');
    }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}

function generatePlatforms() {
    const p = [];
    for (let i = 0; i < CONFIG.PLATFORM_COUNT; i++) {
        const width = CONFIG.PLATFORM_WIDTH_MIN + Math.random() * (CONFIG.PLATFORM_WIDTH_MAX - CONFIG.PLATFORM_WIDTH_MIN);
        let x, y, validPosition = false, attempts = 0;
        while (!validPosition && attempts < 20) {
            x = Math.random() * (canvas.width - width); y = CONFIG.PLATFORM_MIN_Y + Math.random() * (CONFIG.PLATFORM_MAX_Y - CONFIG.PLATFORM_MIN_Y);
            validPosition = true;
            for (const existing of p) {
                const xDist = Math.abs((x + width / 2) - (existing.x + existing.width / 2));
                if (xDist < (width + existing.width) / 2 + 50) { validPosition = false; break; }
            }
            attempts++;
        }
        if (validPosition) p.push(new Platform(x, y, width));
    }
    return p;
}
function generateSmoothGround() {
    const path = []; const segCount = Math.ceil(CONFIG.WIDTH / CONFIG.GROUND_SEGMENT_WIDTH); let prevY = CONFIG.GROUND_BASE_HEIGHT;
    for (let i = 0; i <= segCount; i++) {
        const x = i * CONFIG.GROUND_SEGMENT_WIDTH;
        const wave1 = Math.sin(i * CONFIG.GROUND_ROUGHNESS * 2) * CONFIG.GROUND_AMPLITUDE; 
        const wave2 = Math.cos(i * CONFIG.GROUND_ROUGHNESS * 1.4) * CONFIG.GROUND_AMPLITUDE * 0.6; 
        const y = CONFIG.GROUND_BASE_HEIGHT - (wave1 + wave2);
        const smoothedY = i === 0 ? y : prevY * 0.7 + y * 0.3; path.push({ x, y: smoothedY }); prevY = smoothedY;
    } return path;
}
function getGroundHeightAt(x) {
    if (!groundPath || groundPath.length < 2) return CONFIG.HEIGHT; 
    for (let i = 0; i < groundPath.length - 1; i++) {
        if (x >= groundPath[i].x && x <= groundPath[i+1].x) { const p1 = groundPath[i], p2 = groundPath[i+1]; return p1.y + (p2.y - p1.y) * ((x - p1.x) / (p2.x - p1.x)); }
    }
    if (x < groundPath[0].x) return groundPath[0].y;
    return groundPath[groundPath.length - 1].y;
}
function createStars() {
    const starsContainer = document.getElementById('stars'); starsContainer.innerHTML = ''; 
    for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
        const star = document.createElement('div'); star.className = 'star';
        const size = Math.random() * 2 + 1, left = Math.random() * 100, top = Math.random() * 100, duration = Math.random() * 5 + 3;
        star.style.width = `${size}px`; star.style.height = `${size}px`; star.style.left = `${left}%`; star.style.top = `${top}%`;
        star.style.setProperty('--duration', `${duration}s`); starsContainer.appendChild(star);
    }
}
function lerpColor(c1, c2, factor) {
    const r1 = parseInt(c1.substr(1, 2), 16); const g1 = parseInt(c1.substr(3, 2), 16); const b1 = parseInt(c1.substr(5, 2), 16);
    const r2 = parseInt(c2.substr(1, 2), 16); const g2 = parseInt(c2.substr(3, 2), 16); const b2 = parseInt(c2.substr(5, 2), 16);
    const r = Math.round(r1 + factor * (r2 - r1)); const g = Math.round(g1 + factor * (g2 - g1)); const b = Math.round(b1 + factor * (b2 - b1));
    return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
}
function updateThemeTransition(deltaTime) {
    if (!themeTransition.active) return;
    themeTransition.progress += deltaTime;
    const factor = Math.min(themeTransition.progress / themeTransition.duration, 1);
    
    frameColors.bg[0] = lerpColor(themeTransition.from.bg[0], themeTransition.to.bg[0], factor);
    frameColors.bg[1] = lerpColor(themeTransition.from.bg[1], themeTransition.to.bg[1], factor);
    frameColors.ground = lerpColor(themeTransition.from.ground, themeTransition.to.ground, factor);
    frameColors.ground_top = lerpColor(themeTransition.from.ground_top, themeTransition.to.ground_top, factor);
    frameColors.platform = lerpColor(themeTransition.from.platform, themeTransition.to.platform, factor);

    if (factor >= 1) themeTransition.active = false;
}
function waveManager(deltaTime) { 
    if (gameManager.paused || gameManager.gameOver || gameManager.victory) return;
    if (gameManager.waveState === 'COOLDOWN') { 
        waveIndicator.textContent = `PrÃ³xima onda em: ${(gameManager.waveTimer/1000).toFixed(1)}s`;
        gameManager.waveTimer -= deltaTime; 
        if (gameManager.waveTimer <= 0) { 
            gameManager.wave++; 
            if (gameManager.wave >= 101 && gameManager.gameMode === 'waves') {
                gameManager.victory = true;
                return;
            }
            
            const themeKeys = Object.keys(THEMES);
            const themeIndex = Math.floor((gameManager.wave - 1) / 5) % themeKeys.length;
            const newTheme = THEMES[themeKeys[themeIndex]];
            if (newTheme.name !== currentTheme.name) {
                themeTransition = { active: true, progress: 0, duration: 2000, from: { ...currentTheme }, to: { ...newTheme } };
                currentTheme = newTheme;
            }
            
            if (currentTheme.name !== gameManager.runFlags.currentThemeName) {
                gameManager.runFlags.currentThemeName = currentTheme.name;
                gameManager.runFlags.wavesInCurrentTheme = 1;
            } else {
                gameManager.runFlags.wavesInCurrentTheme++;
            }
            checkAchievement('survival_in_theme', { theme: gameManager.runFlags.currentThemeName, waves: gameManager.runFlags.wavesInCurrentTheme });

            Object.assign(gameManager.runFlags, { playerMovedHorizontally: false, tookDamageThisWave: false, hpAtWaveStart: player.hp });
            gameManager.shotsFiredThisWave = 0;
            if (gameManager.wave % 5 === 0) { bossWarning.style.display = 'block'; setTimeout(() => { bossWarning.style.display = 'none'; }, 3000); gameManager.runFlags.bossSpawnTime = Date.now(); }
            
            checkAchievement('wave', gameManager.wave);
            checkAchievement('wave_in_mode', { wave: gameManager.wave, mode: gameManager.gameMode });
            checkAchievement('wave_in_difficulty', { wave: gameManager.wave, difficulty: gameManager.difficulty });
            
            if (gameManager.wave > 1 && gameManager.wave - 1 > lastDamageWave) { 
                gameManager.noDamageWaves++; 
                if(gameManager.noDamageWaves > 0) checkAchievement('no_damage_waves', gameManager.noDamageWaves); 
            } else { 
                gameManager.noDamageWaves = 0; 
            }
            if(!gameManager.runFlags.playerMovedHorizontally && gameManager.wave > 10) {
                gameManager.stationaryWaveCount++;
                checkAchievement('stationary_waves', gameManager.stationaryWaveCount);
            } else {
                gameManager.stationaryWaveCount = 0;
            }
            
            gameManager.waveState = 'SPAWNING'; 
            let spawnMultiplier = 1.0;
            if(gameManager.difficulty === 'hard') spawnMultiplier = 1.2;
            else if(gameManager.difficulty === 'easy') spawnMultiplier = 0.6;

            const totalEnemies = Math.floor((5 + gameManager.wave * CONFIG.WAVE_ENEMY_MULTIPLIER) * spawnMultiplier);
            const groundEnemyTypes = ['grunt', 'tank', 'shooter', 'bomber', 'bouncer', 'exploder', 'healer', 'teleporter', 'splitter'];
            const flyingEnemyTypes = ['flyer', 'elite'];

            for (let i = 0; i < totalEnemies; i++) {
                const isFlying = Math.random() < 0.2;
                const type = isFlying ? flyingEnemyTypes[Math.floor(Math.random() * flyingEnemyTypes.length)] : groundEnemyTypes[Math.floor(Math.random() * groundEnemyTypes.length)];
                const newEnemy = new Enemy(Math.random() * CONFIG.WIDTH, -50 - Math.random() * 100, type);
                newEnemy.lastDamageTime = gameManager.gameTime; // Inicia com o tempo atual
                enemies.push(newEnemy);
            }

            if (gameManager.wave % 5 === 0) {
                const boss = new Enemy(CONFIG.WIDTH/2, -100, currentTheme.boss_type);
                boss.lastDamageTime = gameManager.gameTime;
                enemies.push(boss);
            }
            
            floatingTexts.push(new FloatingText(`ONDA ${gameManager.wave} INICIADA!`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2, '#ff5555', 40));
        } 
    } else if (gameManager.waveState === 'SPAWNING') {
        const remainingEnemies = enemies.filter(e => e.active && !e.isAlly);
        waveIndicator.textContent = `Onda: ${gameManager.wave} | Inimigos: ${remainingEnemies.length}`;
        
        // MODIFICADO [v7.9]: Novo sistema "Resgate e LiberaÃ§Ã£o"
        if (remainingEnemies.length > 0 && remainingEnemies.length <= 2) {
            const timeSinceLastDamage = gameManager.gameTime - Math.max(...remainingEnemies.map(e => e.lastDamageTime || 0), 0);
            
            const PULL_TRIGGER_TIME = (remainingEnemies.length === 1) ? 5000 : 10000;
            
            if (timeSinceLastDamage > PULL_TRIGGER_TIME) {
                remainingEnemies.forEach(e => {
                    if (!e.isBeingRescued) {
                        e.isBeingRescued = true; // Inicia o processo de puxar
                    }
                });
            }
        }

        if (remainingEnemies.length === 0) {
            gameManager.waveState = 'COOLDOWN'; gameManager.waveTimer = CONFIG.WAVE_SPAWN_COOLDOWN; 
            if (player.hp / player.stats.maxHp < 0.1) checkAchievement('clutch_wave', 1);
            if (player.hp === 1) checkAchievement('one_hp_clutch', 1);
            if (gameManager.wave > 10 && gameManager.shotsFiredThisWave === 0) checkAchievement('no_shot_wave', 1);
            if (!gameManager.runFlags.playerMovedHorizontally && gameManager.wave % 5 === 0) checkAchievement('no_move_boss_wave', 1);
            if (!gameManager.runFlags.tookDamageThisWave && gameManager.wave % 5 === 0) checkAchievement('no_damage_boss_wave', 1);
            if (gameManager.runFlags.hpAtWaveStart < player.stats.maxHp * 0.1 && player.hp > player.stats.maxHp * 0.9) checkAchievement('comeback_wave', 1);

            floatingTexts.push(new FloatingText(`ONDA ${gameManager.wave} COMPLETA!`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2, '#4caf50', 40));
            const waveBonusCoins = gameManager.wave * CONFIG.WAVE_BONUS_COIN_MULTIPLIER;
            if (player) player.addCoin(waveBonusCoins);
            floatingTexts.push(new FloatingText(`+${waveBonusCoins} Moedas (BÃ´nus de Onda)`, canvas.width/2, canvas.height/2 + 40, '#ffd700', 20));
        }
    } 
}
function handleCollisions() { 
    projectiles.forEach(p => { 
        if (p.isPlayer && p.active) { 
            let simultaneousKillsThisFrame = 0;
            enemies.forEach(e => { 
                if (e.active && !e.isAlly && (p.x > e.x && p.x < e.x + e.width && p.y > e.y && p.y < e.y + e.height)) { 
                    const hpBefore = e.hp;
                    
                    if (p.isCrit && p.pStats.blackHole?.enabled && Math.random() < p.pStats.blackHole.chance) {
                        blackHoles.push(new BlackHole(e.x + e.width/2, e.y + e.height/2, p.pStats.blackHole));
                    }

                    e.takeDamage(p.damage, p.isPlayer);
                    
                    if (!e.active && hpBefore > 0) { simultaneousKillsThisFrame++; }
                    
                    if (p.pStats.chainLightning?.enabled && Math.random() < p.pStats.chainLightning.chance) {
                        let currentTarget = e;
                        let bounceCount = p.pStats.chainLightning.bounces;
                        let chainedEnemies = new Set([e]);
                        for(let i = 0; i < bounceCount; i++) {
                            let nextTarget = null, min_dist = 150;
                            enemies.forEach(nextE => {
                                if(nextE.active && !nextE.isAlly && !chainedEnemies.has(nextE)) {
                                    const dist = Math.hypot(currentTarget.x - nextE.x, currentTarget.y - nextE.y);
                                    if(dist < min_dist) { min_dist = dist; nextTarget = nextE; }
                                }
                            });
                            if(nextTarget) {
                                if (VISUAL_SETTINGS.cardEffectIntensity > 0) createTetherEffect(currentTarget.x, currentTarget.y, nextTarget.x, nextTarget.y, '#2196f3');
                                nextTarget.takeDamage(p.damage * p.pStats.chainLightning.damageMultiplier, true);
                                chainedEnemies.add(nextTarget);
                                currentTarget = nextTarget;
                            } else { break; }
                        }
                    }

                    if (p.pStats.gravityWell?.enabled && Math.random() < p.pStats.gravityWell.chance) {
                        gravityWells.push(new GravityWell(e.x + e.width/2, e.y + e.height/2, p.pStats.gravityWell.radius, p.pStats.gravityWell.duration));
                    }
                    p.hitCount++; if (p.hitCount >= p.maxHitCount) p.active = false; 
                }
            });
            if(simultaneousKillsThisFrame > gameManager.simultaneousKills) gameManager.simultaneousKills = simultaneousKillsThisFrame;
            checkAchievement('simultaneous_kills', gameManager.simultaneousKills);
        } 
        if (!p.isPlayer && p.active && player && (p.x > player.x && p.x < player.x + player.width && p.y > player.y && p.y < player.y + player.height)) { 
            p.active = false; player.takeDamage(10); 
        } 
    }); 
    for (let i = coins.length - 1; i >= 0; i--) { if (!coins[i].active) { coins.splice(i,1); } }
}
function showUpgradeScreen() {
    const choicesContainer = document.getElementById('upgrade-choices'); choicesContainer.innerHTML = '';
    const availableUpgrades = Object.keys(UPGRADES).filter(key => { const upgrade = UPGRADES[key]; const currentStacks = player.upgrades[key] || 0; return !upgrade.maxStacks || currentStacks < upgrade.maxStacks; });
    
    const weightedPool = [];
    availableUpgrades.forEach(key => {
        const rarity = UPGRADES[key].rarity;
        let weight = 1;
        if (rarity === 'common') weight = 10;
        if (rarity === 'uncommon') weight = 7;
        if (rarity === 'rare') weight = 4;
        if (rarity === 'epic') weight = 2;
        if (rarity === 'legendary') weight = 1;
        for(let i=0; i < weight; i++) weightedPool.push(key);
    });

    const choices = player.stats.upgradeChoices; const selectedKeys = new Set();
    while (selectedKeys.size < choices && weightedPool.length > 0) { 
        const randomIndex = Math.floor(Math.random() * weightedPool.length); 
        selectedKeys.add(weightedPool[randomIndex]);
    }

    selectedKeys.forEach(key => {
        const upgrade = UPGRADES[key]; const card = document.createElement('div'); card.className = `upgrade-card card-rarity-${upgrade.rarity}`;
        card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
        card.addEventListener('click', () => {
            player.addUpgrade(key); upgradeModal.style.opacity = '0';
            setTimeout(() => { upgradeModal.style.display = 'none'; gameManager.paused = false; }, 300);
        });
        choicesContainer.appendChild(card);
    });
    rollUpgradesButton.disabled = gameManager.stats.coins < 50;
    upgradeModal.style.display = 'flex'; setTimeout(() => upgradeModal.style.opacity = '1', 10);
}
function saveCurrentRunAsRecord() {
    if (gameManager.gameTime <= 5000) return;
    const m = Math.floor(gameManager.gameTime/60000), s = Math.floor((gameManager.gameTime % 60000) / 1000); 
    const timeStr = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    const newRecord = { 
        date: new Date().toLocaleDateString('pt-BR'), 
        time: timeStr, 
        wave: gameManager.wave, 
        kills: gameManager.killsThisRun, 
        xp: gameManager.totalExpThisRun,
        character: gameManager.stats.character,
        isCharacterRandom: gameManager.isCharacterRandom,
        difficulty: gameManager.difficulty,
        isDifficultyRandom: gameManager.isDifficultyRandom,
        mode: gameManager.gameMode,
        isGameModeRandom: gameManager.isGameModeRandom,
        device: gameManager.chosenDevice
    };
    PLAYER_RECORDS.unshift(newRecord); if(PLAYER_RECORDS.length > 50) PLAYER_RECORDS.pop(); 
    saveGameData();
    populateBestRecordDisplay();
}
function showGameOverScreen() { 
    saveCurrentRunAsRecord();
    const m = Math.floor(gameManager.gameTime/60000), s = Math.floor(gameManager.gameTime%60000/1000); 
    const timeStr = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    document.getElementById('final-stats').innerHTML = `Nickname: ${PLAYER_CUSTOMIZATION.nickname} | Tempo: ${timeStr}`;
    
    const difficultyText = gameManager.difficulty.charAt(0).toUpperCase() + gameManager.difficulty.slice(1);
    const modeText = gameManager.gameMode === 'waves' ? '100 Ondas' : 'Infinito';
    document.getElementById('game-over-details').textContent = `Modo: ${modeText} | Dificuldade: ${difficultyText}`;

    document.getElementById('final-wave').textContent = gameManager.wave;
    document.getElementById('final-kills').textContent = gameManager.killsThisRun;
    document.getElementById('final-xp').textContent = gameManager.totalExpThisRun;
    document.getElementById('final-coins').textContent = gameManager.coinsInRun; 
    gameOverScreen.style.display='flex'; setTimeout(() => gameOverScreen.style.opacity='1', 10);
}
function showVictoryScreen() { 
    gameManager.stats.coins += 250;
    gameManager.stats.totalWins++;
    checkAchievement('wave', 101);
    checkAchievement('win_condition', { difficulty: gameManager.difficulty });
    checkAchievement('win_with_card', { cardName: 'GlassCannon' });
    checkAchievement('win_no_deaths', { difficulty: gameManager.difficulty });
    checkAchievement('win_condition_no_rarity', { rarity: 'common'});
    checkAchievement('total_wins', gameManager.stats.totalWins);
    saveCurrentRunAsRecord();
    victoryModal.style.display='flex'; setTimeout(() => victoryModal.style.opacity='1', 10);
}

function checkAchievement(type, data, suppressNotification = false) {
    let unlockedAny = false;
    gameManager.achievements.forEach(ach => {
        if (ach.unlocked) return;
        if (ach.type !== type) return; 

        let conditionMet = false;
        switch(type) {
            case 'kills': case 'wave': case 'level': case 'boss_kills': case 'no_damage_waves': 
            case 'survival_time': case 'xp_orbs': case 'unique_cards': case 'frozen_enemies':
            case 'healing': case 'black_hole_kills': case 'coins_in_run': case 'ricochets':
            case 'rage_kills': case 'single_hit_damage': case 'simultaneous_kills': case 'barrier_blocks':
            case 'rerolls_in_run': case 'total_wins': case 'exploder_kills': case 'stationary_waves':
                if (data >= ach.target) conditionMet = true; 
                break;
            case 'attack_speed_milestone':
                if (data <= ach.target) conditionMet = true;
                break;
            case 'kill_type':
                if(data.subtype === ach.subtype) { 
                    if (data.count >= ach.target) conditionMet = true; 
                } 
                break;
            case 'clutch_wave': case 'death_on_boss_wave': case 'pet_and_shield':
            case 'no_shot_wave': case 'no_move_boss_wave': case 'no_damage_boss_wave':
            case 'barrier_boss_hit': case 'one_hp_clutch': case 'comeback_wave': case 'first_purchase':
                conditionMet = true; 
                break;
            case 'collect_rarity': 
                if(data.rarity === ach.subtype) conditionMet = true; 
                break;
            case 'stat_check': 
                if(data.subtype === ach.subtype && data.value >= ach.target) conditionMet = true; 
                break;
            case 'win_condition':
                if (gameManager.difficulty === ach.subtype) conditionMet = true; break;
            case 'wave_in_mode':
                if (gameManager.gameMode === ach.subtype && data.wave >= ach.target) conditionMet = true; break;
            case 'wave_in_difficulty':
                if (gameManager.difficulty === ach.subtype && data.wave >= ach.target) conditionMet = true; break;
            case 'win_with_card':
                if (player.upgrades[ach.subtype]) conditionMet = true; break;
            case 'win_no_deaths':
                 if (gameManager.difficulty === ach.subtype && gameManager.stats.deathsThisRun === 0) conditionMet = true; break;
            case 'win_condition_no_rarity':
                const hasBannedRarity = Object.keys(player.upgrades).some(cardKey => UPGRADES[cardKey]?.rarity === ach.subtype);
                if (!hasBannedRarity) conditionMet = true; break;
            case 'stat_milestone':
                if (ach.subtype === 'critChance' && data.value >= ach.target) conditionMet = true;
                if (ach.subtype === 'maxHp' && data.value >= ach.target) conditionMet = true;
                break;
            case 'card_combo':
                if (ach.subtypes.every(cardKey => player.upgrades[cardKey])) conditionMet = true; break;
            case 'convert_enemy_type':
                if (ach.subtype === data) conditionMet = true; break;
            case 'fast_boss_kill':
                if (data <= ach.target) conditionMet = true; break;
            case 'first_kill_difficulty':
                if (data.difficulty === ach.subtype && data.kills >= ach.target) conditionMet = true; break;
            case 'multi_kill_in_time':
                if (data >= ach.target) conditionMet = true; break;
            case 'stack_rarity':
                 const hasStackedCard = Object.keys(player.upgrades).some(cardKey => {
                    return UPGRADES[cardKey]?.rarity === ach.subtype && player.upgrades[cardKey] >= ach.target;
                });
                if(hasStackedCard) conditionMet = true; break;
            case 'all_rarities_in_run':
                const foundRarities = new Set(Object.keys(player.upgrades).map(k => UPGRADES[k]?.rarity));
                if (foundRarities.size >= 5) conditionMet = true; break;
            case 'survival_in_theme':
                 if (THEMES[ach.subtype] && data.theme === THEMES[ach.subtype].name && data.waves >= ach.target) conditionMet = true; break;
            case 'death_with_coins':
                if (data >= ach.target) conditionMet = true; break;
        }

        if (conditionMet) { 
            ach.unlocked = true; 
            unlockedAny = true; 
            gameManager.stats.coins += ach.reward;
            if (!suppressNotification) {
                showAchievementNotification(ach); 
            }
            if (ach.customizationReward) {
                const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                rewards.forEach(reward => {
                    const { type, id } = reward;
                    const listKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                    if (PLAYER_CUSTOMIZATION[listKey] && !PLAYER_CUSTOMIZATION[listKey].includes(id)) {
                        PLAYER_CUSTOMIZATION[listKey].push(id);
                    }
                });
            }
            if (!suppressNotification) updateMetaProgression();
        }
    });

    if (unlockedAny) {
        const allUnlocked = gameManager.achievements.filter(a => a.id !== 'ultimate').every(a => a.unlocked);
        const ultimateAchievement = gameManager.achievements.find(a => a.id === 'ultimate');
        if (allUnlocked && !ultimateAchievement.unlocked) { 
            ultimateAchievement.unlocked = true; 
            gameManager.stats.coins += ultimateAchievement.reward; 
            if (!suppressNotification) showAchievementNotification(ultimateAchievement); 
        }
        updateAchievementCounters();
        if (!suppressNotification) saveGameData();
    }
}
function checkMetaAchievements(isMassUnlock = false) {
    let unlockedAny = false;
    gameManager.achievements.forEach(ach => {
        if (ach.unlocked) return; let conditionMet = false;
        switch(ach.type) {
            case 'meta_spend': if(gameManager.stats.totalSpent >= ach.target) {
                conditionMet = true;
                if(ach.customizationReward) {
                    const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                    rewards.forEach(reward => {
                        const { type, id } = reward;
                        const ownedListKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                        if (PLAYER_CUSTOMIZATION[ownedListKey] && !PLAYER_CUSTOMIZATION[ownedListKey].includes(id)) {
                            PLAYER_CUSTOMIZATION[ownedListKey].push(id);
                        }
                    });
                }
            } break;
             case 'collect_all':
                let catalog, ownedList;
                if(ach.subtype === 'hats') { catalog = HATS_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedHats; }
                else if(ach.subtype === 'shapes') { catalog = SHAPES_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedShapes; }
                else if(ach.subtype === 'colors') { catalog = COLORS_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedColors; }
                else if(ach.subtype === 'faces') { catalog = FACES_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedFaces; }
                if(catalog && ownedList.length >= catalog.length) conditionMet = true;
                break;
            case 'max_perm_upgrade':
                const isMaxed = Object.values(PLAYER_PERMANENT_UPGRADES).some(level => level >= 10);
                if (isMaxed) conditionMet = true;
                break;
            case 'total_healing':
                if(gameManager.stats.totalHealing >= ach.target) conditionMet = true;
                break;
        }
        if (conditionMet) { 
            ach.unlocked = true; 
            unlockedAny = true; 
            if (!isMassUnlock) {
                gameManager.stats.coins += ach.reward;
                updateMetaProgression();
            }
            showAchievementNotification(ach); 
        }
    });
     if (unlockedAny) {
        updateAchievementCounters();
        if (!isMassUnlock) saveGameData();
     }
}
function showAchievementNotification(achievement) {
    const notification = document.createElement('div');
    notification.className = 'achievement-notification';
    let rewardText = `+${achievement.reward} moedas`;
    if (achievement.customizationReward) {
        rewardText += ` & item!`;
    }
    notification.innerHTML = `<div class="achievement-icon">ð</div><div class="achievement-text"><h4>${achievement.name}</h4><p>${achievement.description}</p><p><strong>Recompensa: ${rewardText}</strong></p></div><div class="achievement-badge">${achievement.rarity.toUpperCase()}</div>`;
    achievementNotificationContainer.appendChild(notification);
    if (VISUAL_SETTINGS.particleIntensity > 0) { const color = getColorByRarity(achievement.rarity); for (let i = 0; i < 50; i++) setTimeout(() => particles.push(new Particle(canvas.width/2, canvas.height/2, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, Math.random() * 5 + 2, color, 2000)), i * 30); }
    setTimeout(() => { notification.remove(); }, 4000);
}
function getColorByRarity(rarity) {
    switch(rarity) {
        case 'common': return '#ffffff'; case 'uncommon': return '#4caf50'; case 'rare': return '#2196f3';
        case 'epic': return '#9c27b0'; case 'legendary': return '#ff9800'; default: return '#ffffff';
    }
}
function populateAchievements() {
    achievementsList.innerHTML = '';
    const sortedAchievements = [...gameManager.achievements].sort((a,b) => b.unlocked - a.unlocked || a.name.localeCompare(b.name));
    sortedAchievements.forEach(achievement => {
        const card = document.createElement('div');
        card.className = `achievement-card ${achievement.unlocked ? 'unlocked' : ''} achievement-${achievement.rarity}`;
        let rewardHtml = '';
        if(achievement.reward > 0) rewardHtml += `ð° ${achievement.reward} Moedas`;
        if(achievement.customizationReward) {
            const cat = [...SHAPES_CATALOG, ...HATS_CATALOG, ...COLORS_CATALOG, ...FACES_CATALOG];
            const rewards = Array.isArray(achievement.customizationReward) ? achievement.customizationReward : [achievement.customizationReward];
            rewards.forEach(reward => {
                const item = cat.find(i => i.id === reward.id);
                if(item) { rewardHtml += (rewardHtml ? ' <br> ' : '') + `ð¨ Item: ${item.name}`; }
            });
        }

        const statusText = achievement.unlocked 
            ? `<p class="conquista-text" style="color: #ffcc00;">CONQUISTADA!</p>` 
            : '<p class="conquista-text" style="color: #f44336;">NÃ£o desbloqueada</p>';

        card.innerHTML = `<h3>${achievement.name}</h3>
                          <p>${achievement.description}</p>
                          <p><strong>Dificuldade: ${achievement.rarity.toUpperCase()}</strong></p>
                          ${statusText}
                          <div class="reward-info"><strong>Recompensa:</strong><br>${rewardHtml || 'Nenhuma'}</div>`;
        achievementsList.appendChild(card);
    });
}
function updateMetaProgression() {
    document.getElementById('main-menu-coins-value').textContent = gameManager.stats.coins;
    customizationCoinsDisplay.textContent = `Moedas: ${gameManager.stats.coins}`;
    permanentUpgradesCoinsDisplay.textContent = `Moedas: ${gameManager.stats.coins}`;
    updateAchievementCounters();
    populateBestRecordDisplay();
}
function updateAchievementCounters() {
    const unlockedCount = gameManager.achievements.filter(a => a.unlocked).length;
    const totalCount = gameManager.achievements.length;
    const counterText = `${unlockedCount}/${totalCount}`;
    document.getElementById('main-menu-achievement-counter').textContent = counterText;
    document.getElementById('pause-menu-achievement-counter').textContent = counterText;
}

// ===================================================================================
// 6. LOOP PRINCIPAL DO JOGO E PREVIEW DO MENU
// ===================================================================================
function update(deltaTime) {
    if (gameManager.gameOver || gameManager.victory || !player) return;

    if (!gameManager.paused) {
        if (gameManager.runFlags.multiKillTimer > 0) {
            gameManager.runFlags.multiKillTimer -= deltaTime;
            if (gameManager.runFlags.multiKillTimer <= 0) {
                gameManager.runFlags.multiKillCounter = 0;
            }
        }

        if (gameManager.timeWarp.active) {
            gameManager.timeWarp.timer -= deltaTime;
            if(gameManager.timeWarp.timer <= 0) gameManager.timeWarp.active = false;
        }
        const effectiveDeltaTime = gameManager.timeWarp.active ? deltaTime * 0.5 : deltaTime;

        gameManager.gameTime += deltaTime; checkAchievement('survival_time', gameManager.gameTime);
        for (let i = bloodSplatters.length - 1; i >= 0; i--) { bloodSplatters[i].time -= deltaTime; if (bloodSplatters[i].time <= 0) { bloodSplatters[i].element.remove(); bloodSplatters.splice(i, 1); } }
        
        [enemies, projectiles, particles, expOrbs, floatingTexts, blackHoles, orbitalShields, coins, mirageClones, gravityWells, damageZones].forEach(arr => arr.forEach(e => { if (e.update) e.update(effectiveDeltaTime, player); }));
        
        handleCollisions(); waveManager(effectiveDeltaTime);
        updateThemeTransition(deltaTime);

        enemies = enemies.filter(e => e.active); projectiles = projectiles.filter(p => p.active);
        particles = particles.filter(p => p.active); expOrbs = expOrbs.filter(p => p.active);
        floatingTexts = floatingTexts.filter(t => t.active); blackHoles = blackHoles.filter(b => b.active);
        orbitalShields = orbitalShields.filter(s => s.active); coins = coins.filter(c => c.active); 
        mirageClones = mirageClones.filter(c => c.active); gravityWells = gravityWells.filter(w => w.active);
        damageZones = damageZones.filter(d => d.active);
        
        if (screenShake.duration > 0) screenShake.duration -= deltaTime;
    }

    player.update(deltaTime);
}
function draw() {
    ctx.save();
    if (screenShake.duration > 0) { const shakeIntensity = screenShake.magnitude * (screenShake.duration / 200); ctx.translate((Math.random()-0.5) * shakeIntensity, (Math.random()-0.5) * shakeIntensity); }
    
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, frameColors.bg[0]);
    bgGradient.addColorStop(1, frameColors.bg[1]);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGround(); platforms.forEach(p => p.draw(ctx));
    [particles, expOrbs, projectiles, mirageClones, gravityWells, enemies, blackHoles, coins, orbitalShields, damageZones].forEach(arr => arr.forEach(e => e.draw(ctx)));
    if (player) {
        player.draw(ctx);
        drawPlayerNametag(ctx, player);
    }
    drawAimingLine(); 
    floatingTexts.forEach(t => t.draw(ctx)); 

    if (gameManager.timeWarp.active) {
        ctx.fillStyle = "rgba(100, 100, 255, 0.2)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    drawUI();
    if (gameManager.controlScheme === 'mobile' && movementJoystick) { movementJoystick.draw(ctx); shootingJoystick.draw(ctx); }
    ctx.restore();
}
function drawAimingLine() {
    if (!gameManager.running || gameManager.paused || !player) return;
    
    let targetX, targetY;
    if (gameManager.controlScheme === 'desktop') {
        targetX = mouse.x;
        targetY = mouse.y;
    } else if (shootingJoystick && shootingJoystick.active) {
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;
        targetX = playerCenterX + Math.cos(shootingJoystick.angle) * 1000;
        targetY = playerCenterY + Math.sin(shootingJoystick.angle) * 1000;
    } else {
        return;
    }

    ctx.save();
    ctx.beginPath();
    ctx.setLineDash([5, 15]);
    ctx.moveTo(player.x + player.width / 2, player.y + player.height / 2);
    ctx.lineTo(targetX, targetY);
    ctx.strokeStyle = 'rgba(156, 39, 176, 0.4)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}
function drawGround() {
    if (!groundPath) return;
    ctx.fillStyle = frameColors.ground; ctx.strokeStyle = frameColors.ground_top; 
    ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(groundPath[0].x, groundPath[0].y);
    for (let i = 1; i < groundPath.length; i++) ctx.lineTo(groundPath[i].x, groundPath[i].y);
    ctx.stroke(); ctx.lineTo(CONFIG.WIDTH, CONFIG.HEIGHT); ctx.lineTo(0, CONFIG.HEIGHT); ctx.closePath(); ctx.fill();
}
function drawUI() {
    if (!player) return;
    const m = Math.floor(gameManager.gameTime / 60000), s = Math.floor((gameManager.gameTime % 60000) / 1000);
    gameTimerDisplay.textContent = `Tempo: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

    const barWidth = 250, barHeight = 18;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(10, 10, barWidth, barHeight);
    ctx.fillStyle = 'rgba(244, 67, 54, 0.8)'; ctx.fillRect(10, 10, barWidth * (player.hp / player.stats.maxHp), barHeight);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(10, 35, barWidth, barHeight);
    ctx.fillStyle = 'rgba(33, 150, 243, 0.8)'; ctx.fillRect(10, 35, barWidth * (player.exp / player.expToNextLevel), barHeight);
    ctx.fillStyle = '#f0f0f0'; ctx.font = "14px 'Segoe UI'"; ctx.textAlign = 'left';
    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
    ctx.fillText(`HP: ${player.hp.toFixed(0)}/${player.stats.maxHp.toFixed(0)}`, 15, 25);
    ctx.fillText(`LV: ${player.level} (${((player.exp / player.expToNextLevel)*100).toFixed(0)}%)`, 15, 50);
    ctx.fillText(`Moedas (SessÃ£o): ${gameManager.coinsInRun}`, 15, 75); 
    ctx.shadowBlur = 0;
    if (gameManager.cheats.immortality || gameManager.cheats.autoFire || gameManager.cheats.freezeEnemies) {
        ctx.fillStyle = '#ff5555'; ctx.font = "bold 16px 'Segoe UI'"; ctx.textAlign = 'right';
        ctx.fillText('CHEATS ATIVADOS', CONFIG.WIDTH - 20, 50);
    }
}
function drawPlayerNametag(ctx, p) {
    const x = p.x + p.width / 2;
    const y = p.y - 15;
    ctx.font = "bold 14px 'Segoe UI'";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    if (VISUAL_SETTINGS.nametagStyle === 'background') {
        const textWidth = ctx.measureText(PLAYER_CUSTOMIZATION.nickname).width;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(x - textWidth / 2 - 5, y - 18, textWidth + 10, 20);
    }
    
    ctx.fillStyle = '#fff';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 4;
    ctx.fillText(PLAYER_CUSTOMIZATION.nickname, x, y);
    ctx.shadowBlur = 0;
}
function updateIngameCardsUI() {
    if(!player || !gameManager.running) { ingameCardsUI.innerHTML = ''; return; }
    let html = '';
    for(const key in player.upgrades) {
        const upgrade = UPGRADES[key]; const count = player.upgrades[key];
        if (upgrade && count > 0) { html += `<div class="ingame-card-item">${upgrade.name} <span class="count">x${count}</span></div>`; }
    }
    ingameCardsUI.innerHTML = html;
}
function updateIngameInfoDisplay() {
    if (!gameManager.running) { ingameInfoDisplay.style.display = 'none'; return; }
    const charName = gameManager.stats.character.charAt(0).toUpperCase() + gameManager.stats.character.slice(1);
    const diffName = gameManager.difficulty.charAt(0).toUpperCase() + gameManager.difficulty.slice(1);
    const modeName = gameManager.gameMode === 'waves' ? '100 Ondas' : 'Infinito';
    const deviceName = gameManager.chosenDevice === 'desktop' ? 'PC' : 'Mobile';
    
    const charText = `${charName}${gameManager.isCharacterRandom ? ' (ð²)' : ''}`;
    const diffText = `${diffName}${gameManager.isDifficultyRandom ? ' (ð²)' : ''}`;
    const modeText = `${modeName}${gameManager.isGameModeRandom ? ' (ð²)' : ''}`;

    ingameInfoDisplay.innerHTML = 
        `HerÃ³i: <span>${charText}</span> | ` +
        `Dificuldade: <span>${diffText}</span> | ` +
        `Modo: <span>${modeText}</span> | ` +
        `Disp: <span>${deviceName}</span>`;
    ingameInfoDisplay.style.display = 'block';
}
function gameLoop(timestamp) {
    if (!gameManager.running) { gameLoopId = null; return; }
    
    const deltaTime = timestamp - lastTime; lastTime = timestamp;
    update(deltaTime > 100 ? 100 : deltaTime); draw();
    if (gameManager.victory) { showVictoryScreen(); return; }
    if (gameManager.gameOver) { showGameOverScreen(); return; }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}

function drawCharacterPreview(timestamp) {
    if (!previewCtx) return;
    const w = characterPreviewCanvas.width;
    const h = characterPreviewCanvas.height;
    
    previewCtx.clearRect(0, 0, w, h);
    renderCharacter(previewCtx, w / 2 - 40, h / 2 - 50, 80, 100, 1, player?.vfx?.isGlass);
}

function animatePreview(timestamp) {
    if (mainMenuModal.style.display !== 'flex') {
        previewAnimationId = null;
        return;
    }
    drawCharacterPreview(timestamp);
    previewAnimationId = requestAnimationFrame(animatePreview);
}

// ===================================================================================
// 7. CHEAT MENU, SONS E EVENT LISTENERS
// ===================================================================================
function applyCheats() {
    gameManager.cheats.immortality = document.getElementById('immortality-cheat').checked;
    gameManager.cheats.autoFire = document.getElementById('auto-fire-cheat').checked;
    gameManager.cheats.freezeEnemies = document.getElementById('freeze-enemies').checked;
    gameManager.cheats.instantExp = document.getElementById('instant-exp').checked;
    gameManager.cheats.infiniteJumps = document.getElementById('infinite-jumps').checked;
    gameManager.cheats.playerSpeed = parseFloat(document.getElementById('player-speed').value) || 7;
    gameManager.cheats.playerDamage = parseFloat(document.getElementById('player-damage').value) || 5;
    gameManager.cheats.enemyDamage = parseFloat(document.getElementById('enemy-damage').value) || 10;
    
    const maxStacksValue = parseInt(document.getElementById('max-stacks').value, 10);
    Object.keys(UPGRADES).forEach(key => { UPGRADES[key].maxStacks = maxStacksValue; });

    if (player) { player.initStats(); }
    
    const targetWave = parseInt(document.getElementById('set-wave').value, 10);
    if (targetWave && targetWave > gameManager.wave) { jumpToWave(targetWave); }

    cheatMenu.style.display = 'none';
}

function resetCheats() {
    document.getElementById('immortality-cheat').checked = false; document.getElementById('auto-fire-cheat').checked = false;
    document.getElementById('player-speed').value = 7; document.getElementById('player-damage').value = 5;
    document.getElementById('freeze-enemies').checked = false; document.getElementById('enemy-damage').value = 10;
    document.getElementById('instant-exp').checked = false; document.getElementById('infinite-jumps').checked = false;
    document.getElementById('set-wave').value = gameManager.wave;
    document.getElementById('max-stacks').value = 50;

    gameManager.cheats = { immortality: false, autoFire: false, playerSpeed: 7, playerDamage: 5, freezeEnemies: false, enemyDamage: 10, instantExp: false, infiniteJumps: false };
    
    Object.keys(UPGRADES).forEach(key => { UPGRADES[key].maxStacks = ORIGINAL_UPGRADES[key].maxStacks; });

    if (player) { player.initStats(); }
    cheatMenu.style.display = 'none';
}

function jumpToWave(wave) {
    if (!gameManager.running || !player) return;
    gameManager.wave = Math.max(0, wave - 1);
    enemies = [];
    projectiles = [];
    gameManager.waveTimer = 100;
    waveIndicator.textContent = `Pulando para a Onda ${wave}...`;
}

function populateCheatCards() {
    cheatCardsList.innerHTML = '';
    Object.keys(UPGRADES).forEach(key => {
        const upgrade = UPGRADES[key]; const card = document.createElement('div');
        card.className = `cheat-card card-rarity-${upgrade.rarity}`; card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
        card.addEventListener('click', () => { if (player) { player.addUpgrade(key); floatingTexts.push(new FloatingText(`${upgrade.name} ATIVADA!`, canvas.width/2, canvas.height/2, 'gold', 30)); } });
        cheatCardsList.appendChild(card);
    });
}
class JoystickController {
    constructor(x, y, baseRadius, handleRadius, color) {
        this.x = x; this.y = y; this.baseRadius = baseRadius; this.handleRadius = handleRadius;
        this.color = color; this.active = false; this.touchId = null;
        this.handleX = this.x; this.handleY = this.y;
        this.angle = 0; this.strength = 0; this.deltaX = 0; this.deltaY = 0;
    }
    handleTouchStart(touch) {
        const rect = canvas.getBoundingClientRect(); const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
        const dx = x - this.x, dy = y - this.y;
        if (Math.sqrt(dx * dx + dy * dy) < this.baseRadius * 1.5) { this.active = true; this.touchId = touch.identifier; this.updateHandle(x, y); }
    }
    handleTouchMove(touch) { if (this.touchId === touch.identifier) { const rect = canvas.getBoundingClientRect(); this.updateHandle(touch.clientX - rect.left, touch.clientY - rect.top); } }
    handleTouchEnd(touch) { if (this.touchId === touch.identifier) { this.active = false; this.touchId = null; this.handleX = this.x; this.handleY = this.y; this.strength = 0; this.deltaX = 0; this.deltaY = 0; } }
    updateHandle(clientX, clientY) {
        const dx = clientX - this.x, dy = clientY - this.y, dist = Math.sqrt(dx * dx + dy * dy);
        this.angle = Math.atan2(dy, dx); this.strength = Math.min(dist / this.baseRadius, 1);
        this.deltaX = Math.cos(this.angle) * this.strength; this.deltaY = Math.sin(this.angle) * this.strength;
        if (dist > this.baseRadius) { this.handleX = this.x + Math.cos(this.angle) * this.baseRadius; this.handleY = this.y + Math.sin(this.angle) * this.baseRadius; } 
        else { this.handleX = clientX; this.handleY = clientY; }
    }
    draw(ctx) {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.baseRadius, 0, Math.PI * 2); ctx.fillStyle = `rgba(${this.color}, 0.2)`; ctx.fill();
        if (this.active) { ctx.beginPath(); ctx.arc(this.x, this.y, this.baseRadius * 1.1, 0, Math.PI * 2); ctx.strokeStyle = `rgba(${this.color}, 0.5)`; ctx.lineWidth = 3;
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(this.handleX, this.handleY, this.handleRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.color}, ${this.active ? 0.8 : 0.5})`;
        ctx.fill();
        ctx.lineWidth = 1;
    }
}

// ===================================================================================
// 8. CONTROLE DE MENUS E EVENTOS PRINCIPAIS
// ===================================================================================
const playButton = document.getElementById('play-button');
const deviceSelectionModal = document.getElementById('device-selection-modal');
const desktopButton = document.getElementById('desktop-button');
const mobileButton = document.getElementById('mobile-button');
const deviceConfirmationModal = document.getElementById('device-confirmation-modal');
const confirmDeviceYes = document.getElementById('confirm-device-yes');
const confirmDeviceNo = document.getElementById('confirm-device-no');
const pauseButton = document.getElementById('pauseButton');
const pauseModal = document.getElementById('pause-modal');
const resumeGameButton = document.getElementById('resume-game-button');
const pauseRestartButton = document.getElementById('pause-restart-button');
const returnToMenuButton = document.getElementById('return-to-menu-button');
const characterSelectionModal = document.getElementById('character-selection-modal');
const characterCards = document.getElementById('character-selection-cards');
const confirmCharacterButton = document.getElementById('confirm-character');

let tempDeviceChoice = null; let selectedCharacter = null; 
let selectedDifficulty = null; let selectedGameMode = null;

function showMainMenu() {
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
    gameManager.running = false; gameManager.paused = false; gameManager.victory = false;
    ingameCardsUI.style.display = 'none';
    ingameInfoDisplay.style.display = 'none';
    gameTimerDisplay.style.display = 'none';
    cheatMenuButton.style.display = 'none';
    settingsButton.style.display = 'none';
    document.querySelectorAll('.ui-modal').forEach(modal => modal.style.display = 'none');
    canvas.style.display = 'none'; pauseButton.style.display = 'none';
    mainMenuModal.style.display = 'flex'; 
    mainMenuNickname.textContent = PLAYER_CUSTOMIZATION.nickname;
    updateMetaProgression();
    
    if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
    animatePreview();
}

function stopMainMenuAnimations() {
    if (previewAnimationId) {
        cancelAnimationFrame(previewAnimationId);
        previewAnimationId = null;
    }
}

confirmNicknameButton.addEventListener('click', () => {
    const nick = nicknameInput.value.trim();
    if (nick.length >= 3 && nick.length <= 12) {
        PLAYER_CUSTOMIZATION.nickname = nick; nicknameError.textContent = ''; saveGameData(); showMainMenu();
    } else { nicknameError.textContent = 'O nickname deve ter entre 3 e 12 caracteres.'; }
});

nicknameInput.addEventListener('input', () => { const nick = nicknameInput.value.trim(); confirmNicknameButton.disabled = !(nick.length >= 3 && nick.length <= 12); });

playButton.addEventListener('click', () => { 
    stopMainMenuAnimations();
    mainMenuModal.style.display = 'none'; 
    characterSelectionModal.style.display = 'flex';
    const defaultCard = characterCards.querySelector('.character-card[data-character="archer"]');
    if (defaultCard) {
        characterCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedCharacter = defaultCard.dataset.character;
        gameManager.isCharacterRandom = false;
        confirmCharacterButton.disabled = false;
    } else {
        confirmCharacterButton.disabled = true;
    }
});

characterCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if (!card) return;
    characterCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected')); 
    card.classList.add('selected'); 
    selectedCharacter = card.dataset.character; 
    gameManager.isCharacterRandom = (selectedCharacter === 'random');
    confirmCharacterButton.disabled = false;
});

confirmCharacterButton.addEventListener('click', () => {
    if(!selectedCharacter) return;
    gameManager.stats.character = selectedCharacter;
    characterSelectionModal.style.display = 'none';
    difficultyModal.style.display = 'flex';
    const defaultCard = difficultySelectionCards.querySelector('.character-card[data-difficulty="normal"]');
    if (defaultCard) {
        difficultySelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedDifficulty = defaultCard.dataset.difficulty;
        gameManager.isDifficultyRandom = false;
        confirmDifficultyButton.disabled = false;
    } else {
        confirmDifficultyButton.disabled = true;
    }
});

difficultySelectionCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if(!card) return;
    difficultySelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedDifficulty = card.dataset.difficulty;
    gameManager.isDifficultyRandom = (selectedDifficulty === 'random');
    confirmDifficultyButton.disabled = false;
});

confirmDifficultyButton.addEventListener('click', () => {
    if(!selectedDifficulty) return;
    gameManager.difficulty = selectedDifficulty;
    difficultyModal.style.display = 'none';
    gamemodeModal.style.display = 'flex';
    const defaultCard = gamemodeSelectionCards.querySelector('.character-card[data-gamemode="waves"]');
    if (defaultCard) {
        gamemodeSelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedGameMode = defaultCard.dataset.gamemode;
        gameManager.isGameModeRandom = false;
        confirmGamemodeButton.disabled = false;
    } else {
        confirmGamemodeButton.disabled = true;
    }
});

gamemodeSelectionCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if(!card) return;
    gamemodeSelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedGameMode = card.dataset.gamemode;
    gameManager.isGameModeRandom = (selectedGameMode === 'random');
    confirmGamemodeButton.disabled = false;
});

confirmGamemodeButton.addEventListener('click', () => {
    if (!selectedGameMode) return;
    gameManager.gameMode = selectedGameMode;
    gamemodeModal.style.display = 'none';
    if (gameManager.chosenDevice) {
        startGame();
    } else {
        deviceSelectionModal.style.display = 'flex';
    }
});

backFromDifficultyButton.addEventListener('click', () => {
    difficultyModal.style.display = 'none';
    characterSelectionModal.style.display = 'flex';
});

backFromGamemodeButton.addEventListener('click', () => {
    gamemodeModal.style.display = 'none';
    difficultyModal.style.display = 'flex';
});


function selectDevice(device) { tempDeviceChoice = device; deviceSelectionModal.style.display = 'none'; deviceConfirmationModal.style.display = 'flex'; }
desktopButton.addEventListener('click', () => selectDevice('desktop')); mobileButton.addEventListener('click', () => selectDevice('mobile'));
confirmDeviceYes.addEventListener('click', () => { 
    deviceConfirmationModal.style.display = 'none'; 
    gameManager.chosenDevice = tempDeviceChoice; 
    gameManager.controlScheme = tempDeviceChoice;
    startGame(); 
});
confirmDeviceNo.addEventListener('click', () => { deviceConfirmationModal.style.display = 'none'; deviceSelectionModal.style.display = 'flex'; });
returnToMenuFromGameOverButton.addEventListener('click', () => { showMainMenu(); });
returnToMenuFromVictoryButton.addEventListener('click', () => { showMainMenu(); });
pauseButton.addEventListener('click', () => { if (!gameManager.running || gameManager.gameOver) return; gameManager.paused = true; pauseModal.style.display = 'flex'; ingameCardsUI.style.display = 'none'; });
resumeGameButton.addEventListener('click', () => { gameManager.paused = false; pauseModal.style.display = 'none'; ingameCardsUI.style.display = 'block'; });

pauseRestartButton.addEventListener('click', () => {
    pauseModal.style.display = 'none';
    restartConfirmationModal.style.display = 'flex';
});
confirmRestartYes.addEventListener('click', () => {
    saveCurrentRunAsRecord();
    restartConfirmationModal.style.display = 'none';
    startGame(true); 
});
confirmRestartNo.addEventListener('click', () => {
    restartConfirmationModal.style.display = 'none';
    pauseModal.style.display = 'flex';
});

returnToMenuButton.addEventListener('click', () => {
    pauseModal.style.display = 'none';
    returnToMenuConfirmationModal.style.display = 'flex';
});
confirmReturnToMenuYes.addEventListener('click', () => {
    saveCurrentRunAsRecord();
    returnToMenuConfirmationModal.style.display = 'none';
    showMainMenu();
});
confirmReturnToMenuNo.addEventListener('click', () => {
    returnToMenuConfirmationModal.style.display = 'none';
    pauseModal.style.display = 'flex';
});

backFromCharacterButton.addEventListener('click', () => { characterSelectionModal.style.display = 'none'; showMainMenu(); });
backFromDeviceButton.addEventListener('click', () => { deviceSelectionModal.style.display = 'none'; gamemodeModal.style.display = 'flex'; });


window.addEventListener('keydown', e => { if(gameManager.controlScheme === 'desktop' && player) { keys[e.key.toLowerCase()] = true; if (e.key === ' ') { e.preventDefault(); if(!gameManager.paused) player.jump(); } } });
window.addEventListener('keyup', e => { if(gameManager.controlScheme === 'desktop') keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e => { if(gameManager.controlScheme === 'desktop' && !gameManager.paused) { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; } });
canvas.addEventListener('mousedown', () => { if(gameManager.controlScheme === 'desktop' && !gameManager.paused) mouse.down = true; });
canvas.addEventListener('mouseup', () => { if(gameManager.controlScheme === 'desktop') mouse.down = false; });
canvas.addEventListener('touchstart', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile' && !gameManager.paused) { for (const touch of e.changedTouches) { movementJoystick?.handleTouchStart(touch); shootingJoystick?.handleTouchStart(touch); } } }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile' && !gameManager.paused) { for (const touch of e.changedTouches) { movementJoystick?.handleTouchMove(touch); shootingJoystick?.handleTouchMove(touch); } } }, { passive: false });
canvas.addEventListener('touchend', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile') { for (const touch of e.changedTouches) { movementJoystick?.handleTouchEnd(touch); shootingJoystick?.handleTouchEnd(touch); } } });

cheatMenuButton.addEventListener('click', () => { cheatMenu.style.display = cheatMenu.style.display === 'block' ? 'none' : 'block'; if (cheatMenu.style.display === 'block') populateCheatCards(); });
cheatCloseButton.addEventListener('click', () => { cheatMenu.style.display = 'none'; });
applyCheatsButton.addEventListener('click', applyCheats); resetCheatsButton.addEventListener('click', resetCheats);
addAllCardsButton.addEventListener('click', () => { if (!player) return; Object.keys(UPGRADES).forEach(key => player.addUpgrade(key)); floatingTexts.push(new FloatingText('TODAS AS CARTAS ATIVADAS!', canvas.width/2, canvas.height/2, 'gold', 30)); });

function openModal(modal, fromScreen) {
    previousScreen = fromScreen;
    if (fromScreen === 'mainMenu') { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; }
    if (fromScreen === 'pause') pauseModal.style.display = 'none';
    modal.style.display = 'flex';
    if(modal === badgesModal) populateAchievements();
    if(modal === infoModal) setInfoTab('info-cards');
    if(modal === recordsModal) populateRecordsTable();
}

function closeModal(modal, toScreen) {
    modal.style.display = 'none';
    if(toScreen === 'mainMenu' || previousScreen === 'mainMenu') showMainMenu();
    else if(toScreen === 'pause' || previousScreen === 'pause') pauseModal.style.display = 'flex';
}

showBadgesMainButton.addEventListener('click', () => openModal(badgesModal, 'mainMenu'));
showBadgesPauseButton.addEventListener('click', () => openModal(badgesModal, 'pause'));
badgesCloseButton.addEventListener('click', () => closeModal(badgesModal));
closeBadgesButton.addEventListener('click', () => closeModal(badgesModal));

changelogButton.addEventListener('click', () => openModal(changelogModal, 'mainMenu'));
changelogCloseButton.addEventListener('click', () => closeModal(changelogModal, 'mainMenu'));

showSettingsButton.addEventListener('click', () => {
    updateSettingsUI();
    openModal(settingsModal, 'mainMenu');
});

settingsCloseButton.addEventListener('click', () => closeModal(settingsModal, 'mainMenu'));

applySettingsButton.addEventListener('click', () => {
    VISUAL_SETTINGS.shadows = document.getElementById('shadows-setting').checked;
    VISUAL_SETTINGS.blood = document.getElementById('blood-setting').checked; 
    VISUAL_SETTINGS.screenShakeIntensity = parseInt(document.getElementById('screenshake-intensity').value);
    VISUAL_SETTINGS.particleIntensity = parseInt(document.getElementById('particle-intensity').value);
    VISUAL_SETTINGS.trailIntensity = parseInt(document.getElementById('trail-intensity').value);
    VISUAL_SETTINGS.cardEffectIntensity = parseInt(document.getElementById('card-effect-intensity').value);
    VISUAL_SETTINGS.nametagStyle = document.getElementById('nametag-style').value; 
    
    const setCoinsValue = parseInt(document.getElementById('set-coins-input').value, 10);
    if(VISUAL_SETTINGS.cheatFeaturesEnabled && !isNaN(setCoinsValue)) {
        gameManager.stats.coins = setCoinsValue;
        updateMetaProgression();
    }
    
    saveGameData();
    closeModal(settingsModal, 'mainMenu');
});

document.getElementById('unlock-all-achievements-btn').addEventListener('click', () => {
    let totalCoinsGained = 0;
    let itemsGained = 0;
    
    gameManager.achievements.forEach(ach => {
        if (!ach.unlocked) {
            ach.unlocked = true; 
            totalCoinsGained += ach.reward; 
            if (ach.customizationReward) {
                const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                rewards.forEach(reward => {
                    itemsGained++;
                    const { type, id } = reward;
                    const listKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                    if (PLAYER_CUSTOMIZATION[listKey] && !PLAYER_CUSTOMIZATION[listKey].includes(id)) {
                        PLAYER_CUSTOMIZATION[listKey].push(id);
                    }
                });
            }
        }
    });
    
    gameManager.stats.coins += totalCoinsGained;
    
    updateMetaProgression();
    populateAchievements();
    updateAchievementCounters();
    saveGameData();
    alert(`Todas as conquistas foram desbloqueadas! VocÃª ganhou ${totalCoinsGained} moedas e ${itemsGained} itens cosmÃ©ticos.`);
});


document.getElementById('max-all-upgrades-btn').addEventListener('click', () => {
    Object.keys(PERMANENT_UPGRADES_CATALOG).forEach(key => {
        PLAYER_PERMANENT_UPGRADES[key] = PERMANENT_UPGRADES_CATALOG[key].maxLevel;
    });
    alert('Todas as melhorias permanentes maximizadas!');
    saveGameData();
});

cheatFeaturesSettingCheckbox.addEventListener('click', (e) => {
    e.preventDefault();
    if (!VISUAL_SETTINGS.cheatFeaturesEnabled) {
        cheatFeaturesConfirmationModal.style.display = 'flex';
    } else {
        VISUAL_SETTINGS.cheatFeaturesEnabled = false;
        cheatFeaturesSettingCheckbox.checked = false;
        cheatSettingsContainer.style.display = 'none';
    }
});

confirmCheatFeaturesYes.addEventListener('click', () => {
    VISUAL_SETTINGS.cheatFeaturesEnabled = true;
    cheatFeaturesSettingCheckbox.checked = true;
    cheatSettingsContainer.style.display = 'block';
    cheatFeaturesConfirmationModal.style.display = 'none';
});

confirmCheatFeaturesNo.addEventListener('click', () => {
    VISUAL_SETTINGS.cheatFeaturesEnabled = false;
    cheatFeaturesSettingCheckbox.checked = false;
    cheatFeaturesConfirmationModal.style.display = 'none';
});

tutorialButton.addEventListener('click', () => openModal(tutorialModal, 'mainMenu'));
closeTutorialButton.addEventListener('click', () => {
    tutorialModal.style.display = 'none'; 
    showMainMenu(); 
});

rollUpgradesButton.addEventListener('click', () => {
    if (gameManager.stats.coins >= 50) {
        gameManager.stats.coins -= 50;
        gameManager.stats.rerollsThisRun++;
        checkAchievement('rerolls_in_run', gameManager.stats.rerollsThisRun);
        updateMetaProgression();
        saveGameData();
        showUpgradeScreen();
    }
});
randomUpgradeButton.addEventListener('click', () => {
    const choices = document.querySelectorAll('#upgrade-choices .upgrade-card');
    if (choices.length > 0) {
        const randomChoice = choices[Math.floor(Math.random() * choices.length)];
        randomChoice.click();
    }
});
skipUpgradeButton.addEventListener('click', () => {
    if (player) {
        player.exp = 0;
    }
    upgradeModal.style.display = 'none';
    gameManager.paused = false;
});


// ===================================================================================
// 9. CUSTOMIZATION & UPGRADES LOGIC
// ===================================================================================
customizeCharacterButton.addEventListener('click', () => { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; customizationModal.style.display = 'flex'; openCustomizationScreen(); });
backToMainMenuFromCustomizationButton.addEventListener('click', () => { customizationModal.style.display = 'none'; showMainMenu(); });
permanentUpgradesButton.addEventListener('click', () => { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; permanentUpgradesModal.style.display = 'flex'; openPermanentUpgradesScreen(); });
backToMainMenuFromUpgradesButton.addEventListener('click', () => { permanentUpgradesModal.style.display = 'none'; showMainMenu(); });

function openCustomizationScreen() {
    updateMetaProgression(); 
    setActiveTab('shapes'); 
}

function setActiveTab(tabName) {
    document.querySelectorAll('#customization-modal .customization-options-grid').forEach(el => el.style.display = 'none');
    document.querySelectorAll('#customization-modal .customization-tabs button').forEach(el => el.classList.remove('active'));
    let container, type;
    if (tabName === 'shapes') { container = shapesOptionsContainer; type = 'shapes'; shapesTabButton.classList.add('active'); }
    else if (tabName === 'hats') { container = hatsOptionsContainer; type = 'hats'; hatsTabButton.classList.add('active'); }
    else if (tabName === 'colors') { container = colorsOptionsContainer; type = 'colors'; colorsTabButton.classList.add('active'); }
    else if (tabName === 'faces') { container = facesOptionsContainer; type = 'faces'; facesTabButton.classList.add('active');}
    else return;
    container.style.display = 'grid';
    renderCustomizationOptions(type, container);
}

shapesTabButton.addEventListener('click', () => setActiveTab('shapes'));
hatsTabButton.addEventListener('click', () => setActiveTab('hats'));
colorsTabButton.addEventListener('click', () => setActiveTab('colors'));
facesTabButton.addEventListener('click', () => setActiveTab('faces'));

function renderCustomizationOptions(type, container) {
    let catalog, ownedListKey, equippedKey;
    if (type === 'shapes') { catalog = SHAPES_CATALOG; ownedListKey = 'ownedShapes'; equippedKey = 'equippedShape'; }
    else if (type === 'hats') { catalog = HATS_CATALOG; ownedListKey = 'ownedHats'; equippedKey = 'equippedHat'; }
    else if (type === 'colors') { catalog = COLORS_CATALOG; ownedListKey = 'ownedColors'; equippedKey = 'equippedColor'; }
    else if (type === 'faces') { catalog = FACES_CATALOG; ownedListKey = 'ownedFaces'; equippedKey = 'equippedFace'; }
    else return;
    container.innerHTML = '';
    catalog.forEach(item => {
        const isOwned = PLAYER_CUSTOMIZATION[ownedListKey].includes(item.id); const isEquipped = PLAYER_CUSTOMIZATION[equippedKey] === item.id;
        const isLockedByAchievement = item.unlockAchievement && !isOwned;

        const itemDiv = document.createElement('div');
        itemDiv.className = 'customization-item';
        if (isEquipped) itemDiv.classList.add('equipped'); 
        if (!isOwned) itemDiv.classList.add('locked');

        const previewDiv = document.createElement('div'); previewDiv.className = 'item-preview';
        if (type === 'hats') { previewDiv.classList.add('item-preview-emoji'); previewDiv.textContent = item.emoji; } 
        else {
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50; const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, 50, 50);
            if (type === 'shapes') item.asset(tempCtx, 5, 5, 40, 40, '#cccccc');
            else if (type === 'colors') { 
                if (Array.isArray(item.value)) {
                    const gradient = tempCtx.createLinearGradient(0, 0, 50, 50);
                    gradient.addColorStop(0, item.value[0]); gradient.addColorStop(1, item.value[1]);
                    tempCtx.fillStyle = gradient;
                } else {
                    tempCtx.fillStyle = item.value;
                }
                tempCtx.fillRect(5, 5, 40, 40); 
            }
            else if (type === 'faces') { const faceLines = item.text.split('|'); const fontSize = item.text === '0_0' ? 20 : (faceLines.length > 1 ? 16 : 24); tempCtx.fillStyle = '#000000'; tempCtx.textAlign = 'center'; tempCtx.textBaseline = 'middle'; tempCtx.font = `bold ${fontSize}px Courier New`; faceLines.forEach((line, index) => tempCtx.fillText(line, 25, 25 - (faceLines.length - 1) * fontSize * 0.4 + index * fontSize * 0.8)); }
            previewDiv.appendChild(tempCanvas);
        }
        const nameDiv = document.createElement('div'); nameDiv.className = 'item-name'; nameDiv.textContent = item.name;
        const buttonContainer = document.createElement('div'); buttonContainer.className = 'item-button-container';
        if (isLockedByAchievement) {
            const achievement = gameManager.achievements.find(a => a.id === item.unlockAchievement);
            buttonContainer.innerHTML = `<button class="item-button achievement-lock-button" title="${achievement?.description || ''}">ð Conquista</button>`;
        } else if (isEquipped) {
            if (type === 'hats' && item.id !== 'hat_none') { buttonContainer.innerHTML = `<button class="item-button unequip-button">Desequipar</button>`; buttonContainer.querySelector('.unequip-button').onclick = () => handleCustomizationItemClick(item, type, 'unequip'); } 
            else { buttonContainer.innerHTML = `<button class="item-button equipped-button" disabled>Equipado</button>`; }
        } else if (isOwned) { buttonContainer.innerHTML = `<button class="item-button equip-button">Equipar</button>`; buttonContainer.querySelector('.equip-button').onclick = () => handleCustomizationItemClick(item, type, 'equip'); } 
        else { buttonContainer.innerHTML = `<button class="item-button buy-button">Comprar ð°${item.price}</button>`; buttonContainer.querySelector('.buy-button').onclick = () => handleCustomizationItemClick(item, type, 'buy'); }
        itemDiv.appendChild(previewDiv); itemDiv.appendChild(nameDiv); itemDiv.appendChild(buttonContainer); container.appendChild(itemDiv);
    });
}

function handleCustomizationItemClick(item, type, action) {
    let ownedListKey, equippedKey;
    if (type === 'shapes') { ownedListKey = 'ownedShapes'; equippedKey = 'equippedShape'; }
    else if (type === 'hats') { ownedListKey = 'ownedHats'; equippedKey = 'equippedHat'; }
    else if (type === 'colors') { ownedListKey = 'ownedColors'; equippedKey = 'equippedColor'; }
    else if (type === 'faces') { ownedListKey = 'ownedFaces'; equippedKey = 'equippedFace'; }
    
    if (action === 'buy') {
        if (gameManager.stats.coins >= item.price) {
            gameManager.stats.coins -= item.price; gameManager.stats.totalSpent += item.price;
            PLAYER_CUSTOMIZATION[ownedListKey].push(item.id); PLAYER_CUSTOMIZATION[equippedKey] = item.id;
            if(!gameManager.stats.firstPurchaseMade) {
                gameManager.stats.firstPurchaseMade = true;
                checkAchievement('first_purchase', 1);
            }
            checkMetaAchievements();
        } else { return; }
    } else if (action === 'equip') { PLAYER_CUSTOMIZATION[equippedKey] = item.id; }
    else if (action === 'unequip') { if(type === 'hats') PLAYER_CUSTOMIZATION.equippedHat = 'hat_none'; }
    
    saveGameData(); 
    setActiveTab(type); 
    updateMetaProgression();
}

function renderCharacter(ctx, x, y, w, h, facingDirection, isGlass) {
    const shapeData = SHAPES_CATALOG.find(s => s.id === PLAYER_CUSTOMIZATION.equippedShape);
    const colorData = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor);
    const hatData = HATS_CATALOG.find(h => h.id === PLAYER_CUSTOMIZATION.equippedHat);
    const faceData = FACES_CATALOG.find(f => f.id === PLAYER_CUSTOMIZATION.equippedFace);

    let finalColor = '#4caf50';
    if(colorData) {
        if (Array.isArray(colorData.value)) {
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            gradient.addColorStop(0, colorData.value[0]);
            gradient.addColorStop(1, colorData.value[1]);
            finalColor = gradient;
        } else {
            finalColor = colorData.value;
        }
    }
    
    if (isGlass) {
        ctx.save();
        ctx.globalAlpha = 0.5;
    }

    if (shapeData && shapeData.asset) shapeData.asset(ctx, x, y, w, h, finalColor);
    else drawShapeSquare(ctx, x, y, w, h, finalColor);

    if (isGlass) {
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }

    if (faceData) drawPlayerFace(ctx, x, y, w, h, faceData.text, '#000000', facingDirection);
    if (hatData && hatData.emoji) drawHatEmoji(ctx, x, y, w, h, hatData.emoji);
}

function openPermanentUpgradesScreen() { updateMetaProgression(); renderPermanentUpgrades(); }

function renderPermanentUpgrades() {
    permanentUpgradesListContainer.innerHTML = '';
    Object.keys(PERMANENT_UPGRADES_CATALOG).forEach(key => {
        const upgrade = PERMANENT_UPGRADES_CATALOG[key]; const currentLevel = PLAYER_PERMANENT_UPGRADES[key] || 0;
        const isMaxLevel = currentLevel >= upgrade.maxLevel; const cost = isMaxLevel ? 'MAX' : Math.floor(upgrade.cost(currentLevel));
        const itemDiv = document.createElement('div'); itemDiv.className = 'permanent-upgrade-item';
        const infoDiv = document.createElement('div'); infoDiv.className = 'permanent-upgrade-info';
        infoDiv.innerHTML = `<h4>${upgrade.name}</h4><p>${upgrade.description}</p><div class="upgrade-level">NÃ­vel: ${currentLevel} / ${upgrade.maxLevel}</div>`;
        const actionDiv = document.createElement('div'); actionDiv.className = 'permanent-upgrade-action'; const button = document.createElement('button'); button.className = 'modal-button';
        if (isMaxLevel) { button.textContent = 'NÃVEL MÃXIMO'; button.disabled = true; } 
        else { button.textContent = `Melhorar ð°${cost}`; button.disabled = gameManager.stats.coins < cost; button.onclick = () => handlePermanentUpgradePurchase(key); }
        actionDiv.appendChild(button); itemDiv.appendChild(infoDiv); itemDiv.appendChild(actionDiv); permanentUpgradesListContainer.appendChild(itemDiv);
    });
}

function handlePermanentUpgradePurchase(key) {
    const upgrade = PERMANENT_UPGRADES_CATALOG[key]; const currentLevel = PLAYER_PERMANENT_UPGRADES[key] || 0; if (currentLevel >= upgrade.maxLevel) return;
    const cost = Math.floor(upgrade.cost(currentLevel));
    if (gameManager.stats.coins >= cost) {
        gameManager.stats.coins -= cost; gameManager.stats.totalSpent += cost; PLAYER_PERMANENT_UPGRADES[key] = currentLevel + 1;
        checkMetaAchievements(); saveGameData(); renderPermanentUpgrades(); updateMetaProgression();
    }
}


// ===================================================================================
// 10. SAVE/LOAD GAME DATA
// ===================================================================================
function saveGameData() {
    try {
        const saveData = {
            version: 7.9,
            coins: gameManager.stats.coins, totalSpent: gameManager.stats.totalSpent, totalWins: gameManager.stats.totalWins,
            totalHealing: gameManager.stats.totalHealing || 0,
            firstPurchaseMade: gameManager.stats.firstPurchaseMade || false,
            achievements: gameManager.achievements,
            nickname: PLAYER_CUSTOMIZATION.nickname, ownedShapes: PLAYER_CUSTOMIZATION.ownedShapes, ownedHats: PLAYER_CUSTOMIZATION.ownedHats,
            ownedColors: PLAYER_CUSTOMIZATION.ownedColors, ownedFaces: PLAYER_CUSTOMIZATION.ownedFaces, equippedShape: PLAYER_CUSTOMIZATION.equippedShape,
            equippedHat: PLAYER_CUSTOMIZATION.equippedHat, equippedColor: PLAYER_CUSTOMIZATION.equippedColor, equippedFace: PLAYER_CUSTOMIZATION.equippedFace,
            permanentUpgrades: PLAYER_PERMANENT_UPGRADES, records: PLAYER_RECORDS,
            visualSettings: VISUAL_SETTINGS,
        };
        localStorage.setItem('cubeChaosSave', JSON.stringify(saveData));
    } catch(e) { console.error("Falha ao salvar o jogo:", e); }
}

function loadGameData() {
    const savedData = localStorage.getItem('cubeChaosSave');
    if (savedData) {
        try {
            const data = JSON.parse(savedData); 
            if (!data || !data.nickname || data.nickname.trim() === '' || data.nickname.trim() === 'Jogador') {
                 console.log("Save data invalid or nickname not set. Forcing nickname input.");
                 localStorage.removeItem('cubeChaosSave');
                 return false;
            }
            if (data.version < 7.9) { 
                 console.log("Save data from old version ("+ (data.version || 'N/A') +"), resetting for new features.");
                 localStorage.removeItem('cubeChaosSave');
                 return false;
            }
            gameManager.stats.coins = data.coins || 0; gameManager.stats.totalSpent = data.totalSpent || 0; gameManager.stats.totalWins = data.totalWins || 0;
            gameManager.stats.totalHealing = data.totalHealing || 0;
            gameManager.stats.firstPurchaseMade = data.firstPurchaseMade || false;
            if (data.achievements && data.achievements.length === ACHIEVEMENTS.length) { gameManager.achievements = data.achievements; }
            PLAYER_CUSTOMIZATION.nickname = data.nickname;
            PLAYER_CUSTOMIZATION.ownedShapes = data.ownedShapes || ['shape_square'];
            PLAYER_CUSTOMIZATION.ownedHats = data.ownedHats || ['hat_none'];
            PLAYER_CUSTOMIZATION.ownedColors = data.ownedColors || ['color_green_default'];
            PLAYER_CUSTOMIZATION.ownedFaces = data.ownedFaces || ['face_zero', 'face_smile'];
            PLAYER_CUSTOMIZATION.equippedShape = data.equippedShape || 'shape_square';
            PLAYER_CUSTOMIZATION.equippedHat = data.equippedHat || 'hat_none';
            PLAYER_CUSTOMIZATION.equippedColor = data.equippedColor || 'color_green_default';
            PLAYER_CUSTOMIZATION.equippedFace = data.equippedFace || 'face_zero';
            PLAYER_PERMANENT_UPGRADES = data.permanentUpgrades || {};
            PLAYER_RECORDS = data.records || []; 
            Object.assign(VISUAL_SETTINGS, data.visualSettings);
            
            checkRetroactiveAchievements();
            
            updateAchievementCounters();
            return true;
        } catch (e) { console.error("Erro ao carregar dados salvos, resetando:", e); localStorage.removeItem('cubeChaosSave'); }
    }
    return false;
}

function deleteSaveData() {
    localStorage.removeItem('cubeChaosSave');
    location.reload();
}

deleteDataButton.addEventListener('click', () => {
    deleteDataConfirmationModal.style.display = 'flex';
});
confirmDeleteDataYes.addEventListener('click', deleteSaveData);
confirmDeleteDataNo.addEventListener('click', () => {
    deleteDataConfirmationModal.style.display = 'none';
});

function checkRetroactiveAchievements() {
    checkMetaAchievements(true);
    if (gameManager.stats.firstPurchaseMade) {
        const firstPurchaseAch = gameManager.achievements.find(a => a.id === 'firstpurchase');
        if (firstPurchaseAch && !firstPurchaseAch.unlocked) {
            checkAchievement('first_purchase', 1, true);
        }
    }
}

// ===================================================================================
// 11. RECORDS & INFO SYSTEM LOGIC (v6.8 / v7.2)
// ===================================================================================
function populateBestRecordDisplay() {
    const bestWaveEl = document.getElementById('best-record-wave');
    const bestKillsEl = document.getElementById('best-record-kills');
    const bestTimeEl = document.getElementById('best-record-time');

    if (PLAYER_RECORDS.length === 0) {
        bestWaveEl.textContent = '--';
        bestKillsEl.textContent = '--';
        bestTimeEl.textContent = '--:--';
        return;
    }

    const bestRecord = [...PLAYER_RECORDS].sort((a, b) => {
        if (b.wave !== a.wave) return b.wave - a.wave;
        return b.kills - a.kills;
    })[0];

    bestWaveEl.textContent = bestRecord.wave;
    bestKillsEl.textContent = bestRecord.kills;
    bestTimeEl.textContent = bestRecord.time;
}

function populateRecordsTable() {
    recordsTableBody.innerHTML = '';
    if (PLAYER_RECORDS.length > 0) {
        const sortedRecords = [...PLAYER_RECORDS].sort((a, b) => {
            if (b.wave !== a.wave) return b.wave - a.wave;
            return b.kills - a.kills;
        });

        sortedRecords.forEach(record => {
            const charName = record.character ? record.character.charAt(0).toUpperCase() + record.character.slice(1) : 'N/A';
            const diffName = record.difficulty ? record.difficulty.charAt(0).toUpperCase() + record.difficulty.slice(1) : 'N/A';
            const modeName = record.mode === 'waves' ? '100 Ondas' : (record.mode === 'infinite' ? 'Infinito' : 'N/A');
            const deviceName = record.device === 'desktop' ? 'PC' : 'Mobile';

            const charText = `${charName}${record.isCharacterRandom ? ' (ð²)' : ''}`;
            const diffText = `${diffName}${record.isDifficultyRandom ? ' (ð²)' : ''}`;
            const modeText = `${modeName}${record.isGameModeRandom ? ' (ð²)' : ''}`;

            recordsTableBody.innerHTML += `<tr><td>${record.date}</td><td>${charText}</td><td>${diffText}</td><td>${modeText}</td><td>${record.wave}</td><td>${record.kills}</td><td>${record.time}</td><td>${deviceName}</td></tr>`;
        });
    } else {
        recordsTableBody.innerHTML = `<tr><td colspan="8">Nenhum histÃ³rico de partidas encontrado. Jogue para comeÃ§ar a registrar!</td></tr>`;
    }
}

showRecordsButton.addEventListener('click', () => openModal(recordsModal, 'mainMenu'));
recordsCloseButton.addEventListener('click', () => closeModal(recordsModal));
closeRecordsButton.addEventListener('click', () => closeModal(recordsModal));

showInfoButton.addEventListener('click', () => openModal(infoModal, 'mainMenu'));
infoCloseButton.addEventListener('click', () => closeModal(infoModal, 'mainMenu'));
document.querySelectorAll('.info-tabs button').forEach(button => { button.addEventListener('click', () => setInfoTab(button.dataset.tab)); });
function setInfoTab(tabName) {
    document.querySelectorAll('.info-tabs button').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.info-tabs button[data-tab="${tabName}"]`).classList.add('active');
    const contentPanel = document.getElementById('info-content-panel'); contentPanel.innerHTML = ''; let html = '';
    switch(tabName) {
        case 'info-cards':
            html += '<div class="info-card-grid">';
            Object.values(UPGRADES).sort((a,b) => a.name.localeCompare(b.name)).forEach(card => { 
                html += `<div class="info-card"><h4>${card.name}</h4><p>${card.description}</p><p style="font-size: 0.85em; color: #aabfff; margin-top: 10px; border-top: 1px dashed #5a6a8a; padding-top: 8px;"><strong>Efeito de AcÃºmulo:</strong><br>${card.scaling || 'NÃ£o possui efeitos de acÃºmulo adicionais.'}</p><p class="rarity" style="color:${getColorByRarity(card.rarity)}">${card.rarity.toUpperCase()}</p></div>`; 
            });
            html += '</div>';
            break;
        case 'info-enemies':
             html += '<div class="info-card-grid">';
             Object.values(ENEMY_TYPES).forEach(enemy => { html += `<div class="info-card"><h4>${enemy.name}</h4><p>${enemy.description}</p></div>`; }); 
             html += '</div>';
             break;
        case 'info-scenarios':
            html += '<div class="info-card-grid">';
            Object.values(THEMES).forEach(theme => { html += `<div class="info-card"><h4>${theme.name}</h4><p>Cores: <span style="color:${theme.ground}">ChÃ£o</span>, <span style="color:${theme.platform}">Plataformas</span></p></div>`; });
            html += '</div>';
            break;
        case 'info-tech':
             html += `<div class="info-section">
                        <h4>FÃ³rmulas de Jogo</h4>
                        <p>Entender as mecÃ¢nicas centrais pode ajudar a criar builds mais fortes.</p>
                        <ul>
                          <li><strong>Vida dos Inimigos:</strong> <code>Vida Base * (1 + (Onda - 1) * 0.1) * Modificador de Dificuldade</code>. A vida escala linearmente com as ondas.</li>
                          <li><strong>Dano do Jogador:</strong> <code>(Dano Base * BÃ´nus Permanente + BÃ´nus Fixo) * Modificadores Multiplicativos</code>. Cartas como 'FÃºria' e 'CanhÃ£o de Vidro' sÃ£o multiplicadores finais.</li>
                          <li><strong>Dano CrÃ­tico:</strong> <code>Dano Final * (1.5 + BÃ´nus de 'PrecisÃ£o')</code>. CrÃ­ticos sÃ£o uma fonte poderosa de dano em rajada.</li>
                          <li><strong>Velocidade de Ataque:</strong> A recarga Ã© multiplicada por um fator redutor (ex: 0.92 para +8% de velocidade). Acumular velocidade de ataque tem retornos decrescentes, mas Ã© sempre eficaz.</li>
                          <li><strong>Ganhos de Moedas:</strong> <code>(Moedas da Fonte + BÃ´nus de Onda) * (1 + BÃ´nus Permanente)</code>. Melhorias permanentes sÃ£o aplicadas no final.</li>
                        </ul>
                      </div>`;
             html += `<div class="info-section">
                        <h4>Sinergias e Efeitos Visuais</h4>
                        <p>Muitas cartas nÃ£o apenas mudam nÃºmeros, mas tambÃ©m adicionam efeitos visuais que indicam seu poder crescente.</p>
                        <ul>
                          <li><strong>Fogo ('Catalisador'):</strong> Deixa um rastro de fogo nos projÃ©teis.</li>
                          <li><strong>Gelo ('Nova Congelante'):</strong> Cria uma explosÃ£o azulada ao ser atingido.</li>
                          <li><strong>ElÃ©trico ('Corrente de Raios', 'RelÃ¢mpago'):</strong> Gera feixes de energia azul/amarela.</li>
                          <li><strong>Gravitacional ('Buraco Negro', 'PoÃ§o Gravitacional'):</strong> Cria vÃ³rtices roxos que distorcem o espaÃ§o.</li>
                          <li><strong>Fantasma ('Balas Fantasma', 'RessonÃ¢ncia'):</strong> Adiciona efeitos de transparÃªncia e imagens residuais.</li>
                        </ul>
                        <p>Tente combinar cartas para criar sinergias poderosas, como 'Buraco Negro' + 'FragmentaÃ§Ã£o+' para dano massivo em Ã¡rea.</p>
                      </div>`;
             break;
        case 'info-controls':
            html += `<div class="tutorial-section"><h3>Controles (Desktop)</h3><p><strong>A/D ou Setas â/â:</strong> Mover o personagem.<br><strong>Barra de EspaÃ§o:</strong> Pular.<br><strong>Clique do Mouse:</strong> Atirar na direÃ§Ã£o do cursor.</p></div><div class="tutorial-section"><h3>Controles (Mobile)</h3><p><strong>Joystick Esquerdo:</strong> Mover o personagem. Puxe para baixo para pular.<br><strong>Joystick Direito:</strong> Atirar na direÃ§Ã£o apontada.</p></div>`; 
            break;
    }
    contentPanel.innerHTML = html;
}

function updateSettingsUI() {
    document.getElementById('shadows-setting').checked = VISUAL_SETTINGS.shadows;
    document.getElementById('blood-setting').checked = VISUAL_SETTINGS.blood;
    document.getElementById('screenshake-intensity').value = VISUAL_SETTINGS.screenShakeIntensity;
    document.getElementById('particle-intensity').value = VISUAL_SETTINGS.particleIntensity;
    document.getElementById('trail-intensity').value = VISUAL_SETTINGS.trailIntensity;
    document.getElementById('card-effect-intensity').value = VISUAL_SETTINGS.cardEffectIntensity;
    document.getElementById('nametag-style').value = VISUAL_SETTINGS.nametagStyle;
    
    cheatFeaturesSettingCheckbox.checked = VISUAL_SETTINGS.cheatFeaturesEnabled;
    cheatSettingsContainer.style.display = VISUAL_SETTINGS.cheatFeaturesEnabled ? 'block' : 'none';
    document.getElementById('set-coins-input').value = gameManager.stats.coins;
}

function setGraphicsPreset(preset) {
    const settings = {
        low:    { shadows: false, blood: false, shake: 2, particles: 2, trail: 2, cardFx: 3 },
        medium: { shadows: true,  blood: true,  shake: 6, particles: 6, trail: 6, cardFx: 7 },
        high:   { shadows: true,  blood: true,  shake: 8, particles: 10, trail: 10, cardFx: 10 },
    };
    const s = settings[preset];
    if (!s) return;

    VISUAL_SETTINGS.shadows = s.shadows; VISUAL_SETTINGS.blood = s.blood;
    VISUAL_SETTINGS.screenShakeIntensity = s.shake; VISUAL_SETTINGS.particleIntensity = s.particles;
    VISUAL_SETTINGS.trailIntensity = s.trail; VISUAL_SETTINGS.cardEffectIntensity = s.cardFx;
    
    updateSettingsUI();
}

document.getElementById('preset-low').addEventListener('click', () => setGraphicsPreset('low'));
document.getElementById('preset-medium').addEventListener('click', () => setGraphicsPreset('medium'));
document.getElementById('preset-high').addEventListener('click', () => setGraphicsPreset('high'));

// InicializaÃ§Ã£o
function initializeGame() {
    createStars(); 
    const hasSave = loadGameData();
    confirmNicknameButton.disabled = true; 
    
    if (hasSave) {
        showMainMenu(); 
    } else { 
        if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
        nicknameModal.style.display = 'flex'; 
    }
    updateAchievementCounters();
    populateBestRecordDisplay();
}

window.addEventListener('DOMContentLoaded', initializeGame);
window.addEventListener('beforeunload', saveGameData);

</script>
</body>
</html>
