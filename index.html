<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CubeChaos - Sobrecarga Cósmica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body { 
            background: radial-gradient(circle at center, #0a0a1a 0%, #000010 100%);
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #f0f0f0; 
            overflow: hidden; 
            position: relative;
            touch-action: none;
        }
        
        canvas { 
            background: radial-gradient(circle at center, #0a0a2a 0%, #1a1a4a 100%);
            display: none; /* Inicia oculto */
            border-radius: 10px; 
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.5);
        }
        
        .ui-modal { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.92); 
            backdrop-filter: blur(12px); 
            display: none; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            text-align: center; 
            opacity: 0; 
            transition: opacity 0.5s ease; 
            z-index: 100; 
            padding: 20px;
        }

        .ui-modal[style*="display: flex"] {
            opacity: 1;
        }
        
        .modal-content { 
            padding: 30px; 
            border-radius: 15px; 
            width: 90%; 
            max-width: 950px;
            background: rgba(20, 30, 60, 0.95);
            border: 2px solid rgba(100, 180, 255, 0.7);
            box-shadow: 0 0 40px rgba(0, 150, 255, 0.8);
            transform: scale(0.9);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .ui-modal[style*="display: flex"] .modal-content {
            transform: scale(1);
            opacity: 1;
        }
        
        h1, h2, h3 { 
            margin: 10px 0; 
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.9);
            letter-spacing: 1px;
            font-weight: 700;
        }
        
        #upgrade-choices { 
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            justify-content: center; 
            gap: 20px; 
            margin-top: 20px; 
            flex-wrap: wrap; 
        }
        
        .upgrade-card, .cheat-card, .achievement-card { 
            background: rgba(30, 40, 80, 0.95);
            border: 2px solid #4a5a9a; 
            border-radius: 12px; 
            padding: 20px; 
            width: 100%;
            min-height: 160px;
            cursor: pointer; 
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4); 
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .upgrade-card:hover, .cheat-card:hover, .achievement-card:hover { 
            transform: translateY(-10px) scale(1.05);
            border-color: #8a8aff; 
            box-shadow: 0 0 30px rgba(138, 138, 255, 0.9);
            background: rgba(40, 50, 90, 0.95);
        }
        
        .upgrade-card h3, .cheat-card h3, .achievement-card h3 { 
            margin-top: 0; 
            font-size: 1.2em; 
            color: #ffcc00;
            border-bottom: 1px solid rgba(255, 204, 0, 0.3);
            padding-bottom: 8px;
            margin-bottom: 10px;
        }
        
        .upgrade-card p, .cheat-card p, .achievement-card p { 
            font-size: 0.95em; 
            color: #ccc; 
            margin-top: 8px;
            line-height: 1.4;
            flex-grow: 1;
        }
        
        .card-rarity-common { border-left: 6px solid #ffffff; }
        .card-rarity-uncommon { border-left: 6px solid #4caf50; }
        .card-rarity-rare { border-left: 6px solid #2196f3; }
        .card-rarity-epic { border-left: 6px solid #9c27b0; }
        .card-rarity-legendary { border-left: 6px solid #ff9800; }
        
        .achievement-common { border-left: 6px solid #ffffff; }
        .achievement-uncommon { border-left: 6px solid #4caf50; }
        .achievement-rare { border-left: 6px solid #2196f3; }
        .achievement-epic { border-left: 6px solid #9c27b0; }
        .achievement-legendary { border-left: 6px solid #ff9800; }
        
        .modal-button { 
            padding: 15px 30px; 
            font-size: 1.2em; 
            background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%);
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            margin-top: 20px; 
            transition: all 0.3s ease;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: 600;
            min-width: 220px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-button:hover:not(:disabled) { 
            background: linear-gradient(135deg, #66bb6a 0%, #388e3c 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }
         .modal-button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        #game-over-screen, #victory-modal { display: none; }
        #upgrade-modal .modal-content {
            width: 90%;
            max-width: 1000px;
        }
        #upgrade-modal-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(200, 220, 255, 0.8);
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.7);
            z-index: 5;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        #cheatMenuButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(200, 50, 50, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none;
        }
        
        #settingsButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(150, 100, 250, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none; /* Hidden by default */
        }
        
        #cheatMenuButton:hover {
            background: rgba(220, 70, 70, 0.95);
            transform: scale(1.05);
        }
        
        #settingsButton:hover {
            background: rgba(170, 130, 255, 0.95);
        }
        
        #cheat-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 40, 80, 0.97);
            border-radius: 12px;
            padding: 25px;
            width: 340px;
            display: none;
            z-index: 110;
            box-shadow: 0 0 30px rgba(255, 85, 85, 0.6);
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #ff5555;
        }
        #cheat-features-confirmation-modal, #delete-data-confirmation-modal, #restart-confirmation-modal, #return-to-menu-confirmation-modal {
            z-index: 120;
        }

        #badges-modal .modal-content, #records-modal .modal-content, #info-modal .modal-content, #changelog-modal .modal-content {
            border: 2px solid #4caf50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            width: 90%;
            max-width: 1100px;
        }
        
        #settings-modal .modal-content {
            border: 2px solid #9c27b0;
            box-shadow: 0 0 30px rgba(156, 39, 176, 0.6);
            width: 90%;
            max-width: 800px;
        }
        
        .cheat-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #555;
            padding-bottom: 15px;
        }
        
        .cheat-section h3 {
            color: #ff5555;
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1em;
        }
        
        .cheat-option {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            align-items: center;
        }
        
        .cheat-option label {
            flex: 1;
            text-align: left;
            font-size: 14px;
        }
        
        .cheat-option input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
        }
        
        .cheat-option input[type="number"] {
            width: 70px;
            padding: 6px;
            background: #2a2a4a;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }
        
        .cheat-button {
            background: linear-gradient(135deg, #ff5555 0%, #cc0000 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .cheat-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 85, 85, 0.5);
        }
        
        .platform {
            background: #5a6a9a;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(100, 150, 255, 0.6);
        }
        
        .joystick-container {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        .blood-splatter {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle, rgba(200,0,0,0.8) 0%, rgba(150,0,0,0) 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .damage-zone {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            background: rgba(255, 138, 101, 0.5);
            box-shadow: 0 0 15px #ff8a65;
            border: 2px solid #ff5722;
        }
        
        #cheat-cards-list {
            max-height: 300px;
            overflow-y: auto;
            flex-direction: column;
            gap: 12px;
        }
        
        #achievements-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
            max-height: 55vh;
            overflow-y: auto;
            padding: 10px;
        }
        .achievement-card .reward-info {
            font-size: 0.9em;
            color: #8a8aff;
            margin-top: 8px;
            border-top: 1px dashed rgba(138, 138, 255, 0.3);
            padding-top: 8px;
        }

        #pauseButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: rgba(50, 150, 250, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            font-size: 1.2em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            display: none;
        }
        #pauseButton:hover {
            background: rgba(70, 170, 255, 0.95);
            transform: scale(1.05);
        }
        .cheat-card, .achievement-card {
            width: 100%;
            padding: 15px;
            text-align: left;
        }
        .pet {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #ff4081;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff4081;
            z-index: 10;
        }
        
        .lightning {
            position: absolute;
            pointer-events: none;
            z-index: 25; 
            background: linear-gradient(to bottom, rgba(255,255,255,0.8) 0%, rgba(255,255,100,0.8) 30%, rgba(255,200,0,0.8) 100%);
            opacity: 0;
            animation: lightningFlash 0.3s linear;
        }
        
        @keyframes lightningFlash {
            0% { opacity: 0; width: 4px; }
            10% { opacity: 1; width: 6px; }
            100% { opacity: 0; width: 2px; }
        }
        
        .laser-beam {
            position: absolute;
            pointer-events: none;
            z-index: 26; 
            background: linear-gradient(to right, rgba(255,0,0,0.8) 0%, rgba(255,100,100,0.8) 50%, rgba(255,0,0,0.8) 100%);
            box-shadow: 0 0 15px rgba(255,0,0,0.8);
            opacity: 0;
            animation: laserFade 0.4s linear;
        }
        
        @keyframes laserFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #achievement-notification-container {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }
        
        .achievement-notification {
            background: rgba(40, 50, 90, 0.95);
            border: 2px solid #ffcc00;
            border-radius: 10px;
            padding: 15px;
            width: 350px;
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.7);
            display: flex;
            align-items: center;
            animation: slideInOut 4s forwards;
            pointer-events: all;
        }
        
        @keyframes slideInOut {
            0% { transform: translateX(-110%); }
            15% { transform: translateX(0); }
            85% { transform: translateX(0); }
            100% { transform: translateX(-110%); }
        }
        
        .achievement-icon {
            width: 50px;
            height: 50px;
            background: gold;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #333;
            flex-shrink: 0;
        }
        
        .achievement-text h4 {
            color: #ffcc00;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        
        .achievement-text p {
            color: #ccc;
            font-size: 14px;
        }
        
        .achievement-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ffcc00;
            color: #333;
            font-weight: bold;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .achievement-card.unlocked { 
             border-color: #ffcc00; 
             background: rgba(50, 60, 110, 0.95);
        }
        
        .achievement-card.unlocked h3,
        .achievement-card.unlocked p {
            color: #ffdd44 !important;
        }
        
        .achievement-card.unlocked .conquista-text {
            color: #ffcc00 !important;
        }
        
        .achievement-counter-badge {
            display: inline-block;
            margin-left: 10px;
            padding: 3px 10px;
            font-size: 0.8em;
            font-weight: bold;
            background-color: #ffcc00;
            color: #333;
            border-radius: 12px;
            line-height: 1;
        }

        .setting-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .setting-option:last-child {
            border-bottom: none;
        }
        
        .setting-option label {
            flex: 1;
            text-align: left;
            font-size: 16px;
        }
        
        .setting-option input[type="range"] {
            width: 150px;
        }
        
        .setting-option input[type="checkbox"], .setting-option select {
            width: 20px;
            height: 20px;
        }
        .setting-option select {
            width: 150px;
            height: auto;
            padding: 5px;
            background: #2a2a4a;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }

        .graphics-presets {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .preset-button {
            padding: 8px 16px;
            background-color: #4a5a9a;
            border: 1px solid #6a7abc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .preset-button:hover {
            background-color: #8a8aff;
            border-color: #ffcc00;
        }
        .delete-data-button {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
            border: 1px solid #ff8a80;
            padding: 10px 20px;
        }
        .delete-data-button:hover {
             background: linear-gradient(135deg, #ef5350 0%, #d32f2f 100%);
        }

        
        .game-title {
            font-size: 4.5em;
            color: #ffcc00;
            text-shadow: 0 0 20px rgba(255, 204, 0, 0.7);
            margin-bottom: 5px; 
            letter-spacing: 4px;
            text-transform: uppercase;
            animation: titleGlow 2s infinite alternate;
            background: linear-gradient(45deg, #ffcc00, #ff9900);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 204, 0, 0.9), 0 0 60px rgba(255, 204, 0, 0.7); }
        }

        #splash-text, #splash-text-nickname {
            color: #ffffff;
            font-style: italic;
            margin-bottom: 20px;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            min-height: 20px; 
        }
        
        .character-selection {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .character-card {
            background: rgba(40, 50, 90, 0.8);
            border-radius: 15px;
            padding: 20px;
            width: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #4a5a9a;
            text-align: center;
        }
        
        .character-card:hover {
            transform: translateY(-10px);
            border-color: #8a8aff;
            box-shadow: 0 0 30px rgba(138, 138, 255, 0.7);
        }
        
        .character-card.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.7);
            transform: scale(1.05);
        }
        
        .character-icon {
            width: 100px;
            height: 100px;
            margin: 0 auto 15px;
            border-radius: 50%;
            background: #5a6a9a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        
        .character-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffcc00;
        }
        
        .character-description {
            font-size: 0.9em;
            color: #ccc;
        }
        
        .meta-progression {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .progression-item {
            background: rgba(40, 50, 90, 0.8);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            min-width: 120px;
        }
        
        .progression-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffcc00;
            margin: 5px 0;
        }
        
        .progression-label {
            font-size: 0.9em;
            color: #ccc;
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
        }
        
        .damage-indicator {
            position: absolute;
            color: #ff5555;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
            pointer-events: none;
            z-index: 15;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        #ingame-info-display {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto; 
            transform: none; 
            text-align: right;
            background: rgba(0,0,0,0.4);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 14px;
            color: #ccc;
            z-index: 10;
        }

        #game-timer-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.4);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            color: #f0f0f0;
            z-index: 10;
        }

        #ingame-info-display span {
            color: white;
            font-weight: bold;
            margin: 0 8px;
        }

        .wave-indicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
            z-index: 10;
        }
        
        .boss-warning {
            position: absolute;
            top: 30%;
            left: 0;
            right: 0;
            text-align: center;
            color: #ff5555;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            animation: pulseWarning 1s infinite;
            z-index: 20;
            display: none;
        }
        
        @keyframes pulseWarning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .tutorial-content {
            max-width: 800px;
            background: rgba(30, 40, 80, 0.95);
            border-radius: 15px;
            padding: 30px;
            border: 2px solid #4caf50;
        }
        
        .tutorial-section {
            margin-bottom: 25px;
        }
        
        .tutorial-section h3 {
            color: #4caf50;
            margin-bottom: 10px;
        }
        
        .tutorial-controls {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        
        .control-item {
            text-align: center;
        }
        
        .control-icon {
            width: 60px;
            height: 60px;
            background: rgba(100, 180, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-size: 24px;
        }
        
        #play-button {
            position: relative;
            z-index: 5;
        }

        #customization-modal .modal-content, #permanent-upgrades-modal .modal-content {
            max-width: 900px;
        }

        .customization-container {
            display: block;
            margin-top: 20px;
        }

        .customization-sections {
            flex: 1;
        }
        
        .customization-tabs, .info-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 2px solid #8a8aff;
            padding-bottom: 10px;
        }

        .customization-tabs button, .info-tabs button {
            padding: 10px 15px;
            background-color: rgba(50, 60, 100, 0.8);
            color: #ccc;
            border: 1px solid #4a5a9a;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .customization-tabs button.active,
        .customization-tabs button:hover,
        .info-tabs button.active,
        .info-tabs button:hover {
            background-color: #8a8aff;
            color: white;
            border-color: #ffcc00;
        }

        .customization-options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .customization-options-grid::-webkit-scrollbar, .permanent-upgrades-list::-webkit-scrollbar, #info-content-panel::-webkit-scrollbar, #changelog-content::-webkit-scrollbar, #achievements-list::-webkit-scrollbar {
            width: 8px;
        }
        .customization-options-grid::-webkit-scrollbar-track, .permanent-upgrades-list::-webkit-scrollbar-track, #info-content-panel::-webkit-scrollbar-track, #changelog-content::-webkit-scrollbar-track, #achievements-list::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .customization-options-grid::-webkit-scrollbar-thumb, .permanent-upgrades-list::-webkit-scrollbar-thumb, #info-content-panel::-webkit-scrollbar-thumb, #changelog-content::-webkit-scrollbar-thumb, #achievements-list::-webkit-scrollbar-thumb {
            background: #8a8aff;
            border-radius: 4px;
        }
        .customization-options-grid::-webkit-scrollbar-thumb:hover, .permanent-upgrades-list::-webkit-scrollbar-thumb:hover, #info-content-panel::-webkit-scrollbar-thumb:hover, #changelog-content::-webkit-scrollbar-thumb:hover, #achievements-list::-webkit-scrollbar-thumb:hover {
            background: #ffcc00;
        }


        .customization-item {
            background-color: rgba(40, 50, 90, 0.7);
            border: 2px solid #4a5a9a;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 150px;
        }

        .customization-item:hover {
            border-color: #ffcc00;
            transform: translateY(-5px);
        }

        .customization-item.equipped {
            border-color: #4caf50;
            box-shadow: 0 0 15px #4caf50;
        }
         .customization-item.locked {
            opacity: 0.7;
            background-color: rgba(20,30,50,0.7);
        }
        .customization-item.locked .item-name {
            font-style: italic;
        }

        .item-preview {
            width: 60px;
            height: 60px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin: 0 auto 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #6070b0;
            overflow: hidden;
        }
        .item-preview canvas {
            display: block;
        }
        .item-preview-emoji {
             font-size: 36px;
             line-height: 60px;
        }
        
        .item-name {
            font-size: 0.9em;
            color: #eee;
            margin-bottom: 5px;
            word-wrap: break-word;
            flex-grow: 1;
        }

        .item-button-container {
            margin-top: 5px;
        }

        .item-button {
            width: 100%;
            padding: 8px 5px;
            font-size: 0.8em;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color: 0.2s;
        }

        .buy-button { background-color: #ffc107; color: #333; }
        .buy-button:hover { background-color: #ffca28; }
        .equip-button { background-color: #2196f3; color: white; }
        .equip-button:hover { background-color: #42a5f5; }
        .unequip-button { background-color: #78909c; color: white; }
        .unequip-button:hover { background-color: #90a4ae; }
        .equipped-button { background-color: #4caf50; color: white; cursor: not-allowed; }
        .achievement-lock-button { background-color: #b0bec5; color: #37474f; font-size: 0.7em; cursor: help; }


        #customization-coins {
            font-size: 1.2em;
            color: #ffcc00;
            margin-top: 15px;
            text-align: right;
            padding-right: 10px;
        }
        .customization-footer {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
        }

        #permanent-upgrades-modal .modal-content {
            max-width: 700px;
        }
        .permanent-upgrades-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            max-height: 50vh;
            overflow-y: auto;
            padding: 10px;
        }
        .permanent-upgrade-item {
            background-color: rgba(30, 40, 80, 0.9);
            border: 1px solid #4a5a9a;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .permanent-upgrade-info {
            text-align: left;
        }
        .permanent-upgrade-info h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 5px;
        }
        .permanent-upgrade-info p {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 5px;
        }
        .permanent-upgrade-info .upgrade-level {
            font-size: 0.8em;
            color: #4caf50;
        }
        .permanent-upgrade-action button {
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
        }
         .permanent-upgrade-action button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #nickname-modal .modal-content {
            max-width: 500px;
        }
        #nickname-modal { z-index: 150; }
        #nickname-input {
            width: 100%;
            padding: 15px;
            margin: 20px 0;
            font-size: 1.2em;
            text-align: center;
            background-color: rgba(0,0,0,0.3);
            border: 2px solid #8a8aff;
            color: white;
            border-radius: 8px;
        }
        #nickname-error {
            color: #ff5555;
            min-height: 20px;
        }
        
        #main-menu-modal .modal-content {
             background: none;
             border: none;
             box-shadow: none;
             overflow: visible;
             align-items: stretch; 
             justify-content: stretch;
             max-width: 1200px;
        }
        
        .main-menu-layout {
            display: flex;
            justify-content: space-between;
            align-items: center; 
            gap: 20px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .main-menu-left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
            width: 25%;
        }
        
        .main-menu-center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .main-menu-right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            width: 25%;
            text-align: center;
        }
        
        #main-menu-nickname {
            color: #ffcc00;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 0 0 10px #ffcc00;
            margin-bottom: 10px;
            text-align: left;
            width: 100%;
        }

        #characterPreviewCanvas {
            width: 200px;
            height: 200px;
            background: rgba(10, 20, 40, 0.7);
            border-radius: 15px;
            border: 2px solid #8a8aff;
            box-shadow: 0 0 20px rgba(138, 138, 255, 0.5);
            animation: floatPreview 4s ease-in-out infinite;
        }
        @keyframes floatPreview {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        #main-menu-coins-display {
            margin-bottom: 25px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2em;
            color: #ffcc00;
            font-weight: bold;
            border: 1px solid #ffcc00;
            width: 100%;
            text-align: center;
        }
        .main-menu-button {
            padding: 15px 20px;
            font-size: 1.1em;
            font-weight: 600;
            color: #e0e0e0;
            background: transparent;
            border: 2px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(135deg, #6a1b9a, #8a8aff);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            width: 100%; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-menu-button:hover {
            color: white;
            border-image-source: linear-gradient(135deg, #8a8aff, #ffcc00);
            transform: scale(1.05);
            text-shadow: 0 0 10px white;
        }
        .main-menu-button.play-button {
            padding: 25px 20px;
            font-size: 1.5em;
            border-image-source: linear-gradient(135deg, #4caf50, #81c784);
        }
        .main-menu-button.play-button:hover {
            border-image-source: linear-gradient(135deg, #81c784, #ffeb3b);
        }
        
        .main-menu-left-panel .game-title {
            text-align: left;
        }

        #best-record-display {
            background: rgba(40, 50, 90, 0.8);
            border: 2px solid #ffcc00;
            border-radius: 15px;
            padding: 20px;
            width: 100%;
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.5);
        }
        #best-record-display h3 {
            color: #ffcc00;
            margin-top: 0;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 10px;
        }
        #best-record-display p {
            font-size: 1em;
            margin: 8px 0;
            color: #ccc;
        }
        #best-record-display span {
            font-weight: bold;
            color: white;
        }
        #records-modal .modal-content {
            width: 90%;
            max-width: 1200px; 
        }

        #records-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }
        #records-table th, #records-table td {
            padding: 12px;
            border: 1px solid #4a5a9a;
            text-align: center;
        }
        #records-table th {
            background-color: rgba(40, 50, 90, 0.95);
            color: #ffcc00;
        }
        #records-list-container {
             max-height: 60vh;
             overflow-y: auto;
        }
         #records-list-container::-webkit-scrollbar { width: 8px; }
         #records-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
         #records-list-container::-webkit-scrollbar-thumb { background: #4caf50; border-radius: 4px; }

         .selection-footer-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
            margin-top: 20px;
         }
        
        #info-content-panel, #changelog-content {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            max-height: 55vh;
            overflow-y: auto;
            text-align: left;
        }
        .info-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .info-card {
            background-color: rgba(40,50,90,0.8);
            border: 1px solid #6070b0;
            border-radius: 8px;
            padding: 15px;
        }
        .info-card h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
        .info-card p, #changelog-content p, .info-section p {
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.5;
        }
        .info-card .rarity {
            font-style: italic;
            margin-top: 10px;
            text-align: right;
            font-weight: bold;
        }
        .info-section {
            margin-bottom: 20px;
        }
        .info-section h4 {
            color: #ffcc00;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
         #changelog-content ul {
            list-style-position: inside;
            padding-left: 10px;
        }
         #changelog-content li {
            margin-bottom: 8px;
        }
        #changelog-content h4 {
            color: #4caf50;
            margin-top: 15px;
        }
        #changelog-content h3 {
            color: #ffcc00;
            margin-top: 25px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 5px;
        }
        #changelog-content h3:first-child {
            margin-top: 0;
        }
        .info-card ul {
            list-style-position: inside; padding-left: 10px; margin-top: 8px;
        }
        .info-card li {
             margin-bottom: 5px;
        }

        #ingame-cards-ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            max-height: 40vh;
            background-color: rgba(10, 20, 40, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            border: 1px solid rgba(138, 138, 255, 0.5);
            padding: 10px;
            z-index: 50;
            overflow-y: auto;
            display: none;
        }
        #ingame-cards-ui::-webkit-scrollbar { width: 6px; }
        #ingame-cards-ui::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        #ingame-cards-ui::-webkit-scrollbar-thumb { background: #8a8aff; border-radius: 3px;}
        .ingame-card-item {
            color: #eee;
            font-size: 14px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(138, 138, 255, 0.2);
        }
        .ingame-card-item:last-child {
            border-bottom: none;
        }
        .ingame-card-item .count {
            color: #ffcc00;
            font-weight: bold;
            margin-left: 8px;
        }

    </style>
</head>
<body>
    <!-- Fundo de estrelas -->
    <div class="stars" id="stars"></div>

    <!-- Container para notificações de conquista -->
    <div id="achievement-notification-container"></div>
    
    <canvas id="gameCanvas"></canvas>
    
    <!-- Elementos de UI do jogo -->
    <div id="ingame-info-display" style="display: none;"></div>
    <div id="game-timer-display" style="display: none;">Tempo: 00:00</div>
    <div class="wave-indicator" id="wave-indicator">Onda: 0 | Inimigos: 0</div>
    <div class="boss-warning" id="boss-warning">CHEFE IMINENTE!</div>
    <div id="ingame-cards-ui"></div>
    
    <!-- Botões de UI -->
    <button id="cheatMenuButton">Cheat Menu</button>
    <button id="settingsButton">Settings</button>
    <button id="pauseButton">❚❚</button>
    
    <!-- Menu de Cheats -->
    <div id="cheat-menu">
        <button class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;" id="cheat-close">×</button>
        <h2>CHEAT MENU</h2>
        <div class="cheat-section">
            <h3>Jogador</h3>
            <div class="cheat-option"><label>Imortalidade:</label><input type="checkbox" id="immortality-cheat"></div>
            <div class="cheat-option"><label>Auto Disparo:</label><input type="checkbox" id="auto-fire-cheat"></div>
            <div class="cheat-option"><label>Velocidade:</label><input type="number" id="player-speed" value="7"></div>
            <div class="cheat-option"><label>Dano:</label><input type="number" id="player-damage" value="5"></div>
        </div>
        <div class="cheat-section">
            <h3>Inimigos</h3>
            <div class="cheat-option"><label>Congelar Inimigos:</label><input type="checkbox" id="freeze-enemies"></div>
            <div class="cheat-option"><label>Dano aos Inimigos:</label><input type="number" id="enemy-damage" value="10"></div>
        </div>
        <div class="cheat-section">
            <h3>Gameplay</h3>
            <div class="cheat-option"><label>EXP Instantâneo:</label><input type="checkbox" id="instant-exp"></div>
            <div class="cheat-option"><label>Pulos Infinitos:</label><input type="checkbox" id="infinite-jumps"></div>
            <div class="cheat-option"><label>Ir para a Onda:</label><input type="number" id="set-wave" min="1" max="100" value="1"></div>
            <div class="cheat-option"><label>Limite de Cartas:</label><input type="number" id="max-stacks" min="1" max="200" value="50"></div>
        </div>
        <div class="cheat-section">
            <h3>Cartas</h3>
            <div id="cheat-cards-list"></div>
            <button class="cheat-button" id="add-all-cards">Usar todas as cartas</button>
        </div>
        <button class="cheat-button" id="apply-cheats">Aplicar Cheats</button>
        <button class="cheat-button" id="reset-cheats">Resetar Cheats</button>
    </div>
    
    <!-- Menu de Conquistas -->
    <div id="badges-modal" class="ui-modal">
        <div class="modal-content">
            <button id="badges-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">×</button>
            <h2>CONQUISTAS</h2>
            <p>Desbloqueie badges completando desafios!</p>
            <div id="achievements-list"></div>
            <button class="modal-button" id="close-badges" style="margin-top: 20px;">Fechar</button>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div id="changelog-modal" class="ui-modal">
        <div class="modal-content">
            <button id="changelog-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">×</button>
            <h2>Notas de Atualização</h2>
            <div id="changelog-content">
                <h3>[v7.9] – Resgate e Liberação (Melhoria da Comunidade)</h3>
                <ul>
                    <li><strong>Sistema de Resgate de Inimigos Aprimorado:</strong> Atendendo ao feedback, o sistema anti-frustração foi redesenhado para ser mais dinâmico.
                        <ul>
                            <li>Agora, em vez de serem destruídos, os inimigos presos são puxados para o topo da tela e **imediatamente liberados** para atacar o jogador, garantindo que a ação nunca pare.</li>
                            <li>Inimigos são **totalmente vulneráveis a dano durante o processo de resgate**, corrigindo um bug que os tornava invulneráveis enquanto eram puxados.</li>
                            <li>A lógica de eliminação automática foi removida para favorecer uma experiência de jogo mais direta e focada no combate.</li>
                        </ul>
                    </li>
                    <li><strong>Atualização de Versão:</strong> A versão do jogo e do salvamento foi atualizada para `7.9` para incorporar as novas mudanças.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.8] – Sistema Anti-Frustração e Correções Gerais</h3>
                <ul>
                    <li><strong>Novo Sistema de Resgate de Inimigos:</strong> Implementado um novo sistema "Anti-Frustração" para evitar que partidas fiquem travadas.
                        <ul>
                            <li>Se 1 inimigo permanecer vivo por mais de 5 segundos sem sofrer dano, ele será puxado gradualmente para o topo da tela.</li>
                            <li>Se 2 inimigos permanecerem vivos por mais de 10 segundos sem sofrer dano, ambos serão puxados.</li>
                            <li>Uma vez na área de resgate, se o inimigo não for atingido em um novo intervalo de tempo (10s para 1 inimigo, 5s para 2 inimigos), ele será destruído automaticamente, permitindo que a onda prossiga.</li>
                            <li>Atacar um inimigo durante o processo de resgate cancela a ação e o devolve ao combate normal.</li>
                        </ul>
                    </li>
                    <li><strong>Correção de Bugs:</strong> Realizada uma revisão geral no código para corrigir pequenas inconsistências e melhorar a estabilidade, garantindo que as mecânicas das versões anteriores funcionem como esperado.</li>
                    <li><strong>Atualização do Save:</strong> O formato de salvamento foi atualizado para a v7.8. Dados de versões anteriores serão resetados para garantir compatibilidade com as novas mecânicas.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.7] – Correções Críticas e Aprimoramentos Visuais</h3>
                <ul>
                    <li><strong>Correção da Carta "Buraco Negro":</strong> O bug que fazia a carta "Buraco Negro" surgir no jogador em vez de no inimigo foi corrigido. Agora ela funciona conforme a descrição, criando um vórtice gravitacional no local do inimigo derrotado por acerto crítico, com todos os seus atributos (raio, duração, dano) escalando corretamente.</li>
                    <li><strong>Melhoria no Resgate de Inimigos:</strong> O sistema de resgate de "inimigos fantasma" foi aperfeiçoado. Agora, apenas inimigos comprovadamente fora da tela são resgatados. Em vez de serem eliminados, eles são puxados de forma gradual para o topo do cenário e sua IA é reativada para que voltem a ser uma ameaça, tornando o jogo mais justo e dinâmico.</li>
                    <li><strong>Reorganização da UI em Jogo:</strong> O cronômetro da partida agora tem uma posição central e dedicada no topo da tela. O painel de informações da partida foi movido para o canto superior direito para evitar sobreposição. O botão "Configurações" não aparece mais incorretamente durante as partidas.</li>
                    <li><strong>Aprimoramentos Visuais de Cartas:</strong> Diversas cartas receberam novos ou melhores efeitos visuais para que seu impacto seja mais claro, incluindo rastros de fogo para "Catalisador", projéteis translúcidos para "Balas Fantasma", e outros polimentos que enriquecem a experiência de jogo.</li>
                    <li><strong>Verificação Geral de Funcionalidade:</strong> Foi realizada uma revisão completa para garantir que todas as cartas funcionam como descrito.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.6] – Polimento de Cartas e Correções de Gameplay</h3>
                <ul>
                    <li><strong>Reformulação da Carta "Buraco Negro":</strong> A carta lendária agora cria um buraco negro no local do inimigo derrotado por um acerto crítico, em vez de no jogador. O buraco negro puxa inimigos próximos e causa dano contínuo (5% da vida máxima a cada 0,5s). Acumular a carta aumenta a chance de criação, o raio, a duração, o dano e a frequência do dano.</li>
                    <li><strong>Melhorias Visuais e Dinâmicas em Todas as Cartas:</strong> Cada carta no jogo recebeu aprimoramentos em seus efeitos visuais e de jogabilidade para tornar cada escolha mais impactante e única. Exemplos incluem:
                        <ul>
                            <li><strong>Catalisador:</strong> Projéteis agora têm um rastro de fogo visível.</li>
                            <li><strong>Agilidade:</strong> Deixa um rastro de vento mais denso.</li>
                            <li><strong>Visão Apurada:</strong> Cria um pulso de foco visual no jogador.</li>
                            <li><strong>Balas Fantasma:</strong> Projéteis ficam translúcidos.</li>
                            <li><strong>Ricochete:</strong> Projéteis mudam de cor e buscam inimigos após ricochetear.</li>
                            <li>E muitas outras melhorias em todas as raridades!</li>
                        </ul>
                    </li>
                    <li><strong>Correção do "Inimigo Fantasma":</strong> Implementado um sistema de segurança para lidar com inimigos que ficam presos fora da tela. Se 1 a 3 inimigos restarem por mais de 3 segundos, eles são movidos para o centro da tela. Se não sofrerem dano por mais 10 segundos, são eliminados automaticamente, permitindo que a onda prossiga.</li>
                    <li><strong>Correção da Função "Reiniciar Partida":</strong> Reiniciar uma partida agora cria uma nova instância de jogo de forma limpa, usando as mesmas configurações (Herói, Dificuldade, etc.) da partida anterior, sem causar aceleração ou outros bugs. As escolhas aleatórias (🎲) são mantidas.</li>
                    <li><strong>Redução do Intervalo entre Ondas:</strong> O tempo de espera entre as ondas foi reduzido de 5 para 2 segundos, tornando o ritmo do jogo mais rápido e dinâmico.</li>
                    <li><strong>Melhoria no Menu de Informações:</strong> As descrições de todas as cartas, inimigos e mecânicas no menu de informações foram expandidas para serem significativamente mais detalhadas e explicativas.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.5] – Estabilidade e Correções de Bugs Críticos</h3>
                <ul>
                    <li><strong>Correção de Bug Crítico (Reinício):</strong> Resolvido um bug grave que causava a aceleração do jogo a cada vez que a partida era reiniciada pelo menu de pausa. O estado do jogo agora é reiniciado corretamente.</li>
                    <li><strong>Correção de Bug Crítico (Controles Mobile):</strong> Corrigido um bug que impedia o funcionamento dos joysticks e o movimento do personagem ao escolher o modo "Celular".</li>
                    <li><strong>Correção de UI:</strong> O painel de informações da partida (Herói, Dificuldade, etc.) agora é exibido corretamente desde o início do jogo, sem a necessidade de reiniciar.</li>
                    <li><strong>Melhoria na Lógica de Conquistas:</strong> Aprimorada a lógica de desbloqueio de certas conquistas de progressão para garantir que sejam concedidas de forma mais confiável.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.4] – Melhorias de UX e Gameplay</h3>
                <ul>
                    <li><strong>Novo Fluxo de Seleção:</strong> As telas de seleção de Herói e Dificuldade agora iniciam com a opção do meio pré-selecionada, agilizando o início do jogo.</li>
                    <li><strong>Opção "Aleatório 🎲":</strong> Adicionada uma nova opção de seleção "Aleatório" para Herói, Dificuldade e Modo de Jogo, para quem gosta de surpresas.</li>
                    <li><strong>Confirmação de Modo:</strong> A tela de seleção de Modo de Jogo agora possui um botão "Selecionar Modo" para iniciar a partida, evitando inícios acidentais.</li>
                    <li><strong>Informações em Jogo:</strong> Um novo painel de UI exibe o Herói, Dificuldade, Modo e Dispositivo escolhidos durante a partida.</li>
                    <li><strong>Melhoria nos Recordes:</strong> O Histórico de Partidas agora registra e exibe o Herói, o Dispositivo e se alguma das escolhas foi feita de forma aleatória.</li>
                    <li><strong>Escolha Aleatória de Cartas:</strong> Adicionado um botão "🎲 Escolha aleatória" na tela de aprimoramento para selecionar uma das cartas disponíveis ao acaso.</li>
                    <li><strong>Menus de Confirmação:</strong> Implementados modais de confirmação para as opções "Reiniciar Partida" e "Voltar ao Menu" na tela de pausa, evitando ações acidentais.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.3] – Chefes Temáticos e Melhorias Gerais</h3>
                <ul>
                    <li><strong>Chefes Temáticos:</strong> Cada cenário temático (Neve, Deserto, Floresta, etc.) agora possui um Chefe único com habilidades e visuais exclusivos, que aparece a cada 5 ondas, aumentando a variedade dos desafios.</li>
                    <li><strong>Transição de Cenário Aprimorada:</strong> A mudança de tema durante o jogo agora acontece de forma gradual, com uma transição de cores suave, tornando a experiência mais imersiva.</li>
                    <li><strong>Rebalanceamento das Melhorias Permanentes:</strong> Os bônus de Vida, Dano, Moedas e Sorte foram significativamente aumentados para que a progressão seja mais impactante e recompensadora.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.2] – Cosméticos, Inimigos e Cenários</h3>
                <ul>
                    <li><strong>Expansão de Cosméticos:</strong> Adicionados mais de 20 novos itens cosméticos, incluindo chapéus, rostos, cores, gradientes e formas.</li>
                    <li><strong>Novos Tipos de Inimigos:</strong> Introduzidos 5 novos inimigos com habilidades únicas.</li>
                    <li><strong>Cenários Temáticos:</strong> A cada 5 ondas, o visual do jogo muda, ciclando entre 10 temas de cores diferentes.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.1] – +30 Conquistas e Novas Opções Gráficas</h3>
                <ul>
                    <li><strong>Sistema de Conquistas Expandido:</strong> Adicionadas mais de 30 novas conquistas.</li>
                    <li><strong>Configurações Gráficas Avançadas:</strong> O menu de configurações agora inclui mais opções para customizar a experiência visual.</li>
                </ul>
                <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v7.0] – UI de dificuldade e modos</h3>
                <ul>
                    <li><strong>Novos Menus de Seleção:</strong> Adicionados menus para escolher a Dificuldade e o Modo de Jogo.</li>
                </ul>
                 <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v6.9] – Rebalanceamento e +10 cartas</h3>
                <ul>
                    <li><strong>Rebalanceamento Geral:</strong> Muitas cartas baseadas em porcentagem foram rebalanceadas.</li>
                    <li><strong>+10 Novas Cartas:</strong> Adicionadas 10 novas cartas com mecânicas únicas.</li>
                </ul>
                 <hr style="margin: 20px 0; border-color: #4a5a9a;">
                <h3>[v6.8] - Recordes e Revisão do Menu</h3>
                <ul>
                    <li><strong>Novo Sistema de Recordes.</strong></li>
                    <li><strong>Revisão do Menu Principal.</strong></li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Menu de Configurações -->
    <div id="settings-modal" class="ui-modal">
        <div class="modal-content">
            <button id="settings-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">×</button>
            <h2>CONFIGURAÇÕES</h2>

            <div class="setting-option" style="flex-direction: column; align-items: stretch; border-bottom: none;">
                <label style="margin-bottom: 10px; text-align: center; color: #ffcc00;">Presets Gráficos</label>
                <div class="graphics-presets">
                    <button class="preset-button" id="preset-low">Baixo</button>
                    <button class="preset-button" id="preset-medium">Médio</button>
                    <button class="preset-button" id="preset-high">Alto</button>
                </div>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            
            <div class="setting-option">
                <label>Sombras</label>
                <input type="checkbox" id="shadows-setting" checked>
            </div>
            <div class="setting-option">
                <label>Efeitos de Sangue</label>
                <input type="checkbox" id="blood-setting" checked>
            </div>
             <div class="setting-option">
                <label>Tremor de Tela</label>
                <input type="range" id="screenshake-intensity" min="0" max="10" value="8">
            </div>
            <div class="setting-option">
                <label>Intensidade de Partículas</label>
                <input type="range" id="particle-intensity" min="0" max="10" value="7">
            </div>
            <div class="setting-option">
                <label>Intensidade de Rastros</label>
                <input type="range" id="trail-intensity" min="0" max="10" value="7">
            </div>
            <div class="setting-option">
                <label>Intensidade Efeitos de Cartas</label>
                <input type="range" id="card-effect-intensity" min="0" max="10" value="8">
            </div>

            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                <label>Estilo do Nametag</label>
                <select id="nametag-style">
                    <option value="simple">Simples</option>
                    <option value="background">Com Fundo</option>
                </select>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                <label style="color: #ff5555; font-weight: bold;">Ativar Recursos de Cheat</label>
                <input type="checkbox" id="cheat-features-setting">
            </div>
            <div id="cheat-settings-container" style="display: none; padding-left: 20px; border-left: 2px solid #ff5555; margin-top: 10px;">
                <div class="setting-option">
                    <label>Definir Moedas:</label>
                    <input type="number" id="set-coins-input" style="width: 120px;">
                </div>
                 <div class="setting-option">
                    <label>Desbloquear Conquistas:</label>
                    <button class="cheat-button" id="unlock-all-achievements-btn" style="width: auto; margin-top:0;">Desbloquear</button>
                </div>
                 <div class="setting-option">
                    <label>Maximizar Melhorias:</label>
                    <button class="cheat-button" id="max-all-upgrades-btn" style="width: auto; margin-top:0;">Maximizar</button>
                </div>
            </div>
            <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
            <div class="setting-option">
                 <label style="color: #f44336; font-weight: bold;">Apagar Dados do Jogo</label>
                 <button class="modal-button delete-data-button" id="delete-data-btn">Apagar Dados</button>
            </div>

            <button class="modal-button" id="apply-settings" style="margin-top: 20px;">Aplicar e Fechar</button>
        </div>
    </div>
    
    <!-- MODAIS DO JOGO -->

    <!-- 1. Nickname Modal -->
    <div id="nickname-modal" class="ui-modal">
        <div class="modal-content">
            <h1 class="game-title">CubeChaos</h1>
            <div id="splash-text-nickname"></div>
            <h2>Defina seu Nickname</h2>
            <p>Seu nome de guerra para enfrentar as hordas!</p>
            <input type="text" id="nickname-input" placeholder="Entre 3 e 12 caracteres" maxlength="12">
            <div id="nickname-error"></div>
            <button id="confirm-nickname-button" class="modal-button">Confirmar</button>
        </div>
    </div>
    
    <!-- 2. Main Menu Modal -->
    <div id="main-menu-modal" class="ui-modal">
        <div class="modal-content">
            <div class="main-menu-layout">
                <!-- Painel Esquerdo (Ações) -->
                <div class="main-menu-left-panel">
                    <h1 class="game-title">CubeChaos</h1>
                    <div id="main-menu-nickname"></div>
                    <div id="main-menu-coins-display">Moedas: <span id="main-menu-coins-value">0</span></div>
                    
                    <button id="play-button" class="main-menu-button play-button">▶️ Iniciar</button>
                    <button id="customize-character-button" class="main-menu-button">🎨 Personalizar</button>
                    <button id="permanent-upgrades-button" class="main-menu-button">✨ Melhorias</button>
                    <button id="show-badges-main" class="main-menu-button">
                        🏆 Conquistas <span id="main-menu-achievement-counter" class="achievement-counter-badge"></span>
                    </button>
                </div>
                
                <!-- Painel Central (Preview) -->
                <div class="main-menu-center-panel">
                    <canvas id="characterPreviewCanvas" width="200" height="200"></canvas>
                </div>
                
                <!-- Painel Direito (Informações e Recordes) -->
                <div class="main-menu-right-panel">
                    <div id="best-record-display">
                        <h3>🏆 Melhor Recorde</h3>
                        <p>Onda: <span id="best-record-wave">--</span></p>
                        <p>Abates: <span id="best-record-kills">--</span></p>
                        <p>Tempo: <span id="best-record-time">--:--</span></p>
                    </div>
                    <button id="show-records-button" class="main-menu-button">📜 Histórico de Partidas</button>
                    <button id="show-info-button" class="main-menu-button">ℹ️ Informações</button>
                    <button id="tutorial-button" class="main-menu-button">📚 Tutorial</button>
                    <button id="show-settings" class="main-menu-button">⚙️ Configurações</button>
                    <button id="changelog-button" class="main-menu-button">📜 Changelog [v7.9]</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. Records Modal -->
    <div id="records-modal" class="ui-modal">
        <div class="modal-content">
            <button id="records-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">×</button>
            <h2>Histórico de Partidas</h2>
            <p>Sua jornada de sobrevivência registrada, da melhor para a pior.</p>
            <div id="records-list-container">
                <table id="records-table">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Herói</th>
                            <th>Dificuldade</th>
                            <th>Modo</th>
                            <th>Onda</th>
                            <th>Abates</th>
                            <th>Tempo</th>
                            <th>Dispositivo</th>
                        </tr>
                    </thead>
                    <tbody id="records-table-body"></tbody>
                </table>
            </div>
             <button class="modal-button" id="close-records" style="margin-top: 20px;">Fechar</button>
        </div>
    </div>

    <!-- 4. Info Modal -->
    <div id="info-modal" class="ui-modal">
        <div class="modal-content">
            <button id="info-close" class="cheat-button" style="position: absolute; top: 15px; right: 15px; width: auto; background: #f44336;">×</button>
            <h2>Informações do Jogo</h2>
             <div class="info-tabs">
                <button data-tab="info-cards" class="active">Cartas</button>
                <button data-tab="info-enemies">Inimigos</button>
                <button data-tab="info-scenarios">Cenários</button>
                <button data-tab="info-tech">Mecânicas</button>
                <button data-tab="info-controls">Controles</button>
            </div>
            <div id="info-content-panel"></div>
        </div>
    </div>

    <div id="customization-modal" class="ui-modal">
        <div class="modal-content">
            <button class="cheat-button" id="back-to-main-menu-from-customization" style="position: absolute; top: 15px; right: 15px; width: auto; background: #78909c;">Voltar</button>
            <h2>Personalizar Personagem</h2>
            <div id="customization-coins" style="text-align: right; margin-bottom: 15px; font-size: 1.2em; color: #ffcc00;">Moedas: 0</div>
            <div class="customization-container">
                <div class="customization-sections">
                    <div class="customization-tabs">
                        <button data-tab="shapes" id="shapes-tab-button" class="active">Formas</button>
                        <button data-tab="hats" id="hats-tab-button">Chapéus</button>
                        <button data-tab="colors" id="colors-tab-button">Cores</button>
                        <button data-tab="faces" id="faces-tab-button">Rostos</button>
                    </div>
                    <div id="shapes-options" class="customization-options-grid"></div>
                    <div id="hats-options" class="customization-options-grid" style="display: none;"></div>
                    <div id="colors-options" class="customization-options-grid" style="display: none;"></div>
                     <div id="faces-options" class="customization-options-grid" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="permanent-upgrades-modal" class="ui-modal">
        <div class="modal-content">
            <button class="cheat-button" id="back-to-main-menu-from-upgrades" style="position: absolute; top: 15px; right: 15px; width: auto; background: #78909c;">Voltar</button>
            <h2>Melhorias Permanentes</h2>
            <p>Use suas moedas para fortalecer seu personagem para sempre!</p>
            <div id="permanent-upgrades-coins" style="text-align: right; margin-bottom: 15px; font-size: 1.2em; color: #ffcc00;">Moedas: 0</div>
            
            <div class="permanent-upgrades-list" id="permanent-upgrades-list"></div>
        </div>
    </div>

    <!-- Modais de Seleção -->
    <div id="difficulty-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione a Dificuldade</h2>
            <p>A dificuldade afeta a força dos inimigos e os seus atributos.</p>
            <div class="character-selection" id="difficulty-selection-cards">
                <div class="character-card" data-difficulty="easy">
                    <div class="character-icon">😊</div>
                    <div class="character-name">Fácil</div>
                    <div class="character-description">Inimigos mais fracos, jogador mais forte. Ideal para aprender.</div>
                </div>
                <div class="character-card" data-difficulty="normal">
                    <div class="character-icon">😐</div>
                    <div class="character-name">Normal</div>
                    <div class="character-description">A experiência balanceada.</div>
                </div>
                <div class="character-card" data-difficulty="hard">
                    <div class="character-icon">😈</div>
                    <div class="character-name">Difícil</div>
                    <div class="character-description">Um verdadeiro desafio cósmico. Sem modificadores.</div>
                </div>
                <div class="character-card" data-difficulty="random">
                    <div class="character-icon">🎲</div>
                    <div class="character-name">Aleatório</div>
                    <div class="character-description">Deixe o caos decidir o seu destino.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-difficulty" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-difficulty" class="modal-button" disabled>Confirmar Dificuldade</button>
            </div>
        </div>
    </div>

    <div id="gamemode-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione o Modo de Jogo</h2>
            <p>Até onde você consegue chegar?</p>
            <div class="character-selection" id="gamemode-selection-cards">
                <div class="character-card" data-gamemode="waves">
                    <div class="character-icon">🏁</div>
                    <div class="character-name">100 Ondas</div>
                    <div class="character-description">Sobreviva a 100 ondas para alcançar a vitória.</div>
                </div>
                <div class="character-card" data-gamemode="infinite">
                    <div class="character-icon">♾️</div>
                    <div class="character-name">Infinito</div>
                    <div class="character-description">Sobreviva o máximo que puder. Não há fim.</div>
                </div>
                <div class="character-card" data-gamemode="random">
                    <div class="character-icon">🎲</div>
                    <div class="character-name">Aleatório</div>
                    <div class="character-description">Uma surpresa a cada partida.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-gamemode" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-gamemode" class="modal-button" disabled>Selecionar Modo</button>
            </div>
        </div>
    </div>

    <div id="device-selection-modal" class="ui-modal">
        <div class="modal-content">
            <h1>Como você quer jogar?</h1>
            <div id="device-choices">
                <button id="desktop-button" class="modal-button">🖥️ Computador</button>
                <button id="mobile-button" class="modal-button">📱 Celular</button>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-device" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
            </div>
        </div>
    </div>

    <div id="device-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Confirmar Dispositivo</h2>
            <p id="confirmation-text">Atenção: Após confirmar, esta escolha não poderá ser alterada nesta sessão.</p>
            <div id="device-choices">
                <button id="confirm-device-yes" class="modal-button">Sim, continuar</button>
                <button id="confirm-device-no" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Não, voltar</button>
            </div>
        </div>
    </div>
    
    <div id="delete-data-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #f44336;">Apagar Todos os Dados?</h2>
            <p>Esta ação é irreversível e irá apagar:</p>
            <ul style="list-style: none; padding: 10px; text-align: left; max-width: 300px; margin: 10px auto; background: rgba(0,0,0,0.2); border-radius: 5px;">
                <li>- Todas as Moedas</li>
                <li>- Todas as Conquistas</li>
                <li>- Todas as Melhorias Permanentes</li>
                <li>- Todos os Itens Cosméticos</li>
                <li>- Todo o Histórico de Partidas</li>
                <li>- Seu Nickname</li>
            </ul>
            <p>Você tem certeza?</p>
            <div class="selection-footer-buttons">
                <button id="confirm-delete-data-yes" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Sim, apagar dados</button>
                <button id="confirm-delete-data-no" class="modal-button">Não, manter dados</button>
            </div>
        </div>
    </div>

    <div id="cheat-features-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff5555;">Ativar Recursos de Cheat?</h2>
            <p>Ativar esta opção lhe dará acesso a configurações que podem alterar fundamentalmente a experiência de jogo. Use por sua conta e risco!</p>
            <div class="selection-footer-buttons">
                <button id="confirm-cheat-features-yes" class="modal-button">Sim, ativar</button>
                <button id="confirm-cheat-features-no" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Cancelar</button>
            </div>
        </div>
    </div>
    
    <div id="character-selection-modal" class="ui-modal">
        <div class="modal-content">
            <h2>Selecione seu Herói</h2>
            <p>Escolha um personagem com habilidades únicas</p>
            
            <div class="character-selection" id="character-selection-cards">
                <div class="character-card" data-character="warrior">
                    <div class="character-icon">🛡️</div>
                    <div class="character-name">Guardião</div>
                    <div class="character-description">+20% de vida, defesa aumentada</div>
                </div>
                
                <div class="character-card" data-character="archer">
                    <div class="character-icon">🏹</div>
                    <div class="character-name">Atirador</div>
                    <div class="character-description">+30% de velocidade de ataque</div>
                </div>
                
                <div class="character-card" data-character="mage">
                    <div class="character-icon">🔮</div>
                    <div class="character-name">Mago</div>
                    <div class="character-description">Habilidades especiais recarregam mais rápido</div>
                </div>
                <div class="character-card" data-character="random">
                    <div class="character-icon">🎲</div>
                    <div class="character-name">Aleatório</div>
                    <div class="character-description">Comece com um herói surpresa.</div>
                </div>
            </div>
            <div class="selection-footer-buttons">
                <button id="back-from-character" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%);">Voltar</button>
                <button id="confirm-character" class="modal-button" disabled>Confirmar Herói</button>
            </div>
        </div>
    </div>
    
    <div id="pause-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ffcc00;">JOGO PAUSADO</h2>
            <div style="display: flex; flex-direction: column; gap: 15px; align-items: center; margin-top: 30px;">
                 <button id="resume-game-button" class="modal-button">Retornar ao Jogo</button>
                 <button id="pause-restart-button" class="modal-button">Reiniciar Partida</button>
                 <button id="show-badges-pause" class="modal-button" style="background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%);">
                     🏆 Conquistas <span id="pause-menu-achievement-counter" class="achievement-counter-badge"></span>
                 </button>
                 <button id="return-to-menu-button" class="modal-button" style="background: linear-gradient(135deg, #ff9800 0%, #ef6c00 100%);">Voltar ao Menu</button>
            </div>
        </div>
    </div>

    <!-- Modais de Confirmação do Pause -->
    <div id="restart-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff9800;">Reiniciar Partida?</h2>
            <p>Todo o progresso desta partida será perdido.</p>
            <div class="selection-footer-buttons">
                <button id="confirm-restart-yes" class="modal-button" style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%);">Sim, Reiniciar Partida</button>
                <button id="confirm-restart-no" class="modal-button">Não, Manter Partida</button>
            </div>
        </div>
    </div>

    <div id="return-to-menu-confirmation-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #ff9800;">Voltar ao Menu Principal?</h2>
            <p>Sua partida atual será encerrada e os resultados salvos.</p>
            <div class="selection-footer-buttons">
                <button id="confirm-return-to-menu-yes" class="modal-button" style="background: linear-gradient(135deg, #ff9800 0%, #ef6c00 100%);">Voltar ao Menu</button>
                <button id="confirm-return-to-menu-no" class="modal-button">Permanecer no Jogo</button>
            </div>
        </div>
    </div>

    <div id="upgrade-modal" class="ui-modal">
        <div class="modal-content">
            <h2 style="color: #4caf50;">Nível Alcançado!</h2>
            <p>Escolha um aprimoramento:</p>
            <div id="upgrade-choices"></div>
            <div id="upgrade-modal-actions">
                <button id="roll-upgrades-button" class="modal-button" style="background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%); font-size: 1em;">Rolar (💰 50)</button>
                <button id="random-upgrade-button" class="modal-button" style="background: linear-gradient(135deg, #9c27b0 0%, #6a1b9a 100%); font-size: 1em;">🎲 Escolha aleatória</button>
                <button id="skip-upgrade-button" class="modal-button" style="background: linear-gradient(135deg, #78909C 0%, #455A64 100%); font-size: 1em;">Não pegar cartas</button>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen" class="ui-modal">
         <div class="modal-content">
            <h1 style="color: #f44336;">Fim de Jogo</h1>
            <h3 id="final-stats"></h3>
            <h3 id="game-over-details" style="color: #ccc; font-size: 1.1em;"></h3>
            <div class="meta-progression" style="margin: 20px 0;">
                <div class="progression-item">
                    <div class="progression-label">Onda Alcançada</div>
                    <div class="progression-value" id="final-wave">0</div>
                </div>
                <div class="progression-item">
                    <div class="progression-label">Inimigos Derrotados</div>
                    <div class="progression-value" id="final-kills">0</div>
                </div>
                 <div class="progression-item">
                    <div class="progression-label">XP Total</div>
                    <div class="progression-value" id="final-xp">0</div>
                </div>
                <div class="progression-item">
                    <div class="progression-label">Moedas Ganhas</div>
                    <div class="progression-value" id="final-coins">0</div>
                </div>
            </div>
            <button id="return-to-menu-from-gameover" class="modal-button">Voltar ao Menu Principal</button>
        </div>
    </div>
    
    <div id="victory-modal" class="ui-modal">
         <div class="modal-content" style="border-color: #ffd700; box-shadow: 0 0 50px #ffd700;">
            <h1 style="color: #ffd700;">VITÓRIA!</h1>
            <h2>Você conquistou o Caos Cósmico!</h2>
            <p>Você sobreviveu a 100 ondas e provou ser o maior guerreiro. Como recompensa, você ganhou 250 moedas extras e uma conquista lendária!</p>
            <button id="return-to-menu-from-victory" class="modal-button" style="background: linear-gradient(135deg, #ffc107 0%, #ffa000 100%);">Voltar ao Menu Principal</button>
        </div>
    </div>
    
    <div class="controls-hint" id="controls-hint"></div>
    
    <div id="tutorial-modal" class="tutorial-overlay" style="display: none;">
        <div class="tutorial-content">
            <h2 style="color: #4caf50; margin-bottom: 20px;">Tutorial do CubeChaos</h2>
            
            <div class="tutorial-section">
                <h3>Objetivo do Jogo</h3>
                <p>Sobreviva ao maior número possível de ondas de inimigos. Derrote inimigos, colete XP e escolha aprimoramentos para se tornar mais forte.</p>
            </div>
            
            <div class="tutorial-section">
                <h3>Controles</h3>
                <div class="tutorial-controls">
                    <div class="control-item">
                        <div class="control-icon">←→ / A/D</div>
                        <div>Movimento</div>
                    </div>
                    <div class="control-item">
                        <div class="control-icon">ESPAÇO</div>
                        <div>Pular</div>
                    </div>
                    <div class="control-item">
                        <div class="control-icon">🖱️ CLIQUE</div>
                        <div>Atirar</div>
                    </div>
                </div>
                 <p>Em dispositivos móveis, use os joysticks virtuais que aparecerão na tela.</p>
            </div>
            
            <div class="tutorial-section">
                <h3>Gameplay</h3>
                <p>• Colete orbes de XP para subir de nível e escolher novas cartas de aprimoramento.</p>
                <p>• Fique atento aos chefes a cada 5 ondas, eles são mais fortes e resistentes!</p>
                <p>• Use moedas ganhas nas partidas para comprar personalizações e melhorias permanentes no menu principal!</p>
            </div>
            
            <button id="close-tutorial" class="modal-button">Voltar</button>
        </div>
    </div>

<script>
// ===================================================================================
// 1. CONFIGURAÇÕES GLOBAIS E CONSTANTES AJUSTÁVEIS
// ===================================================================================
const CONFIG = {
    WIDTH: 1280, 
    HEIGHT: 720, 
    GRAVITY: 0.8,
    GROUND_SEGMENT_WIDTH: 8,
    GROUND_BASE_HEIGHT: 650,
    GROUND_ROUGHNESS: 0.015,
    GROUND_AMPLITUDE: 25,
    PLATFORM_COUNT: 7, 
    PLATFORM_WIDTH_MIN: 100,
    PLATFORM_WIDTH_MAX: 160,
    PLATFORM_HEIGHT: 20,
    PLATFORM_MIN_Y: 400, 
    PLATFORM_MAX_Y: 600, 
    PLATFORM_MIN_X_DIST: 180, 
    COLOR_ENEMY: '#f44336', 
    COLOR_PLAYER_PROJECTILE: '#ff9800', 
    COLOR_ENEMY_PROJECTILE: '#ff4081',
    STAR_COUNT: 400,
    PARTICLE_COUNT: 20,
    WAVE_SPAWN_COOLDOWN: 2000, 
    WAVE_ENEMY_MULTIPLIER: 1.5,
    COIN_DROP_CHANCE: 0.3, 
    WAVE_BONUS_COIN_MULTIPLIER: 2 
};

// Cores do Cenário (v7.2)
const THEMES = {
    default: { name: "Padrão Cósmico", boss_type: 'boss_default', bg: ['#0a0a2a', '#1a1a4a'], ground: '#3a4a5a', ground_top: '#4a5a6a', platform: '#5a6a8a' },
    city: { name: "Cidade Noturna", boss_type: 'boss_city', bg: ['#2c3e50', '#485563'], ground: '#34495e', ground_top: '#7f8c8d', platform: '#95a5a6' },
    snow: { name: "Pico Nevado", boss_type: 'boss_snow', bg: ['#e0eafc', '#cfdef3'], ground: '#ffffff', ground_top: '#bdc3c7', platform: '#ecf0f1' },
    forest: { name: "Floresta Densa", boss_type: 'boss_forest', bg: ['#134e5e', '#71b280'], ground: '#5c4033', ground_top: '#6b8e23', platform: '#8fbc8f' },
    aurora: { name: "Aurora Boreal", boss_type: 'boss_aurora', bg: ['#0f2027', '#2c5364'], ground: '#1d2b3a', ground_top: '#526b86', platform: '#3e517a' },
    space: { name: "Vazio Sideral", boss_type: 'boss_space', bg: ['#000000', '#434343'], ground: '#2d3436', ground_top: '#636e72', platform: '#b2bec3' },
    water: { name: "Praia Tropical", boss_type: 'boss_water', bg: ['#1c92d2', '#f2fcfe'], ground: '#f0e68c', ground_top: '#ffd700', platform: '#add8e6' },
    desert: { name: "Deserto Ardente", boss_type: 'boss_desert', bg: ['#ffc371', '#ff5f6d'], ground: '#d2b48c', ground_top: '#cdaa7d', platform: '#f0e68c' },
    flowers: { name: "Campo Florido", boss_type: 'boss_flowers', bg: ['#f8b500', '#fceabb'], ground: '#4caf50', ground_top: '#8bc34a', platform: '#ffc0cb' },
    cave: { name: "Caverna de Cristal", boss_type: 'boss_cave', bg: ['#302b63', '#24243e'], ground: '#4a4a4a', ground_top: '#6b6b6b', platform: '#808080' },
};
let currentTheme = THEMES.default;
let frameColors = { ...THEMES.default };
let themeTransition = { active: false, progress: 0, duration: 3000, from: null, to: null };


// Configurações visuais
const VISUAL_SETTINGS = {
    shadows: true,
    blood: true,
    screenShakeIntensity: 8,
    particleIntensity: 7,
    trailIntensity: 7,
    cardEffectIntensity: 8,
    nametagStyle: 'simple',
    cheatFeaturesEnabled: false,
};

// ===================================================================================
// 1.5. CUSTOMIZATION & METAPROGRESSION DATA
// ===================================================================================
let PLAYER_CUSTOMIZATION = {
    nickname: 'Jogador',
    ownedShapes: ['shape_square'],
    ownedHats: ['hat_none'],
    ownedColors: ['color_green_default'],
    ownedFaces: ['face_zero', 'face_smile'], 
    equippedShape: 'shape_square',
    equippedHat: 'hat_none',
    equippedColor: 'color_green_default',
    equippedFace: 'face_zero', 
};

let PLAYER_PERMANENT_UPGRADES = {}; 
let PLAYER_RECORDS = [];

// Funções de desenho para formas
function drawShapeSquare(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }
function drawShapeCircle(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x + w/2, y + h/2, Math.min(w,h)/2, 0, Math.PI * 2); ctx.fill(); }
function drawShapeTriangle(ctx, x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x + w, y + h); ctx.lineTo(x, y + h); ctx.closePath(); ctx.fill(); }
function drawShapeStar(ctx, cx_offset, cy_offset, w, h, color) { 
    const spikes = 5, outerRadius = Math.min(w,h) / 2, innerRadius = outerRadius / 2;
    const cx = cx_offset + w/2, cy = cy_offset + h/2;
    let rot = Math.PI / 2 * 3, cur_x = cx, cur_y = cy, step = Math.PI / spikes;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        cur_x = cx + Math.cos(rot) * outerRadius; cur_y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(cur_x, cur_y); rot += step;
        cur_x = cx + Math.cos(rot) * innerRadius; cur_y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(cur_x, cur_y); rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
}
function drawShapePentagon(ctx, x, y, w, h, color) {
    const radius = Math.min(w, h) / 2; const cx = x + w / 2; const cy = y + h / 2;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
    for (let i = 1; i <= 5; i++) { ctx.lineTo(cx + radius * Math.cos(i * 2 * Math.PI / 5), cy + radius * Math.sin(i * 2 * Math.PI / 5)); }
    ctx.closePath(); ctx.fill();
}
function drawShapeHexagon(ctx, x, y, w, h, color) {
    const radius = Math.min(w, h) / 2; const cx = x + w / 2; const cy = y + h / 2;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx + radius, cy);
    for (let i = 1; i <= 6; i++) { ctx.lineTo(cx + radius * Math.cos(i * Math.PI / 3), cy + radius * Math.sin(i * Math.PI / 3)); }
    ctx.closePath(); ctx.fill();
}
function drawShapeGear(ctx, x, y, w, h, color) {
    const spikes = 8, outerRadius = Math.min(w,h) / 2, innerRadius = outerRadius * 0.7;
    const cx = x + w/2, cy = y + h/2; let rot = 0;
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(cx, cy);
    for (let i = 0; i < spikes; i++) {
        rot = i * 2 * Math.PI / spikes;
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
        rot += Math.PI / (spikes * 2);
        ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
        rot += Math.PI / (spikes * 2);
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
    }
    ctx.closePath(); ctx.fill();
}
function drawShapeCross(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; const armWidth = w / 3;
    ctx.fillRect(x + armWidth, y, armWidth, h); ctx.fillRect(x, y + armWidth, w, armWidth);
}
function drawShapeDiamond(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x + w / 2, y); ctx.lineTo(x + w, y + h / 2);
    ctx.lineTo(x + w / 2, y + h); ctx.lineTo(x, y + h / 2); ctx.closePath(); ctx.fill();
}
function drawShapeHeart(ctx, x, y, w, h, color) {
    ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(x + w / 2, y + h / 4); ctx.arc(x + w / 4, y + h / 4, w / 4, 0, Math.PI, true);
    ctx.arc(x + w * 3 / 4, y + h / 4, w / 4, 0, Math.PI, true); ctx.lineTo(x + w / 2, y + h);
    ctx.closePath(); ctx.fill();
}
function drawShapeCapsule(ctx, x, y, w, h, color) {
    const r = h / 2; ctx.fillStyle = color; ctx.beginPath();
    ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.arc(x + w - r, y + r, r, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(x + r, y + h); ctx.arc(x + r, y + r, r, Math.PI / 2, -Math.PI / 2); ctx.closePath(); ctx.fill();
}

function drawHatEmoji(ctx, playerX, playerY, playerW, playerH, emoji) {
    if (!emoji || emoji === "🚫") return;
    const hatSize = playerW * 0.7; ctx.font = `${hatSize}px Arial`; 
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const hatX = playerX + playerW / 2; const hatY = playerY - playerH * 0.1;
    ctx.fillText(emoji, hatX, hatY);
}
function drawPlayerFace(ctx, playerX, playerY, playerW, playerH, faceText, faceColor, facingDirection) {
    if (!faceText) return;
    ctx.fillStyle = faceColor;
    const baseFontSize = playerH * 0.25;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const lines = faceText.split('|');
    const lineHeight = baseFontSize * (lines.length > 1 ? 0.8 : 1);
    ctx.font = `bold ${lineHeight}px 'Courier New', monospace`;
    const totalTextHeight = lines.length * lineHeight;
    let startY = playerY + playerH / 2 - totalTextHeight / 2 + lineHeight / 2;
    const horizontalOffset = playerW * 0.05 * facingDirection;
    lines.forEach((line, index) => {
        ctx.fillText(line, playerX + playerW / 2 + (line.length === 1 ? horizontalOffset : 0) , startY + index * lineHeight);
    });
}

const SHAPES_CATALOG = [
    { id: 'shape_square', name: 'Quadrado', price: 0, asset: drawShapeSquare },
    { id: 'shape_circle', name: 'Círculo', price: 200, asset: drawShapeCircle },
    { id: 'shape_triangle', name: 'Triângulo', price: 200, asset: drawShapeTriangle },
    { id: 'shape_star', name: 'Estrela', price: 500, asset: drawShapeStar },
    { id: 'shape_diamond', name: 'Diamante', price: 600, asset: drawShapeDiamond },
    { id: 'shape_capsule', name: 'Cápsula', price: 600, asset: drawShapeCapsule },
    { id: 'shape_heart', name: 'Coração', asset: drawShapeHeart, unlockAchievement: 'heart_shape_unlock' },
    { id: 'shape_pentagon', name: 'Pentágono', asset: drawShapePentagon, unlockAchievement: 'pentagon_shape_unlock' },
    { id: 'shape_hexagon', name: 'Hexágono', asset: drawShapeHexagon, unlockAchievement: 'hexagon_shape_unlock' },
    { id: 'shape_gear', name: 'Engrenagem', asset: drawShapeGear, unlockAchievement: 'gear_shape_unlock' },
    { id: 'shape_cross', name: 'Cruz', asset: drawShapeCross, unlockAchievement: 'cross_shape_unlock' },
];

const HATS_CATALOG = [
    { id: 'hat_none', name: 'Nenhum', price: 0, emoji: "🚫" },
    { id: 'hat_party', name: 'Chapéu de Sol', price: 250, emoji: "👒" },
    { id: 'hat_tophat', name: 'Cartola', price: 250, emoji: "🎩" },
    { id: 'hat_crown', name: 'Coroa', price: 1000, emoji: "👑" },
    { id: 'hat_idea', name: 'Ideia', price: 300, emoji: "💭" },
    { id: 'hat_bell', name: 'Sino', price: 300, emoji: "🔔" },
    { id: 'hat_balloon', name: 'Balão', price: 400, emoji: "🎈" },
    { id: 'hat_clock', name: 'Relógio', price: 400, emoji: "⏰" },
    { id: 'hat_sleep', name: 'Soneca', emoji: "💤", unlockAchievement: 'sleep_hat_unlock' },
    { id: 'hat_question', name: 'Dúvida', emoji: "⁉️", unlockAchievement: 'question_hat_unlock' },
    { id: 'hat_bomb', name: 'Bombástico', emoji: "💣", unlockAchievement: 'bomb_hat_unlock' },
    { id: 'hat_moneybag', name: 'Magnata', emoji: "💰", unlockAchievement: 'money_face_unlock' },
    { id: 'hat_trophy', name: 'Campeão', emoji: "🏆", unlockAchievement: 'win_hard' },
    { id: 'hat_gamer', name: 'Gamer', emoji: "🕹", unlockAchievement: 'gamer_hat_unlock' },
    { id: 'hat_grad', name: 'Graduado', emoji: "🎓", unlockAchievement: 'grad_hat_unlock' },
    { id: 'hat_rescue', name: 'Resgate', emoji: "⛑", unlockAchievement: 'rescue_hat_unlock' },
    { id: 'hat_box', name: 'Caixa', emoji: "📦", unlockAchievement: 'box_hat_unlock' },
    { id: 'hat_books', name: 'Leitor', emoji: "📚", unlockAchievement: 'books_hat_unlock' },
    { id: 'hat_coffee', name: 'Cafeinado', emoji: "☕️", unlockAchievement: 'coffee_hat_unlock' },
];

const COLORS_CATALOG = [
    { id: 'color_green_default', name: 'Verde Padrão', price: 0, value: '#4caf50' },
    { id: 'color_red', name: 'Vermelho Fogo', price: 100, value: '#f44336' },
    { id: 'color_blue', name: 'Azul Celeste', price: 100, value: '#2196F3' },
    { id: 'color_yellow', name: 'Amarelo Solar', price: 100, value: '#FFEB3B' },
    { id: 'color_purple', name: 'Roxo Místico', price: 150, value: '#9C27B0' },
    { id: 'color_pink', name: 'Rosa Chiclete', price: 150, value: '#E91E63' },
    { id: 'color_cyan', name: 'Ciano', price: 120, value: '#00BCD4' },
    { id: 'color_orange', name: 'Laranja', price: 120, value: '#FF9800' },
    { id: 'color_lime', name: 'Lima', price: 120, value: '#CDDC39' },
    { id: 'color_indigo', name: 'Índigo', price: 180, value: '#3F51B5' },
    { id: 'color_teal', name: 'Verde-azulado', price: 180, value: '#009688' },
    { id: 'color_lava', name: 'Lava', value: ['#ff4800', '#ffb400'], unlockAchievement: 'lava_color_unlock' },
    { id: 'color_toxic', name: 'Tóxico', value: ['#7fff00', '#abff00'], unlockAchievement: 'toxic_color_unlock' },
    { id: 'color_ice', name: 'Gelo', value: ['#00ffff', '#ffffff'], unlockAchievement: 'ice_color_unlock' },
    { id: 'color_sunset', name: 'Pôr do Sol', value: ['#ff9800', '#f44336'], unlockAchievement: 'sunset_color_unlock' },
    { id: 'color_ocean', name: 'Oceano', value: ['#00BCD4', '#2196F3'], unlockAchievement: 'ocean_color_unlock' },
    { id: 'color_forest', name: 'Floresta', value: ['#4CAF50', '#8BC34A'], unlockAchievement: 'forest_color_unlock' },
    { id: 'color_aurora', name: 'Aurora', value: ['#9C27B0', '#00BCD4'], unlockAchievement: 'aurora_color_unlock' },
    { id: 'color_royal', name: 'Realeza', value: ['#673AB7', '#FFC107'], unlockAchievement: 'royal_color_unlock' },
    { id: 'color_void', name: 'Vazio', value: ['#212121', '#424242'], unlockAchievement: 'void_color_unlock' },
];

const FACES_CATALOG = [
    { id: 'face_zero', name: 'Zumbi', price: 0, text: "0_0" },
    { id: 'face_smile', name: 'Sorriso', price: 50, text: ":)" },
    { id: 'face_cat', name: 'Gatinho', price: 150, text: ":3" },
    { id: 'face_shrug', name: 'Indiferente', price: 250, text: "¯\\_ツ_/¯" },
    { id: 'face_kiss', name: 'Beijinho', price: 250, text: "^3^" },
    { id: 'face_lenny', name: 'Lenny', price: 500, text: "(͡°͜ʖ͡°)" },
    { id: 'face_bear', name: 'Ursinho', text: "ʕ•ᴥ•ʔ", unlockAchievement: 'bear_face_unlock' },
    { id: 'face_crying', name: 'Chorão', text: "T_T", unlockAchievement: 'crying_face_unlock' },
    { id: 'face_money', name: 'Milionário', text: "$o$", unlockAchievement: 'money_face_unlock' },
    { id: 'face_sad', name: 'Quase lá', text: ";-;", unlockAchievement: 'sad_face_unlock' },
    { id: 'face_uwu', name: 'Fofura', text: "UnU", unlockAchievement: 'uwu_face_unlock' },
    { id: 'face_dizzy', name: 'Tonto', text: "@q@", unlockAchievement: 'dizzy_face_unlock' },
    { id: 'face_rage', name: 'Fúria', text: ">0<", unlockAchievement: 'rage_face_unlock' },
    { id: 'face_error', name: 'Erro 404', text: "#-#", unlockAchievement: 'error_face_unlock' },
];

const PERMANENT_UPGRADES_CATALOG = {
    'perm_hp': { name: 'Vitalidade Cósmica', description: '+5% Vida Máxima base por nível.', maxLevel: 10, cost: (level) => 100 * Math.pow(level + 1, 1.6), effect: (level) => 1 + level * 0.05 },
    'perm_dmg': { name: 'Força Bruta', description: '+2.5% Dano base por nível.', maxLevel: 10, cost: (level) => 150 * Math.pow(level + 1, 1.7), effect: (level) => 1 + level * 0.025 },
    'perm_coins': { name: 'Sorte do Magnata', description: '+4% Moedas ganhas por nível.', maxLevel: 10, cost: (level) => 200 * Math.pow(level + 1, 1.5), effect: (level) => 1 + level * 0.04 },
    'perm_luck': { name: 'Olho de Lince', description: '+1% Chance de crítico base por nível.', maxLevel: 5, cost: (level) => 500 * Math.pow(level + 1, 1.9), effect: (level) => 0 + level * 0.01 },
};


const SPLASH_TEXTS = [
    "Agora com mais polígonos!",
    "Cuidado com os chefes!",
    "Colete todas as cartas!",
    "Não é um bug, é uma feature!",
    "Tente sobreviver!",
    "100% mais dinâmico!",
    "Experimente as melhorias permanentes!",
    "Visite o GitHub!",
    "Pressione P para pausar... Ah, não, é um botão!",
    "Mais de 4 lados!",
    "Splash text!",
];

// ===================================================================================
// 2. BANCO DE DADOS DE CONTEÚDO (UPGRADES, INIMIGOS E CONQUISTAS)
// ===================================================================================
const UPGRADES = {
    // COMMON
    'Catalyst': { name: 'Catalisador', description: 'Dano do Projétil +2. Adiciona uma aura de fogo.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.projectileDamage += 2; p.stats.catalyst.stacks++; }, scaling: 'Dano base do projétil aumenta em 2. A aura de fogo ao redor do jogador e o rastro de fogo dos projéteis se tornam mais intensos.' },
    'Growth': { name: 'Crescimento', description: 'Vida Máxima +10. Deixa um leve rastro verde.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.maxHp += 10; p.hp += 10; p.stats.growth.stacks++; }, scaling: 'Aumenta a Vida Máxima em 10. O jogador cresce ligeiramente em tamanho e o rastro de partículas verdes se torna mais denso.' },
    'Swift': { name: 'Agilidade', description: 'Velocidade de Movimento +5%. Deixa um rastro de vento.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.moveSpeed += (p.baseStats.moveSpeed * 0.05); p.stats.swift.stacks++; }, scaling: 'Aumenta a velocidade de movimento em 5% do valor base. O rastro de "vento" (partículas brancas) deixado ao se mover fica mais longo e espesso.' },
    'Resonance': { name: 'Ressonância', description: 'Velocidade de Ataque +8%. Deixa um rastro fantasma.', rarity: 'common', maxStacks: 50, apply: p => { p.stats.attackSpeed *= 0.92; p.stats.resonance.stacks++; }, scaling: 'Reduz o tempo de recarga do ataque em 8% (multiplicativo). O número de "fantasmas" (imagens residuais) que seguem o jogador aumenta.' },
    'Renew': { name: 'Renovação', description: 'Cura 25% da vida máxima instantaneamente.', rarity: 'common', maxStacks: 50, apply: p => { const healAmount = p.stats.maxHp * 0.25; p.hp = Math.min(p.stats.maxHp, p.hp + healAmount); if(VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(p.x + p.width/2, p.y + p.height/2, 30, 'lightgreen')); }, scaling: 'Cura instantaneamente 25% da sua Vida Máxima atual. O efeito visual da cura se torna mais forte a cada uso.' },

    // UNCOMMON
    'Eyesight': { name: 'Visão Apurada', description: 'Chance de Crítico +5%. Gera um brilho de foco.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.critChance += 0.05; p.stats.eyesight.stacks++; }, scaling: 'Aumenta a chance de acerto crítico em 5%. Um pulso de luz amarela emana do jogador, com frequência e intensidade crescentes.' },
    'Gush': { name: 'Impulso', description: '+1 Pulo extra. O pulo solta mais partículas.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.maxJumps++; }, scaling: 'Adiciona um pulo extra. A explosão de partículas ao pular se torna maior e mais colorida.' },
    'Charge': { name: 'Carga', description: 'Tamanho do Projétil +15%.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.projectileSize *= 1.15; }, scaling: 'Aumenta o tamanho dos projéteis em 15% (multiplicativo). O projétil se torna visivelmente maior.' },
    'Leech': { name: 'Sanguessuga', description: 'Concede 5% de Roubo de Vida, com efeito visual.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.lifesteal += 0.05; }, scaling: 'Converte 5% do dano causado em cura. Partículas vermelhas visíveis viajam do inimigo atingido de volta para o jogador.' },
    'Magnetic Field': { name: 'Campo Magnético', description: 'Aumenta o raio de atração de XP. O campo se torna visível.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.magneticField.range += 20; }, scaling: 'Aumenta o raio de coleta de XP e moedas em 20. Um anel azul translúcido ao redor do jogador indica a área de atração, e ele se expande a cada acúmulo.' },
    'MultiShot': { name: 'Tiro Múltiplo', description: 'Adiciona +1 projétil. A "arma" brilha mais forte.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.projectileCount++; }, scaling: 'Adiciona um projétil extra a cada disparo, em um pequeno leque. Um brilho na ponta da "arma" do jogador fica mais intenso.' },
    'GhostBullets': { name: 'Balas Fantasma', description: 'Projéteis têm 10% de chance de atravessar paredes. Aumenta a chance.', rarity: 'uncommon', maxStacks: 50, apply: p => { p.stats.ghostBullets.enabled = true; p.stats.ghostBullets.chance += 0.1; }, scaling: 'Concede 10% de chance de um projétil se tornar "fantasma" e atravessar paredes. Projéteis fantasmas são translúcidos e deixam um rastro etéreo.' },

    // RARE
    'Precision': { name: 'Precisão', description: 'Dano Crítico +25%. Acertos críticos são maiores e mais brilhantes.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.critDamage += 0.25; }, scaling: 'Aumenta o multiplicador de dano crítico em 25%. Projéteis críticos se tornam maiores e a explosão de partículas no impacto é mais violenta.' },
    'Rage': { name: 'Fúria', description: 'Dano aumenta em 50% com vida baixa. Uma aura vermelha pulsa.', rarity: 'rare', maxStacks: 1, apply: p => { p.stats.rage.enabled = true; }, scaling: 'Quando sua vida está abaixo de 30%, você ganha 50% de dano adicional. Uma aura vermelha pulsante e agressiva aparece ao redor do jogador. Não acumula.' },
    'Barrier': { name: 'Barreira', description: 'Um escudo bloqueia o próximo dano. Recarga -5%.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.barrier.enabled = true; p.stats.barrier.cooldown *= 0.95; }, scaling: 'Cria uma barreira que bloqueia um ataque. A recarga diminui em 5% (multiplicativo). Uma esfera ciano visível protege o jogador quando a barreira está ativa.' },
    'Appraisal': { name: 'Avaliação', description: '+1 opção de upgrade ao subir de nível.', rarity: 'rare', maxStacks: 1, apply: p => { p.stats.upgradeChoices++; }, scaling: 'Aumenta o número de escolhas de cartas ao subir de nível de 3 para 4. Não acumula.' },
    'Blood Ritual': { name: 'Ritual Sanguíneo', description: 'Inimigos têm +5% de chance de soltar um orbe de cura.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.bloodRitual.chance += 0.05; }, scaling: 'Adiciona 5% de chance de inimigos derrotados deixarem um orbe de cura (verde). A chance aumenta a cada acúmulo.' },
    'FrostNova': { name: 'Nova Congelante', description: 'Ao ser atingido, libera uma onda congelante. Aumenta a duração.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.frostNova.enabled = true; p.stats.frostNova.duration += 200; }, scaling: 'Ao sofrer dano, emite uma onda que congela inimigos próximos. A duração do congelamento aumenta em 200ms. O efeito visual da explosão de gelo se torna maior.' },
    'VampiricExplosion': { name: 'Explosão Vampírica', description: 'Inimigos derrotados têm 10% de chance de explodir, curando você em 2% da vida máxima.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.vampiricExplosion.enabled = true; p.stats.vampiricExplosion.chance += 0.10; p.stats.vampiricExplosion.healPercent += 0.02; }, scaling: 'Adiciona 10% de chance de inimigos explodirem em energia vampírica, curando 2% da sua vida máxima. A chance e a cura aumentam a cada acúmulo.' },
    'ShockwaveJump': { name: 'Salto Trovejante', description: 'Ao aterrissar, cria uma onda de choque que causa 5 de dano. Aumenta o dano e o raio.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.shockwaveJump.enabled = true; p.stats.shockwaveJump.damage += 5; p.stats.shockwaveJump.radius += 10; }, scaling: 'Cria uma onda de choque visível ao aterrissar. Dano aumenta em 5 e o raio em 10.' },
    'GravityWell': { name: 'Poço Gravitacional', description: 'Projéteis têm 10% de chance de criar um pequeno poço gravitacional ao atingir um inimigo.', rarity: 'rare', maxStacks: 50, apply: p => { p.stats.gravityWell.enabled = true; p.stats.gravityWell.chance += 0.1; }, scaling: 'Adiciona 10% de chance de um projétil criar um vórtice roxo que puxa inimigos próximos. Acúmulos aumentam a chance.' },
    
    // EPIC
    'LaserPet': { name: 'Pet de Combate', description: 'Invoca um pet que atira. Aumenta o dano do pet.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.laserPet.count = Math.min(6, (p.upgrades['LaserPet'] || 0) + 1); p.stats.laserPet.damage += 2; }, scaling: 'Invoca um pet orbital rosa que atira nos inimigos. Adiciona +1 pet e +2 de dano por carta, até um máximo de 6 pets.' },
    'Fragmentation+': { name: 'Fragmentação+', description: 'Inimigos explodem em +1 projétil ao morrer.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.fragmentation.enabled = true; p.stats.fragmentation.count += 1; }, scaling: 'Inimigos derrotados explodem em uma rajada de projéteis teleguiados. Adiciona +1 projétil à explosão.' },
    'Piercing': { name: 'Perfuração', description: 'Projéteis atravessam +1 inimigo.', rarity: 'epic', maxStacks: 50, apply: p => {p.stats.piercing.enabled = true; p.stats.piercing.hits++;}, scaling: 'Permite que seus projéteis atravessem um inimigo adicional. O projétil deixa um rastro de dano visível através dos inimigos perfurados.' },
    'Ricochet': { name: 'Ricochete', description: '+1 rebote para os projéteis. Eles mudam de cor ao ricochetear.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.ricochet.enabled = true; p.stats.ricochet.maxBounces++; }, scaling: 'Permite que seus projéteis ricocheteiem nas paredes. Adiciona +1 ricochete. Após ricochetear, o projétil muda de cor para ciano e busca o inimigo mais próximo.' },
    'TempAlliance': { name: 'Aliança Temporária', description: '+5% de chance de converter inimigos. Aliados duram mais.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.tempAlliance.chance += 0.05; p.stats.tempAlliance.duration += 100; }, scaling: 'Adiciona 5% de chance de converter um inimigo derrotado para lutar ao seu lado. A duração do aliado aumenta em 100ms. Aliados convertidos brilham em verde.' },
    'OrbitalShield': { name: 'Escudo Orbital', description: 'Cria um escudo orbital. Adiciona +1 a cada 3 níveis.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.orbitalShield.count = Math.floor((p.upgrades['OrbitalShield'] || 0) / 3) + 1; p.stats.orbitalShield.speed += 0.1; }, scaling: 'Cria um escudo ciano que orbita você e destrói projéteis inimigos. A cada 3 acúmulos, um novo escudo é adicionado e a velocidade de rotação aumenta.' },
    'SingularityCore': { name: 'Núcleo de Singularidade', description: 'Emite um pulso de energia a cada 4 segundos, causando dano. Aumenta o dano e diminui o tempo.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.singularityCore.enabled = true; p.stats.singularityCore.damage += 8; p.stats.singularityCore.cooldown = Math.max(500, p.stats.singularityCore.cooldown * 0.95); }, scaling: 'Emite um pulso de energia roxa ao seu redor. Dano aumenta em 8 e a recarga diminui em 5% (multiplicativo).' },
    'HolyRetribution': { name: 'Retribuição Divina', description: 'Ao ser atingido, invoca 2 raios de luz vingativos sobre inimigos aleatórios.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.holyRetribution.enabled = true; p.stats.holyRetribution.count += 2; }, scaling: 'Ao sofrer dano, raios de luz dourada caem do céu sobre os inimigos. Adiciona 2 raios por acúmulo.' },
    'MirageClones': { name: 'Clones de Miragem', description: 'A cada 10 segundos, cria 1 clone que atrai o fogo inimigo. Aumenta o número de clones.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.mirageClones.enabled = true; p.stats.mirageClones.count += 1; }, scaling: 'Cria clones translúcidos de si mesmo que confundem os inimigos. Adiciona +1 clone por acúmulo.' },
    'OuroborosRounds': { name: 'Munição Ouroboros', description: 'Projéteis que não atingem nada por 2s têm 10% de chance de retornar a você.', rarity: 'epic', maxStacks: 50, apply: p => { p.stats.ouroborosRounds.enabled = true; p.stats.ouroborosRounds.chance += 0.1; }, scaling: 'Adiciona 10% de chance de projéteis perdidos retornarem, buscando o jogador. O projétil muda de cor ao iniciar o retorno.' },

    // LEGENDARY
    'Black Hole': { name: 'Buraco Negro', description: '+5% de chance em acerto crítico de criar um buraco negro.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.blackHole.enabled = true; p.stats.blackHole.chance += 0.05; p.stats.blackHole.radius += 10; p.stats.blackHole.duration += 500; p.stats.blackHole.damagePercent += 0.01; p.stats.blackHole.tickRate *= 0.95; }, scaling: 'Chance de +5% em acerto crítico de criar um buraco negro no inimigo. Aumenta raio (+10), duração (+0.5s), dano (+1% maxHP) e velocidade do dano (-5% intervalo).' },
    'Thunderbolt': { name: 'Relâmpago', description: 'A cada 5s, invoca +1 raio que atinge inimigos.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.thunderbolt.enabled = true; p.stats.thunderbolt.count++; }, scaling: 'A cada 5 segundos, um raio poderoso atinge um inimigo aleatório. Adiciona +1 raio por acúmulo.' },
    'GlassCannon': { name: 'Canhão de Vidro', description: '+100% de dano, -50% de vida máxima.', rarity: 'legendary', maxStacks: 1, apply: p => { p.stats.projectileDamage *= 2; p.stats.maxHp *= 0.5; p.hp = Math.min(p.hp, p.stats.maxHp); }, scaling: 'Dobra todo o seu dano, mas reduz sua vida máxima pela metade. Seu personagem fica com uma aparência rachada e translúcida. Não acumula.' },
    'ChainLightning': { name: 'Corrente de Raios', description: 'Projéteis têm +5% de chance de criar um raio para um inimigo próximo. +1 salto.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.chainLightning.enabled = true; p.stats.chainLightning.chance += 0.05; p.stats.chainLightning.bounces++; }, scaling: 'Adiciona 5% de chance de um projétil gerar uma corrente de raios que salta para outros inimigos. Adiciona +1 salto por acúmulo.' },
    'QuantumEntanglement': { name: 'Emaranhamento Quântico', description: 'O dano causado é compartilhado em 5% para até 2 outros inimigos aleatórios.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.quantumEntanglement.enabled = true; p.stats.quantumEntanglement.sharePercent += 0.05; p.stats.quantumEntanglement.targets += 1; }, scaling: 'Compartilha 5% do dano com 1 alvo adicional. Vínculos de energia roxa conectam os inimigos afetados. A porcentagem de dano e o número de alvos aumentam.' },
    'TimeWarp': { name: 'Dobra Temporal', description: 'Acertos críticos têm 10% de chance de desacelerar todos os inimigos em 50% por 2s.', rarity: 'legendary', maxStacks: 50, apply: p => { p.stats.timeWarp.enabled = true; p.stats.timeWarp.chance += 0.1; }, scaling: 'Adiciona 10% de chance de acertos críticos ativarem uma desaceleração global do tempo. Um filtro azul e distorção visual aparecem na tela durante o efeito.' },
};
const ORIGINAL_UPGRADES = JSON.parse(JSON.stringify(UPGRADES)); // For resetting max stacks

const ENEMY_TYPES = {
    // Minions
    'grunt': { name: 'Soldado', hp: 10, speed: 2, size: 30, color: '#f44336', attackCooldown: 2500, behavior: 'standard', expValue: 1, description: 'A unidade básica do exército inimigo. Fraco individualmente, mas perigoso em grandes números. Ataca o jogador diretamente.' },
    'grunt_mini': { name: 'Soldado Mini', hp: 5, speed: 2.5, size: 15, color: '#ff7961', attackCooldown: 2500, behavior: 'standard', expValue: 0, description: 'Um fragmento menor e mais rápido de um inimigo maior. Não concede experiência.' },
    'tank': { name: 'Tanque', hp: 50, speed: 1, size: 50, color: '#d32f2f', attackCooldown: 4000, behavior: 'standard', expValue: 3, description: 'Lento, mas extremamente resistente. Seu corpo retangular é projetado para absorver dano e proteger unidades mais fracas atrás dele.' },
    'shooter': { name: 'Atirador', hp: 15, speed: 1.5, size: 35, color: '#ff8a80', attackCooldown: 1500, behavior: 'standard', expValue: 2, description: 'Mantém distância do jogador e dispara projéteis de um cano lateral. Prioriza o posicionamento para atacar de longe.' },
    'flyer': { name: 'Voador', hp: 8, speed: 3, size: 25, color: '#ffaa00', attackCooldown: 3000, behavior: 'flying', expValue: 2, description: 'Ignora o terreno e voa diretamente em direção ao jogador. Sua forma triangular indica sua agilidade e dificuldade de ser atingido.' },
    'bomber': { name: 'Bombardeiro', hp: 25, speed: 1.2, size: 40, color: '#ff6600', attackCooldown: 5000, behavior: 'standard', expValue: 4, description: 'Solta projéteis explosivos que causam dano em área. Uma luz piscante em seu corpo sinaliza um ataque iminente.' },
    'elite': { name: 'Elite Hexagonal', hp: 80, speed: 1.8, size: 45, color: '#ab47bc', attackCooldown: 1200, behavior: 'flying', expValue: 5, description: 'Uma versão voadora e aprimorada do Atirador. É rápido, resistente e dispara com alta frequência, sendo uma grande ameaça.' },
    'bouncer': { name: 'Rebatedor', hp: 20, speed: 2.2, size: 30, color: '#4dd0e1', attackCooldown: 1800, behavior: 'standard', expValue: 3, description: 'Especialista em caos, dispara projéteis que ricocheteiam nas paredes, tornando o campo de batalha imprevisível e perigoso.' },
    'exploder': { name: 'Explosivo', hp: 30, speed: 1.5, size: 40, color: '#ffd54f', attackCooldown: 99999, behavior: 'kamikaze', expValue: 4, description: 'Não ataca. Em vez disso, corre em direção ao jogador e, ao ser derrotado, explode em uma cruz de energia estática que causa dano.' },
    'healer': { name: 'Curandeiro', hp: 40, speed: 1.2, size: 35, color: '#a5d6a7', attackCooldown: 3000, behavior: 'support', expValue: 5, description: 'Uma unidade de suporte vital. Tenta evitar o combate direto e emite pulsos de cura que regeneram a vida de todos os inimigos próximos.' },
    'teleporter': { name: 'Saltador Quântico', hp: 15, speed: 2, size: 28, color: '#b39ddb', attackCooldown: 2000, behavior: 'teleporting', expValue: 4, description: 'Extremamente evasivo. Move-se de forma errática, teleportando-se em curtas distâncias a cada poucos segundos, tornando-se um alvo difícil.' },
    'splitter': { name: 'Divisor', hp: 60, speed: 1, size: 55, color: '#90a4ae', attackCooldown: 5000, behavior: 'standard', expValue: 6, description: 'Um inimigo grande e lento. Ao ser derrotado, sua massa se divide em dois Soldados Mini, continuando a luta.' },
    
    // Bosses
    'boss_default': { name: 'Chefe Padrão', hp: 200, speed: 0.8, size: 80, color: '#e53935', attackCooldown: 1000, behavior: 'standard', expValue: 20, isBoss: true, description: 'O primeiro grande desafio. Um inimigo massivo com alta vida e dano, servindo como um teste de força para o jogador.' },
    'boss_snow': { name: 'Lorde Glacial', hp: 250, speed: 0.7, size: 85, color: '#81d4fa', attackCooldown: 2000, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'frost_nova', specialCooldown: 8000, description: 'Um chefe do ártico. Dispara projéteis que podem congelar o jogador e, periodicamente, libera uma devastadora Nova de Gelo em área.' },
    'boss_forest': { name: 'Ancião da Floresta', hp: 300, speed: 0.6, size: 90, color: '#66bb6a', attackCooldown: 2500, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'summon_minions', specialCooldown: 10000, description: 'Um guardião ancestral e resistente. Sua tática é sobrecarregar o jogador, invocando hordas de Soldados para lutar ao seu lado.' },
    'boss_desert': { name: 'Elemental de Fogo', hp: 180, speed: 1.2, size: 75, color: '#ffa726', attackCooldown: 800, behavior: 'flying', expValue: 25, isBoss: true, specialAttack: 'fire_trail', specialCooldown: 5000, description: 'Rápido, aéreo e agressivo. Persegue o jogador incansavelmente, deixando um rastro de chamas que causa dano contínuo.' },
    'boss_cave': { name: 'Golias de Cristal', hp: 400, speed: 0.5, size: 95, color: '#7e57c2', attackCooldown: 1500, behavior: 'standard', expValue: 30, isBoss: true, specialAttack: 'crystal_shot', specialCooldown: 6000, description: 'Uma fortaleza ambulante. Extremamente resistente, seus projéteis se fragmentam em múltiplos estilhaços ao atingir uma parede ou o jogador.' },
    'boss_city': { name: 'Sentinela Urbana', hp: 220, speed: 0.9, size: 80, color: '#78909c', attackCooldown: 900, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'laser_beam', specialCooldown: 7000, description: 'Um construto de precisão mortal. Periodicamente, dispara um feixe de laser horizontal que atravessa toda a tela, exigindo um pulo perfeito.' },
    'boss_aurora': { name: 'Espectro da Aurora', hp: 200, speed: 1.0, size: 80, color: '#9c27b0', attackCooldown: 1200, behavior: 'teleporting', expValue: 25, isBoss: true, specialAttack: 'clone', specialCooldown: 9000, description: 'Um mestre da ilusão. Teleporta-se pelo campo de batalha e cria clones de si mesmo para confundir e dividir a atenção do jogador.' },
    'boss_space': { name: 'Verme do Vazio', hp: 250, speed: 0.8, size: 85, color: '#616161', attackCooldown: 1300, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'gravity_pulse', specialCooldown: 8000, description: 'Manipulador da gravidade. Emite pulsos periódicos que puxam o jogador e seus projéteis para perto, tornando a movimentação difícil.' },
    'boss_water': { name: 'Kraken das Marés', hp: 280, speed: 0.7, size: 90, color: '#29b6f6', attackCooldown: 1800, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'geyser', specialCooldown: 6000, description: 'Controla a água para atacar. Invoca gêiseres de alta pressão que emergem do chão em locais aleatórios, pegando jogadores desatentos.' },
    'boss_flowers': { name: 'Abominação Floral', hp: 200, speed: 0.9, size: 80, color: '#ec407a', attackCooldown: 1500, behavior: 'standard', expValue: 25, isBoss: true, specialAttack: 'pollen_cloud', specialCooldown: 7000, description: 'Uma beleza mortal. Libera uma grande nuvem de pólen que causa dano contínuo e obscurece a visão de quem estiver dentro dela.' },

};
const ACHIEVEMENTS = [
    // Kills
    { id: 'kills1', name: 'Primeiro Sangue', description: 'Mate seu primeiro inimigo.', rarity: 'common', target: 1, type: 'kills', reward: 5 },
    { id: 'kills50', name: 'Caçador Novato', description: 'Mate 50 inimigos.', rarity: 'common', target: 50, type: 'kills', reward: 10 },
    { id: 'kills250', name: 'Caçador Experiente', description: 'Mate 250 inimigos.', rarity: 'uncommon', target: 250, type: 'kills', reward: 25 },
    { id: 'kills1000', name: 'Exterminador', description: 'Mate 1000 inimigos em uma única partida.', rarity: 'rare', target: 1000, type: 'kills', reward: 100 },
    
    // Waves & Survival
    { id: 'wave5', name: 'Sobrevivente', description: 'Sobreviva até a onda 5.', rarity: 'common', target: 5, type: 'wave', reward: 10 },
    { id: 'wave15', name: 'Veterano', description: 'Sobreviva até a onda 15.', rarity: 'uncommon', target: 15, type: 'wave', reward: 30 },
    { id: 'wave25', name: 'Lenda Viva', description: 'Sobreviva até a onda 25.', rarity: 'rare', target: 25, type: 'wave', reward: 75 },
    { id: 'cosmic_conqueror', name: 'Conquistador Cósmico', description: 'Chegue à onda 101 e vença o jogo.', rarity: 'legendary', target: 101, type: 'wave', reward: 250 },
    { id: 'bosskiller1', name: 'Matador de Chefes', description: 'Derrote o primeiro chefe (Onda 5).', rarity: 'uncommon', target: 1, type: 'boss_kills', reward: 40 },
    
    // Gameplay Challenges
    { id: 'nodamage5', name: 'Intocável', description: 'Complete 5 ondas seguidas sem levar dano.', rarity: 'rare', target: 5, type: 'no_damage_waves', reward: 50 },
    { id: 'clutch', name: 'Por um Fio', description: 'Termine uma onda com menos de 10% de vida.', rarity: 'epic', target: 1, type: 'clutch_wave', reward: 70 },
    
    // Stats & Upgrades
    { id: 'level10', name: 'Poder Crescente', description: 'Alcance o nível 10 em uma partida.', rarity: 'uncommon', target: 10, type: 'level', reward: 20 },
    { id: 'legendaryCard', name: 'Achado Raro', description: 'Obtenha sua primeira carta Lendária.', rarity: 'rare', target: 1, type: 'collect_rarity', subtype: 'legendary', reward: 50 },
    
    // Meta Progression
    { id: 'firstpurchase', name: 'Primeira Compra', description: 'Compre seu primeiro item de personalização.', rarity: 'common', target: 1, type: 'first_purchase', reward: 10 },
    { id: 'spender', name: 'Gastador', description: 'Gaste um total de 1000 moedas.', rarity: 'uncommon', target: 1000, type: 'meta_spend', reward: 40 },
    
    // --- CONQUISTAS DE PERSONALIZAÇÃO (DINÂMICA) ---
    // HATS
    { id: 'gamer_hat_unlock', name: 'Aniquilador', description: 'Derrote 500 inimigos em uma única partida.', rarity: 'uncommon', target: 500, type: 'kills', reward: 50, customizationReward: { type: 'hat', id: 'hat_gamer' } },
    { id: 'grad_hat_unlock', name: 'O Estudioso', description: 'Alcance o nível 25 em uma partida.', rarity: 'rare', target: 25, type: 'level', reward: 100, customizationReward: { type: 'hat', id: 'hat_grad' } },
    { id: 'rescue_hat_unlock', name: 'Indestrutível', description: 'Sobreviva a 3 ondas de chefes em uma partida.', rarity: 'rare', target: 3, type: 'boss_kills', reward: 150, customizationReward: { type: 'hat', id: 'hat_rescue' } },
    { id: 'box_hat_unlock', name: 'Colecionador de XP', description: 'Colete 100 orbes de XP em uma partida.', rarity: 'uncommon', target: 100, type: 'xp_orbs', reward: 50, customizationReward: { type: 'hat', id: 'hat_box' } },
    { id: 'books_hat_unlock', name: 'Mestre das Cartas', description: 'Tenha 10 cartas únicas diferentes em uma partida.', rarity: 'rare', target: 10, type: 'unique_cards', reward: 120, customizationReward: { type: 'hat', id: 'hat_books' } },
    { id: 'coffee_hat_unlock', name: 'Maratonista', description: 'Sobreviva por 15 minutos em uma única partida.', rarity: 'epic', target: 900000, type: 'survival_time', reward: 200, customizationReward: { type: 'hat', id: 'hat_coffee' } },
    // COLORS
    { id: 'sunset_color_unlock', name: 'Crepúsculo', description: 'Derrote 50 inimigos do tipo Bombardeiro.', rarity: 'uncommon', target: 50, type: 'kill_type', subtype: 'bomber', reward: 60, customizationReward: { type: 'color', id: 'color_sunset' } },
    { id: 'ocean_color_unlock', name: 'Tsunami', description: 'Congele 100 inimigos com a Nova Congelante.', rarity: 'rare', target: 100, type: 'frozen_enemies', reward: 100, customizationReward: { type: 'color', id: 'color_ocean' } },
    { id: 'forest_color_unlock', name: 'Guardião da Floresta', description: 'Cure 1000 de vida com Roubo de Vida ou Orbes de Cura.', rarity: 'uncommon', target: 1000, type: 'healing', reward: 75, customizationReward: { type: 'color', id: 'color_forest' } },
    { id: 'aurora_color_unlock', name: 'Luzes do Norte', description: 'Tenha um Pet de Combate e um Escudo Orbital ao mesmo tempo.', rarity: 'epic', target: 1, type: 'pet_and_shield', reward: 150, customizationReward: { type: 'color', id: 'color_aurora' } },
    { id: 'royal_color_unlock', name: 'Realeza', description: 'Gaste um total de 2500 moedas.', rarity: 'rare', target: 2500, type: 'meta_spend', reward: 100, customizationReward: { type: 'color', id: 'color_royal' } },
    { id: 'void_color_unlock', name: 'Abismo', description: 'Derrote 50 inimigos com Buracos Negros.', rarity: 'epic', target: 50, type: 'black_hole_kills', reward: 250, customizationReward: { type: 'color', id: 'color_void' } },
    // FACES
    { id: 'money_face_unlock', name: 'Magnata', description: 'Ganhe 500 moedas em uma única partida.', rarity: 'rare', target: 500, type: 'coins_in_run', reward: 100, customizationReward: [{ type: 'face', id: 'face_money' }, { type: 'hat', id: 'hat_moneybag'}] },
    { id: 'sad_face_unlock', name: 'Quase lá', description: 'Morra em uma onda de chefe.', rarity: 'common', target: 1, type: 'death_on_boss_wave', reward: 20, customizationReward: { type: 'face', id: 'face_sad' } },
    { id: 'uwu_face_unlock', name: 'Amigo dos Animais', description: 'Tenha 6 pets de combate ao mesmo tempo.', rarity: 'epic', target: 6, type: 'stat_check', subtype: 'laserPet.count', reward: 150, customizationReward: { type: 'face', id: 'face_uwu' } },
    { id: 'dizzy_face_unlock', name: 'Ricocheteador', description: 'Faça 50 projéteis rebaterem com la carta Ricochete.', rarity: 'uncommon', target: 50, type: 'ricochets', reward: 80, customizationReward: { type: 'face', id: 'face_dizzy' } },
    { id: 'rage_face_unlock', name: 'Fúria Implacável', description: 'Mate 20 inimigos enquanto estiver com o buff da carta Fúria ativo.', rarity: 'rare', target: 20, type: 'rage_kills', reward: 90, customizationReward: { type: 'face', id: 'face_rage' } },
    { id: 'error_face_unlock', name: 'Quebrador de Limites', description: 'Cause mais de 1000 de dano em um único acerto.', rarity: 'epic', target: 1000, type: 'single_hit_damage', reward: 200, customizationReward: { type: 'face', id: 'face_error' } },

    // --- CONQUISTAS DE FORMA (VFX E POLÍGONOS) ---
    { id: 'pentagon_shape_unlock', name: 'Penta-Kill', description: 'Mate 5 inimigos simultaneamente.', rarity: 'rare', target: 5, type: 'simultaneous_kills', reward: 150, customizationReward: { type: 'shape', id: 'shape_pentagon' } },
    { id: 'hexagon_shape_unlock', name: 'Muralha', description: 'Bloqueie 25 projéteis com la Barreira em uma partida.', rarity: 'rare', target: 25, type: 'barrier_blocks', reward: 150, customizationReward: { type: 'shape', id: 'shape_hexagon' } },
    { id: 'gear_shape_unlock', name: 'Metralhadora', description: 'Alcance uma cadência de 10 tiros por segundo.', rarity: 'epic', target: 100, type: 'attack_speed_milestone', reward: 200, customizationReward: { type: 'shape', id: 'shape_gear' } },
    { id: 'cross_shape_unlock', name: 'Curandeiro', description: 'Cure um total de 2000 de vida em uma partida.', rarity: 'rare', target: 2000, type: 'healing', reward: 150, customizationReward: { type: 'shape', id: 'shape_cross' } },

    // --- NEW ACHIEVEMENTS (v7.1) ---
    // Difficulty / Mode
    { id: 'win_hard', name: 'Deus Cósmico', description: 'Vença o jogo (100 ondas) na dificuldade Difícil.', rarity: 'legendary', target: 1, type: 'win_condition', subtype: 'hard', reward: 500, customizationReward: { type: 'hat', id: 'hat_trophy' } },
    { id: 'wave50_infinite', name: 'Infinito e Além', description: 'Alcance a onda 50 no modo Infinito.', rarity: 'epic', target: 50, type: 'wave_in_mode', subtype: 'infinite', reward: 200 },
    { id: 'wave20_hard', name: 'Sobrevivente Nato', description: 'Alcance a onda 20 no modo Difícil.', rarity: 'rare', target: 20, type: 'wave_in_difficulty', subtype: 'hard', reward: 150 },
    { id: 'win_no_commons', name: 'Purista', description: 'Vença o jogo (100 ondas) sem pegar nenhuma carta Comum.', rarity: 'epic', target: 1, type: 'win_condition_no_rarity', subtype: 'common', reward: 300 },
    { id: 'flawless_victory_easy', name: 'Passeio no Parque', description: 'Vença o jogo (100 ondas) no Fácil sem morrer.', rarity: 'uncommon', target: 1, type: 'win_no_deaths', subtype: 'easy', reward: 75 },

    // Card / Stat Combos
    { id: 'crit_master', name: 'Mestre do Crítico', description: 'Alcance 100% de chance de crítico em uma partida.', rarity: 'epic', target: 1.0, type: 'stat_milestone', subtype: 'critChance', reward: 150 },
    { id: 'health_tank', name: 'Tanque Imortal', description: 'Alcance 500 de Vida Máxima em uma partida.', rarity: 'rare', target: 500, type: 'stat_milestone', subtype: 'maxHp', reward: 100 },
    { id: 'glass_cannon_god', name: 'Deus de Vidro', description: 'Vença uma partida (100 ondas) com la carta Canhão de Vidro.', rarity: 'legendary', target: 1, type: 'win_with_card', subtype: 'GlassCannon', reward: 400 },
    { id: 'synergy_master', name: 'Mestre da Sinergia', description: 'Tenha Buraco Negro e Poço Gravitacional ao mesmo tempo.', rarity: 'epic', target: 1, type: 'card_combo', subtypes: ['Black Hole', 'GravityWell'], reward: 120 },
    { id: 'army_of_one', name: 'Exército de Um Homem Só', description: 'Tenha 6 pets e 3 clones de miragem ao mesmo tempo.', rarity: 'epic', target: 1, type: 'card_combo', subtypes: ['LaserPet', 'MirageClones'], reward: 150 },
    { id: 'pacifist_wave', name: 'Onda Pacifista', description: 'Complete uma onda após a onda 10 sem atirar (danos passivos permitidos).', rarity: 'rare', target: 1, type: 'no_shot_wave', reward: 100 },
    { id: 'stationary_threat', name: 'Ameaça Estacionária', description: 'Complete uma onda de chefe sem se mover horizontalmente.', rarity: 'epic', target: 1, type: 'no_move_boss_wave', reward: 180 },
    { id: 'reroll_addict', name: 'Viciado em Rolar', description: 'Use a opção de rolar cartas 5 vezes em uma única partida.', rarity: 'uncommon', target: 5, type: 'rerolls_in_run', reward: 50 },
    { id: 'elite_conversion', name: 'Conversão de Elite', description: 'Converta um inimigo Elite com a Aliança Temporária.', rarity: 'rare', target: 1, type: 'convert_enemy_type', subtype: 'elite', reward: 90 },
    { id: 'boss_melter', name: 'Derretedor de Chefes', description: 'Derrote um chefe em menos de 10 segundos.', rarity: 'epic', target: 10000, type: 'fast_boss_kill', reward: 200 },
    
    // Meta / Collection
    { id: 'fashionista', name: 'Fashionista', description: 'Tenha todos os chapéus.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'hats', reward: 100 },
    { id: 'shapeshifter', name: 'Metamorfo', description: 'Tenha todas as formas.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'shapes', reward: 100 },
    { id: 'chromatic', name: 'Cromático', description: 'Tenha todas as cores.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'colors', reward: 100 },
    { id: 'expressive', name: 'Expressivo', description: 'Tenha todos os rostos.', rarity: 'rare', target: 1, type: 'collect_all', subtype: 'faces', reward: 100 },
    { id: 'max_out_perm', name: 'Mestre das Melhorias', description: 'Maximize uma melhoria permanente.', rarity: 'epic', target: 1, type: 'max_perm_upgrade', reward: 250 },
    { id: 'big_spender', name: 'Grande Gastador', description: 'Gaste um total de 5000 moedas.', rarity: 'rare', target: 5000, type: 'meta_spend', reward: 150 },
    { id: 'ten_wins', name: 'Campeão Consistente', description: 'Vença 10 partidas no total (qualquer dificuldade).', rarity: 'epic', target: 10, type: 'total_wins', reward: 200 },
    { id: 'first_hard_kill', name: 'Batismo de Fogo', description: 'Derrote seu primeiro inimigo na dificuldade Difícil.', rarity: 'uncommon', target: 1, type: 'first_kill_difficulty', subtype: 'hard', reward: 50 },
    { id: 'one_hp_wonder', name: 'Maravilha de 1 HP', description: 'Termine uma onda com exatamente 1 de HP.', rarity: 'epic', target: 1, type: 'one_hp_clutch', reward: 120 },
    { id: 'combo_wombo', name: 'Wombo Combo', description: 'Mate 15 inimigos em menos de 2 segundos.', rarity: 'legendary', target: 15, type: 'multi_kill_in_time', reward: 300 },
    { id: 'from_the_brink', name: 'À Beira do Abismo', description: 'Comece uma onda com menos de 10% de vida e termine com mais de 90%.', rarity: 'epic', target: 1, type: 'comeback_wave', reward: 150 },
    { id: 'specialist_common', name: 'Especialista Comum', description: 'Acumule 10 stacks de qualquer carta comum.', rarity: 'uncommon', target: 10, type: 'stack_rarity', subtype: 'common', reward: 60 },
    { id: 'specialist_epic', name: 'Especialista Épico', description: 'Acumule 5 stacks de qualquer carta épica.', rarity: 'rare', target: 5, type: 'stack_rarity', subtype: 'epic', reward: 130 },
    { id: 'untouchable_boss', name: 'Chefe Intocável', description: 'Derrote um chefe sem levar dano durante a onda dele.', rarity: 'epic', target: 1, type: 'no_damage_boss_wave', reward: 220 },
    { id: 'all_rounder', name: 'Generalista', description: 'Tenha pelo menos uma carta de cada raridade em uma partida.', rarity: 'rare', target: 1, type: 'all_rarities_in_run', reward: 100 },
    
    // --- NEW ACHIEVEMENTS (v7.2) ---
    { id: 'heart_shape_unlock', name: 'Amor à Vida', description: 'Cure 5000 de vida no total.', rarity: 'rare', target: 5000, type: 'total_healing', reward: 150, customizationReward: { type: 'shape', id: 'shape_heart' } },
    { id: 'sleep_hat_unlock', name: 'Imóvel', description: 'Sobreviva a 3 ondas após a onda 10 sem se mover.', rarity: 'epic', target: 3, type: 'stationary_waves', reward: 150, customizationReward: { type: 'hat', id: 'hat_sleep' } },
    { id: 'question_hat_unlock', name: 'Indeciso', description: 'Role as cartas de upgrade 10 vezes em uma única partida.', rarity: 'rare', target: 10, type: 'rerolls_in_run', reward: 100, customizationReward: { type: 'hat', id: 'hat_question' } },
    { id: 'bomb_hat_unlock', name: 'Reação em Cadeia', description: 'Mate 50 inimigos com a explosão dos inimigos Explosivos.', rarity: 'uncommon', target: 50, type: 'exploder_kills', reward: 75, customizationReward: { type: 'hat', id: 'hat_bomb' } },
    { id: 'bear_face_unlock', name: 'Amigo da Natureza', description: 'Sobreviva a 10 ondas no cenário de Floresta.', rarity: 'uncommon', target: 10, type: 'survival_in_theme', subtype: 'forest', reward: 50, customizationReward: { type: 'face', id: 'face_bear' } },
    { id: 'crying_face_unlock', name: 'Pobre e Derrotado', description: 'Morra enquanto possui mais de 1000 moedas na partida.', rarity: 'uncommon', target: 1000, type: 'death_with_coins', reward: 50, customizationReward: { type: 'face', id: 'face_crying' } },
    { id: 'lava_color_unlock', name: 'Infernal', description: 'Sobreviva a 10 ondas no cenário de Deserto.', rarity: 'rare', target: 10, type: 'survival_in_theme', subtype: 'desert', reward: 100, customizationReward: { type: 'color', id: 'color_lava' } },
    { id: 'toxic_color_unlock', name: 'Anti-Suporte', description: 'Derrote 25 inimigos Curandeiros.', rarity: 'rare', target: 25, type: 'kill_type', subtype: 'healer', reward: 100, customizationReward: { type: 'color', id: 'color_toxic' } },
    { id: 'ice_color_unlock', name: 'Calafrio', description: 'Sobreviva a 10 ondas no cenário de Neve.', rarity: 'rare', target: 10, type: 'survival_in_theme', subtype: 'snow', reward: 100, customizationReward: { type: 'color', id: 'color_ice' } },

    // Ultimate
    { id: 'ultimate', name: 'Conquista Suprema', description: 'Desbloqueie todas as outras conquistas.', rarity: 'legendary', unlocked: false, target: 1, type: 'all', reward: 500 }
];


// ===================================================================================
// 3. GERENCIADOR DO JOGO E VARIÁVEIS GLOBAIS
// ===================================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.WIDTH; 
canvas.height = CONFIG.HEIGHT;

// Elementos da UI
const characterPreviewCanvas = document.getElementById('characterPreviewCanvas');
const previewCtx = characterPreviewCanvas.getContext('2d');
const achievementNotificationContainer = document.getElementById('achievement-notification-container');
const nicknameModal = document.getElementById('nickname-modal');
const nicknameInput = document.getElementById('nickname-input');
const nicknameError = document.getElementById('nickname-error');
const confirmNicknameButton = document.getElementById('confirm-nickname-button');

const mainMenuModal = document.getElementById('main-menu-modal');
const mainMenuNickname = document.getElementById('main-menu-nickname');
const mainMenuCoinsValue = document.getElementById('main-menu-coins-value');

const changelogModal = document.getElementById('changelog-modal');
const changelogButton = document.getElementById('changelog-button');
const changelogCloseButton = document.getElementById('changelog-close');

const upgradeModal = document.getElementById('upgrade-modal');
const rollUpgradesButton = document.getElementById('roll-upgrades-button');
const randomUpgradeButton = document.getElementById('random-upgrade-button');
const skipUpgradeButton = document.getElementById('skip-upgrade-button');

const gameOverScreen = document.getElementById('game-over-screen');
const victoryModal = document.getElementById('victory-modal');
const controlsHint = document.getElementById('controls-hint');
const cheatMenu = document.getElementById('cheat-menu');
const badgesModal = document.getElementById('badges-modal');
const settingsModal = document.getElementById('settings-modal');
const infoModal = document.getElementById('info-modal');
const cheatMenuButton = document.getElementById('cheatMenuButton');
const settingsButton = document.getElementById('settingsButton');
const cheatCardsList = document.getElementById('cheat-cards-list');
const achievementsList = document.getElementById('achievements-list');
const addAllCardsButton = document.getElementById('add-all-cards');
const applyCheatsButton = document.getElementById('apply-cheats');
const resetCheatsButton = document.getElementById('reset-cheats');
const cheatCloseButton = document.getElementById('cheat-close');
const badgesCloseButton = document.getElementById('badges-close');
const settingsCloseButton = document.getElementById('settings-close');
const infoCloseButton = document.getElementById('info-close');
const closeBadgesButton = document.getElementById('close-badges');
const returnToMenuFromGameOverButton = document.getElementById('return-to-menu-from-gameover');
const returnToMenuFromVictoryButton = document.getElementById('return-to-menu-from-victory');
const showBadgesMainButton = document.getElementById('show-badges-main');
const showSettingsButton = document.getElementById('show-settings');
const showInfoButton = document.getElementById('show-info-button');
const applySettingsButton = document.getElementById('apply-settings');
const showBadgesPauseButton = document.getElementById('show-badges-pause');
const tutorialButton = document.getElementById('tutorial-button');
const tutorialModal = document.getElementById('tutorial-modal');
const closeTutorialButton = document.getElementById('close-tutorial');
const waveIndicator = document.getElementById('wave-indicator');
const bossWarning = document.getElementById('boss-warning');
const ingameCardsUI = document.getElementById('ingame-cards-ui');
const ingameInfoDisplay = document.getElementById('ingame-info-display');
const gameTimerDisplay = document.getElementById('game-timer-display');
const cheatFeaturesConfirmationModal = document.getElementById('cheat-features-confirmation-modal');
const confirmCheatFeaturesYes = document.getElementById('confirm-cheat-features-yes');
const confirmCheatFeaturesNo = document.getElementById('confirm-cheat-features-no');
const cheatFeaturesSettingCheckbox = document.getElementById('cheat-features-setting');
const cheatSettingsContainer = document.getElementById('cheat-settings-container');
const deleteDataButton = document.getElementById('delete-data-btn');
const deleteDataConfirmationModal = document.getElementById('delete-data-confirmation-modal');
const confirmDeleteDataYes = document.getElementById('confirm-delete-data-yes');
const confirmDeleteDataNo = document.getElementById('confirm-delete-data-no');


const customizeCharacterButton = document.getElementById('customize-character-button');
const customizationModal = document.getElementById('customization-modal');
const customizationCoinsDisplay = document.getElementById('customization-coins');
const backToMainMenuFromCustomizationButton = document.getElementById('back-to-main-menu-from-customization');
const shapesTabButton = document.getElementById('shapes-tab-button');
const hatsTabButton = document.getElementById('hats-tab-button');
const colorsTabButton = document.getElementById('colors-tab-button');
const facesTabButton = document.getElementById('faces-tab-button');
const shapesOptionsContainer = document.getElementById('shapes-options');
const hatsOptionsContainer = document.getElementById('hats-options');
const colorsOptionsContainer = document.getElementById('colors-options');
const facesOptionsContainer = document.getElementById('faces-options');
const permanentUpgradesButton = document.getElementById('permanent-upgrades-button');
const permanentUpgradesModal = document.getElementById('permanent-upgrades-modal');
const permanentUpgradesListContainer = document.getElementById('permanent-upgrades-list');
const permanentUpgradesCoinsDisplay = document.getElementById('permanent-upgrades-coins');
const backToMainMenuFromUpgradesButton = document.getElementById('back-to-main-menu-from-upgrades');
const recordsModal = document.getElementById('records-modal');
const showRecordsButton = document.getElementById('show-records-button');
const recordsCloseButton = document.getElementById('records-close');
const closeRecordsButton = document.getElementById('close-records');
const recordsTableBody = document.getElementById('records-table-body');
const backFromCharacterButton = document.getElementById('back-from-character');
const backFromDeviceButton = document.getElementById('back-from-device');

// New Modals v7.0
const difficultyModal = document.getElementById('difficulty-modal');
const gamemodeModal = document.getElementById('gamemode-modal');
const difficultySelectionCards = document.getElementById('difficulty-selection-cards');
const gamemodeSelectionCards = document.getElementById('gamemode-selection-cards');
const confirmDifficultyButton = document.getElementById('confirm-difficulty');
const backFromDifficultyButton = document.getElementById('back-from-difficulty');
const backFromGamemodeButton = document.getElementById('back-from-gamemode');
const confirmGamemodeButton = document.getElementById('confirm-gamemode');

// Pause Menu Confirmation Modals (v7.4)
const restartConfirmationModal = document.getElementById('restart-confirmation-modal');
const confirmRestartYes = document.getElementById('confirm-restart-yes');
const confirmRestartNo = document.getElementById('confirm-restart-no');
const returnToMenuConfirmationModal = document.getElementById('return-to-menu-confirmation-modal');
const confirmReturnToMenuYes = document.getElementById('confirm-return-to-menu-yes');
const confirmReturnToMenuNo = document.getElementById('confirm-return-to-menu-no');

// Estado global do jogo
let gameManager = {
    controlScheme: null,
    chosenDevice: null,
    running: false,
    paused: false,
    gameOver: false,
    victory: false,
    wave: 0,
    waveState: 'COOLDOWN',
    waveTimer: CONFIG.WAVE_SPAWN_COOLDOWN,
    killsThisRun: 0,
    bossKillsThisRun: 0,
    totalExpThisRun: 0,
    xpOrbsCollected: 0,
    coinsInRun: 0,
    gameTime: 0,
    noDamageWaves: 0,
    shotsFiredThisWave: 0,
    jumpsThisRun: 0,
    frozenEnemiesThisRun: 0,
    healingDoneThisRun: 0,
    blackHoleKillsThisRun: 0,
    ricochetsThisRun: 0,
    rageKillsThisRun: 0,
    simultaneousKills: 0,
    barrierBlocks: 0,
    exploderKillsThisRun: 0,
    stationaryWaveCount: 0,
    difficulty: 'normal',
    gameMode: 'waves',
    isDifficultyRandom: false,
    isGameModeRandom: false,
    isCharacterRandom: false,
    achievements: JSON.parse(JSON.stringify(ACHIEVEMENTS)), // Deep copy
    stats: {
        coins: 0, 
        totalSpent: 0,
        totalWins: 0,
        totalHealing: 0,
        firstPurchaseMade: false,
        character: 'warrior',
        killCounts: {},
        criticalHitsThisRun: 0,
        rerollsThisRun: 0,
        deathsThisRun: 0,
    },
    runFlags: {
        playerMovedHorizontally: false,
        tookDamageThisWave: false,
        hpAtWaveStart: 0,
        multiKillTimer: 0,
        multiKillCounter: 0,
        bossSpawnTime: 0,
        currentThemeName: 'default',
        wavesInCurrentTheme: 0,
    },
    cheats: {
        immortality: false, autoFire: false, playerSpeed: 7, playerDamage: 5,
        freezeEnemies: false, enemyDamage: 10, instantExp: false, infiniteJumps: false
    },
    timeWarp: { active: false, timer: 0 } // For TimeWarp card
};

// Variáveis de jogo
let player; 
let groundPath = [];
let platforms = [];
let enemies = [];
let projectiles = [];
let particles = [];
let expOrbs = [];
let floatingTexts = [];
let blackHoles = [];
let orbitalShields = [];
let coins = []; 
let mirageClones = [];
let gravityWells = [];
let damageZones = [];

let keys = {}, mouse = { x: 0, y: 0, down: false };
let lastTime = 0, screenShake = { duration: 0, magnitude: 0 };
let movementJoystick, shootingJoystick;
let bloodSplatters = [];
let lastDamageWave = -1;
let previousScreen = null;
let previewAnimationId = null;
let gameLoopId = null; 

// ===================================================================================
// 4. CLASSES DE OBJETOS DO JOGO (MELHORADAS)
// ===================================================================================

class Platform {
    constructor(x, y, width) {
        this.x = x; this.y = y; this.width = width; this.height = CONFIG.PLATFORM_HEIGHT;
    }
    draw(ctx) {
        ctx.fillStyle = frameColors.platform;
        ctx.shadowColor = '#8a8aff';
        ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

class Entity {
    constructor(x, y, width, height, color) { 
        this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; 
        this.vx = 0; this.vy = 0; this.active = true; 
    }
}

class Player extends Entity {
    constructor(x, y) {
        const initialColor = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor)?.value || '#4caf50';
        super(x, y, 40, 60, initialColor);
        this.initStats();
        this.onGround = false; this.wasOnGround = false; this.jumps = 0; this.attackTimer = 0; this.invincibleTimer = 0; 
        this.scale = { x: 1, y: 1 }; this.jumpInputSustained = false; this.facingDirection = 1; this.onPlatform = false;
        this.lastAutoFireTime = 0;
        this.upgrades = {}; // e.g. {'Catalyst': 2}
        this.vfx = { // Visual Effects State
            damageAuraOpacity: 0,
            speedTrail: [],
            attackSpeedTrail: [],
            critGlow: 0,
            muzzleGlow: 0,
            isGlass: false,
        };
    }

    initStats() { 
        const baseStats = {
            hp: 100,
            damage: 5,
            moveSpeed: 7,
            jumpForce: 20,
            attackSpeed: 250,
            critChance: 0.05
        };

        const permHpBonus = PERMANENT_UPGRADES_CATALOG['perm_hp'].effect(PLAYER_PERMANENT_UPGRADES['perm_hp'] || 0);
        const permDmgBonus = PERMANENT_UPGRADES_CATALOG['perm_dmg'].effect(PLAYER_PERMANENT_UPGRADES['perm_dmg'] || 0);
        const permLuckBonus = PERMANENT_UPGRADES_CATALOG['perm_luck'].effect(PLAYER_PERMANENT_UPGRADES['perm_luck'] || 0);
        
        let finalHp = baseStats.hp * permHpBonus;
        let finalDmg = baseStats.damage * permDmgBonus;
        let finalSpeed = baseStats.moveSpeed;
        let finalAttackSpeed = baseStats.attackSpeed;
        let finalCritChance = baseStats.critChance + permLuckBonus;

        if (gameManager.difficulty === 'easy') { finalHp *= 1.3; finalDmg *= 1.3; } 
        else if (gameManager.difficulty === 'normal') { finalHp *= 1.15; finalDmg *= 1.1; }

        this.baseStats = { moveSpeed: finalSpeed };
        this.hp = finalHp; 
        this.exp = 0; this.level = 1; this.expToNextLevel = 10; 
        
        this.stats = { 
            maxHp: finalHp, moveSpeed: finalSpeed, jumpForce: baseStats.jumpForce, maxJumps: 1, 
            attackSpeed: finalAttackSpeed, projectileDamage: finalDmg,
            projectileSize: 5, projectileCount: 1, critChance: finalCritChance, critDamage: 1.5, lifesteal: 0, 
            upgradeChoices: 3, 
            catalyst: { stacks: 0 },
            growth: { stacks: 0 },
            swift: { stacks: 0 },
            resonance: { stacks: 0 },
            eyesight: { stacks: 0 },
            barrier: { enabled: false, cooldown: 15000, timer: 0, active: true }, 
            rage: { enabled: false }, 
            thunderbolt: { enabled: false, cooldown: 5000, timer: 5000, count: 0, damage: 20 },
            fragmentation: { enabled: false, count: 0 },
            piercing: { enabled: false, hits: 1 },
            blackHole: { enabled: false, chance: 0, radius: 80, duration: 3000, damagePercent: 0.05, tickRate: 500 },
            laserPet: { count: 0, attackSpeed: 2000, damage: 15 },
            bloodRitual: { chance: 0 },
            ricochet: { enabled: false, chance: 1, maxBounces: 0 },
            tempAlliance: { chance: 0, duration: 3000, healBonus: 0.05 },
            frostNova: { enabled: false, duration: 2000 },
            chainLightning: { enabled: false, chance: 0, bounces: 0, damageMultiplier: 0.5 },
            orbitalShield: { count: 0, speed: 1 },
            magneticField: { enabled: true, range: 150 },
            vampiricExplosion: { enabled: false, chance: 0, healPercent: 0 },
            shockwaveJump: { enabled: false, damage: 0, radius: 0 },
            gravityWell: { enabled: false, chance: 0, radius: 50, duration: 1000 },
            singularityCore: { enabled: false, damage: 0, cooldown: 4000, timer: 4000 },
            holyRetribution: { enabled: false, count: 0, damage: 15 },
            mirageClones: { enabled: false, count: 0, cooldown: 10000, timer: 10000, duration: 5000 },
            ouroborosRounds: { enabled: false, chance: 0 },
            quantumEntanglement: { enabled: false, sharePercent: 0, targets: 0 },
            timeWarp: { enabled: false, chance: 0, duration: 2000 },
            ghostBullets: { enabled: false, chance: 0 },
        };
        
        if (gameManager.stats.character === 'warrior') { this.stats.maxHp *= 1.2; } 
        else if (gameManager.stats.character === 'archer') { this.stats.attackSpeed *= 0.7; }
        this.hp = this.stats.maxHp;
        
        this.applyAllCheats();
    }

    applyAllCheats() {
        if (gameManager.cheats.immortality) this.hp = 99999;
        this.stats.moveSpeed = gameManager.cheats.playerSpeed;
        this.stats.projectileDamage += (gameManager.cheats.playerDamage - 5);
        if (gameManager.cheats.infiniteJumps) this.stats.maxJumps = 999;
    }

    update(deltaTime) {
        this.wasOnGround = this.onGround || this.onPlatform;
        const initialX = this.x;

        if (gameManager.cheats.autoFire && this.attackTimer <= 0) {
            this.autoShoot();
        } else if (gameManager.controlScheme === 'desktop') {
            if (keys['a'] || keys['ArrowLeft']) { this.vx = -this.stats.moveSpeed; this.facingDirection = -1; gameManager.runFlags.playerMovedHorizontally = true; }
            else if (keys['d'] || keys['ArrowRight']) { this.vx = this.stats.moveSpeed; this.facingDirection = 1; gameManager.runFlags.playerMovedHorizontally = true; }
            else this.vx = 0;
            
            if (mouse.down && this.attackTimer <= 0) {
                this.shoot();
            }
        } else if (gameManager.controlScheme === 'mobile' && movementJoystick && shootingJoystick) {
            this.vx = movementJoystick.deltaX * this.stats.moveSpeed;
            if (this.vx !== 0) { this.facingDirection = Math.sign(this.vx); gameManager.runFlags.playerMovedHorizontally = true; }
            if (movementJoystick.deltaY < -0.75 && !this.jumpInputSustained) { this.jump(); this.jumpInputSustained = true; }
            if (movementJoystick.deltaY > -0.5) this.jumpInputSustained = false;
            
            if (shootingJoystick.active && this.attackTimer <= 0) {
                this.shoot();
            }
        }
       
        this.vy += CONFIG.GRAVITY; this.x += this.vx; this.y += this.vy; this.onGround = false; this.onPlatform = false;
        
        if (Math.abs(this.x - initialX) < 0.1) {
            // Player hasn't moved horizontally this frame
        } else {
            gameManager.runFlags.playerMovedHorizontally = true;
        }

        const groundY = getGroundHeightAt(this.x + this.width / 2);
        if (this.y + this.height > groundY && this.vy >= 0) { 
            this.y = groundY - this.height; this.vy = 0; this.onGround = true; this.jumps = 0; 
            if (!this.wasOnGround && this.stats.shockwaveJump.enabled) this.createShockwave();
        }
        
        for (const platform of platforms) {
            if (this.y + this.height > platform.y && this.y + this.height < platform.y + this.vy + 2 &&
                this.x + this.width > platform.x && this.x < platform.x + platform.width && this.vy >= 0) {
                this.y = platform.y - this.height; this.vy = 0; this.onPlatform = true; this.jumps = 0;
                if (!this.wasOnGround && this.stats.shockwaveJump.enabled) this.createShockwave();
            }
        }
        
        if (this.x < 0) this.x = 0; if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

        if (this.attackTimer > 0) this.attackTimer -= deltaTime;
        if (this.invincibleTimer > 0) this.invincibleTimer -= deltaTime;
        if ((this.onGround || this.onPlatform) && this.vy === 0) { this.scale.y = 1; this.scale.x = 1; }
        
        this.updateSpecialEffects(deltaTime);
        this.updateVFX(deltaTime);

        if (this.stats.magneticField.enabled) {
            [...expOrbs, ...coins].forEach(item => {
                const dx = this.x + this.width/2 - item.x; const dy = this.y + this.height/2 - item.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < this.stats.magneticField.range) { 
                    item.vx = (item.vx * 0.9) + (dx/dist * 8 * 0.1); item.vy = (item.vy * 0.9) + (dy/dist * 8 * 0.1);
                }
            });
        }
        if (gameManager.cheats.instantExp && this.exp < this.expToNextLevel) this.addExp(1, false);
    }
    
    updateSpecialEffects(deltaTime) {
        if (this.stats.thunderbolt.enabled) {
            this.stats.thunderbolt.timer -= deltaTime;
            if (this.stats.thunderbolt.timer <= 0) {
                this.stats.thunderbolt.timer = this.stats.thunderbolt.cooldown;
                for (let i = 0; i < this.stats.thunderbolt.count; i++) {
                    const validTargets = enemies.filter(e => e.active && !e.isAlly);
                    if (validTargets.length > 0) {
                        const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                        if(target) createLightningStrike(target.x + target.width/2, target.y + target.height/2, this.stats.thunderbolt.damage);
                    }
                }
            }
        }
        while (this.stats.laserPet.count > 0 && orbitalShields.filter(s => s.isPet).length < this.stats.laserPet.count) {
             orbitalShields.push(new OrbitalShield(this, true));
        }
        while (this.stats.orbitalShield.count > 0 && orbitalShields.filter(s => !s.isPet).length < this.stats.orbitalShield.count) {
             orbitalShields.push(new OrbitalShield(this, false));
        }
        if (this.stats.orbitalShield.count > 0 && this.stats.laserPet.count > 0) checkAchievement('pet_and_shield', 1);

        if (this.stats.singularityCore.enabled) {
            this.stats.singularityCore.timer -= deltaTime;
            if (this.stats.singularityCore.timer <= 0) {
                this.stats.singularityCore.timer = this.stats.singularityCore.cooldown;
                const pX = this.x + this.width / 2;
                const pY = this.y + this.height / 2;
                if(VISUAL_SETTINGS.cardEffectIntensity > 0) particles.push(...createParticleBurst(pX, pY, 30, 'rgba(156, 39, 176, 0.7)'));
                enemies.forEach(e => {
                    if (e.active && !e.isAlly) {
                        const dist = Math.hypot(e.x - pX, e.y - pY);
                        if (dist < 100) {
                            e.takeDamage(this.stats.singularityCore.damage);
                        }
                    }
                });
            }
        }

        if (this.stats.mirageClones.enabled) {
            this.stats.mirageClones.timer -= deltaTime;
            if (this.stats.mirageClones.timer <= 0) {
                this.stats.mirageClones.timer = this.stats.mirageClones.cooldown;
                for (let i = 0; i < this.stats.mirageClones.count; i++) {
                    const cloneX = this.x + (Math.random() - 0.5) * 200;
                    const cloneY = this.y;
                    mirageClones.push(new MirageClone(cloneX, cloneY, this.width, this.height, this.stats.mirageClones.duration));
                }
            }
        }
    }

    updateVFX(deltaTime) {
        const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
        const trailIntensity = VISUAL_SETTINGS.trailIntensity / 10;

        if (this.stats.catalyst.stacks > 0) { this.vfx.damageAuraOpacity = Math.min(0.1 + this.stats.catalyst.stacks * 0.05, 0.6) * effectIntensity; } 
        else { this.vfx.damageAuraOpacity = 0; }

        if (this.stats.swift.stacks > 0 && this.vx !== 0) {
            for (let i = 0; i < this.stats.swift.stacks * trailIntensity; i++) {
                if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width / 2, this.y + this.height * Math.random(), -this.vx * 0.1, (Math.random() - 0.5) * 2, Math.random() * 2, 'rgba(255,255,255,0.5)', 300));
            }
        }
        
        if (this.stats.growth.stacks > 0 && trailIntensity > 0 && Math.random() > 0.8) {
             if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, 0, 0, Math.random() * 3 + 1, 'rgba(76, 175, 80, 0.5)', 500));
        }

        if (this.stats.resonance.stacks > 0 && trailIntensity > 0) {
            this.vfx.attackSpeedTrail.push({x: this.x, y: this.y, alpha: 1.0, w: this.width, h: this.height, dir: this.facingDirection});
            if (this.vfx.attackSpeedTrail.length > 5 * this.stats.resonance.stacks * trailIntensity) { this.vfx.attackSpeedTrail.shift(); }
        }
        this.vfx.attackSpeedTrail.forEach(t => t.alpha -= 0.05);
        this.vfx.attackSpeedTrail = this.vfx.attackSpeedTrail.filter(t => t.alpha > 0);
        
        if (this.stats.eyesight.stacks > 0 && effectIntensity > 0) {
            this.vfx.critGlow += deltaTime;
            if (this.vfx.critGlow > (3000 / this.stats.eyesight.stacks) / effectIntensity) {
                 this.vfx.critGlow = 0;
                 if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new Particle(this.x + this.width/2, this.y, 0, -1, 15 * effectIntensity, 'rgba(255, 255, 0, 0.8)', 200));
            }
        }

        if (this.vfx.muzzleGlow > 0) { this.vfx.muzzleGlow -= deltaTime * 0.01; }
    }
    
    shoot(angleOverride = null) {
        gameManager.shotsFiredThisWave++;
        let angle;
        
        if (angleOverride !== null) {
            angle = angleOverride;
        } else if (gameManager.controlScheme === 'desktop') {
            angle = Math.atan2(mouse.y - (this.y + this.height / 2), mouse.x - (this.x + this.width / 2));
        } else { // mobile
            if (!shootingJoystick || !shootingJoystick.active) return;
            angle = shootingJoystick.angle;
        }

        for (let i = 0; i < this.stats.projectileCount; i++) {
            const spreadAngle = angle + (i - (this.stats.projectileCount-1)/2) * 0.2; let damage = this.stats.projectileDamage;
            const isCrit = Math.random() < this.stats.critChance;
            if(isCrit) {
                damage *= this.stats.critDamage; gameManager.stats.criticalHitsThisRun++;
                if (this.stats.timeWarp.enabled && Math.random() < this.stats.timeWarp.chance) {
                    gameManager.timeWarp.active = true;
                    gameManager.timeWarp.timer = this.stats.timeWarp.duration;
                }
            }
            if (this.stats.rage.enabled && this.hp < this.stats.maxHp * 0.3) damage *= 1.5;
            checkAchievement('single_hit_damage', damage);
            
            const pStats = JSON.parse(JSON.stringify(this.stats)); // Pass a copy of stats to projectile
            projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, Math.cos(spreadAngle) * 15, Math.sin(spreadAngle) * 15, damage, isCrit, this.stats.projectileSize, CONFIG.COLOR_PLAYER_PROJECTILE, true, pStats));
        }
        this.attackTimer = this.stats.attackSpeed;
        if(this.stats.attackSpeed < 100) checkAchievement('attack_speed_milestone', this.stats.attackSpeed);
        this.vfx.muzzleGlow = 1;
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createMuzzleFlash(this.x + this.width/2, this.y + this.height/2, angle, 10));
    }

    autoShoot() {
        const validEnemies = enemies.filter(e => e.active && !e.isAlly);
        if (validEnemies.length === 0) return;

        let closestEnemy = null;
        let min_dist = Infinity;
        validEnemies.forEach(e => {
            const dist = Math.hypot(this.x - e.x, this.y - e.y);
            if (dist < min_dist) {
                min_dist = dist;
                closestEnemy = e;
            }
        });

        if (closestEnemy) {
            const angle = Math.atan2((closestEnemy.y + closestEnemy.height / 2) - (this.y + this.height / 2), (closestEnemy.x + closestEnemy.width / 2) - (this.x + this.width / 2));
            this.shoot(angle);
            this.lastAutoFireTime = Date.now();
        }
    }

    jump() { 
        if (this.jumps < (gameManager.cheats.infiniteJumps ? 100 : this.stats.maxJumps)) { 
            this.vy = -this.stats.jumpForce; this.onGround = false; this.jumps++; gameManager.jumpsThisRun++;
            this.scale.y = 0.7; this.scale.x = 1.3; 
            const playerColorData = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor);
            const playerColor = Array.isArray(playerColorData.value) ? playerColorData.value[0] : playerColorData.value;
            if (VISUAL_SETTINGS.particleIntensity > 0) {
                particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height, 10 + (this.upgrades['Gush'] || 0) * 5, playerColor));
                particles.push(...createJumpDust(this.x + this.width/2, this.y + this.height, 15));
            }
        } 
    }
    
    draw(ctx) { 
        ctx.save(); 
        if (this.invincibleTimer > 0) {
            ctx.globalAlpha = Math.abs(Math.sin(Date.now() / 50));
        }
        
        this.drawVFX(ctx);

        const centerX = this.x + this.width / 2; 
        const centerY = this.y + this.height / 2;
        
        ctx.translate(centerX, centerY); 
        ctx.scale(this.scale.x, this.scale.y); 
        ctx.translate(-centerX, -centerY); 
        
        renderCharacter(ctx, this.x, this.y, this.width, this.height, this.facingDirection, this.vfx.isGlass);
        
        ctx.restore(); 
        ctx.shadowBlur = 0; 
    }

    drawVFX(ctx) {
        this.vfx.attackSpeedTrail.forEach(trail => {
            ctx.save();
            ctx.globalAlpha = trail.alpha * 0.3 * (VISUAL_SETTINGS.trailIntensity / 7);
            renderCharacter(ctx, trail.x, trail.y, trail.w, trail.h, trail.dir, this.vfx.isGlass);
            ctx.restore();
        });

        if (this.vfx.damageAuraOpacity > 0) {
            ctx.save();
            const grad = ctx.createRadialGradient(this.x + this.width/2, this.y + this.height/2, this.width/2, this.x + this.width/2, this.y + this.height/2, this.width);
            grad.addColorStop(0, 'rgba(255, 60, 0, 0.5)');
            grad.addColorStop(1, 'rgba(255, 150, 0, 0)');
            ctx.fillStyle = grad;
            ctx.globalAlpha = Math.random() * 0.5 + this.vfx.damageAuraOpacity;
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        if (this.vfx.muzzleGlow > 0) {
            const stacks = this.upgrades['MultiShot'] || 0;
            const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
            ctx.save();
            ctx.globalAlpha = this.vfx.muzzleGlow;
            ctx.fillStyle = '#ffcc00';
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = (5 + stacks * 5) * effectIntensity;
            ctx.beginPath();
            const muzzleX = this.x + this.width/2 + (this.facingDirection * (this.width / 2));
            const muzzleY = this.y + this.height/2;
            ctx.arc(muzzleX, muzzleY, (5 + stacks * 2) * effectIntensity, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        const magStacks = this.upgrades['Magnetic Field'] || 0;
        if (magStacks > 0) {
            ctx.save();
            ctx.strokeStyle = `rgba(100, 180, 255, ${0.1 + magStacks * 0.02})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.stats.magneticField.range, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        if(this.stats.rage.enabled && this.hp < this.stats.maxHp * 0.3) {
            ctx.save();
            const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
            ctx.globalAlpha = (0.3 + Math.sin(Date.now() / 100) * 0.2) * effectIntensity;
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20 * effectIntensity;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        if(this.stats.barrier.enabled && this.stats.barrier.active) {
            ctx.save();
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    takeDamage(amount) { 
        if (gameManager.cheats.immortality || this.invincibleTimer > 0) return;
        lastDamageWave = gameManager.wave; gameManager.noDamageWaves = 0; gameManager.runFlags.tookDamageThisWave = true;
        
        if (this.stats.barrier.enabled && this.stats.barrier.active) {
            this.stats.barrier.active = false; this.stats.barrier.timer = this.stats.barrier.cooldown;
            gameManager.barrierBlocks++; checkAchievement('barrier_blocks', gameManager.barrierBlocks);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height/2, 20, 'cyan'));
            floatingTexts.push(new FloatingText('ESCUDO!', this.x + this.width/2, this.y, '#00ffff', 20));
            if (gameManager.waveState === 'SPAWNING' && enemies.some(e => e.isBoss)) { checkAchievement('barrier_boss_hit', 1); }
            return;
        }
        
        this.hp -= amount; this.invincibleTimer = 500; screenShake = { duration: 200, magnitude: VISUAL_SETTINGS.screenShakeIntensity }; 
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width / 2, this.y + this.height / 2, 20, 'red'));
        if (VISUAL_SETTINGS.blood) createBloodSplatter(this.x + this.width/2, this.y + this.height/2, amount * 2);
        createDamageIndicator(this.x + this.width/2, this.y, amount);
        
        if (this.stats.frostNova.enabled) {
            let frozenCount = 0;
            enemies.forEach(e => {
                const dx = e.x - this.x, dy = e.y - this.y;
                if(Math.sqrt(dx*dx + dy*dy) < 150) { 
                    e.isFrozen = true; frozenCount++;
                    setTimeout(() => e.isFrozen = false, this.stats.frostNova.duration); 
                }
            });
            if (frozenCount > 0) {
                gameManager.frozenEnemiesThisRun += frozenCount;
                checkAchievement('frozen_enemies', gameManager.frozenEnemiesThisRun);
            }
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 30, '#00ffff'));
        }
        
        if (this.stats.holyRetribution.enabled) {
            for(let i=0; i < this.stats.holyRetribution.count; i++) {
                const validTargets = enemies.filter(e => e.active && !e.isAlly);
                if (validTargets.length > 0) {
                    const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                    if(target) createHolyBeam(target.x + target.width/2, this.stats.holyRetribution.damage);
                }
            }
        }

        if (this.hp <= 0) { 
            this.hp = 0; if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createDeathExplosion(this.x + this.width/2, this.y + this.height/2, 50));
            if (gameManager.wave % 5 === 0) checkAchievement('death_on_boss_wave', 1);
            checkAchievement('death_with_coins', gameManager.coinsInRun);
            gameManager.stats.deathsThisRun++;
            gameManager.gameOver = true;
        } 
    }
    
    addExp(amount, fromOrb=true) { 
        if (fromOrb) gameManager.xpOrbsCollected++; checkAchievement('xp_orbs', gameManager.xpOrbsCollected);
        this.exp += amount; gameManager.totalExpThisRun += amount;
        while (this.exp >= this.expToNextLevel) { this.exp -= this.expToNextLevel; this.levelUp(); } 
    }
    
    levelUp() { 
        this.level++; this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5); this.hp = this.stats.maxHp; 
        checkAchievement('level', this.level);
        gameManager.paused = true; showUpgradeScreen(); 
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x + this.width/2, this.y + this.height/2, 50, 'gold')); 
        floatingTexts.push(new FloatingText(`NÍVEL ${this.level}!`, canvas.width/2, canvas.height/2, 'gold', 40));
    }
    
    addCoin(amount) {
        const coinGainBonus = PERMANENT_UPGRADES_CATALOG['perm_coins'].effect(PLAYER_PERMANENT_UPGRADES['perm_coins'] || 0);
        const finalAmount = Math.ceil(amount * coinGainBonus);
        gameManager.stats.coins += finalAmount;
        gameManager.coinsInRun += finalAmount;
        checkAchievement('coins_in_run', gameManager.coinsInRun);
        floatingTexts.push(new FloatingText(`+${finalAmount} Moedas`, this.x + this.width/2, this.y, '#ffd700', 20));
        updateMetaProgression(); 
    }

    addUpgrade(upgradeKey) {
        const upgrade = UPGRADES[upgradeKey]; if (!upgrade) return;
        const currentStacks = this.upgrades[upgradeKey] || 0;
        if (upgrade.maxStacks && currentStacks >= upgrade.maxStacks) return; 
        
        upgrade.apply(this); this.upgrades[upgradeKey] = (this.upgrades[upgradeKey] || 0) + 1;
        
        if (upgradeKey === 'GlassCannon') this.vfx.isGlass = true;
        
        const a_data = { rarity: upgrade.rarity };
        checkAchievement('collect_rarity', a_data);
        checkAchievement('unique_cards', Object.keys(this.upgrades).length);
        if(upgradeKey === 'LaserPet') checkAchievement('stat_check', {'subtype': 'laserPet.count', 'value': this.stats.laserPet.count});
        
        checkAchievement('stat_milestone', { subtype: 'critChance', value: this.stats.critChance });
        checkAchievement('stat_milestone', { subtype: 'maxHp', value: this.stats.maxHp });
        checkAchievement('stack_rarity', { rarity: upgrade.rarity, stacks: this.upgrades[upgradeKey] });
        checkAchievement('card_combo', this.upgrades);
        checkAchievement('all_rarities_in_run', 1);

        updateIngameCardsUI();
    }

    createShockwave() {
        const pX = this.x + this.width / 2;
        const pY = this.y + this.height;
        const { damage, radius } = this.stats.shockwaveJump;
        if(VISUAL_SETTINGS.cardEffectIntensity > 0) particles.push(...createShockwaveEffect(pX, pY, radius));
        enemies.forEach(e => {
            if (e.active && !e.isAlly && e.y + e.height > pY - 20) { // On the ground
                const dist = Math.abs(e.x - pX);
                if (dist < radius) {
                    e.takeDamage(damage);
                }
            }
        });
    }
}

class Enemy extends Entity { 
    constructor(x, y, type) { 
        const d = ENEMY_TYPES[type]; super(x, y, d.size, d.size, d.color); 
        this.type = type;

        let hpMultiplier = 1.0; let damageMultiplier = 1.0; let cooldownMultiplier = 1.0;
        if (gameManager.difficulty === 'easy') { hpMultiplier = 0.5; damageMultiplier = 0.5; cooldownMultiplier = 1.5; } 
        else if (gameManager.difficulty === 'normal') { hpMultiplier = 0.75; damageMultiplier = 0.9; }

        this.maxHp = d.hp * (1 + (gameManager.wave - 1) * 0.1) * hpMultiplier; 
        this.hp = this.maxHp; 
        this.speed = d.speed; 
        this.shootCooldown = d.attackCooldown * cooldownMultiplier; 
        this.shootTimer = Math.random() * this.shootCooldown; 
        this.damageValue = (d.type === 'bomber' ? 20 : 10) * damageMultiplier;

        this.behavior = d.behavior; 
        this.targetY = CONFIG.PLATFORM_MIN_Y + Math.random() * (CONFIG.PLATFORM_MAX_Y - CONFIG.PLATFORM_MIN_Y);
        this.expValue = d.expValue; this.isBoss = d.isBoss || false; this.isFrozen = false; this.isAlly = false; 
        this.allyTimer = 0;
        this.specialAttack = d.specialAttack;
        this.specialCooldown = d.specialCooldown || 0;
        this.specialTimer = this.specialCooldown;
        this.behaviorTimer = Math.random() * 3000 + 2000;
        
        // v7.8+ - Anti-Frustration System
        this.lastDamageTime = 0;
        this.isBeingRescued = false;
    } 
    update(dt, p) { 
        if (gameManager.cheats.freezeEnemies || this.isFrozen) return; 

        // MODIFIED [v7.9]: Lógica de resgate simplificada.
        if (this.isBeingRescued) {
            const targetX = CONFIG.WIDTH / 2;
            const targetY = 150;
            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 20) {
                const pullSpeed = 5;
                this.x += (dx / dist) * pullSpeed;
                this.y += (dy / dist) * pullSpeed;
            } else {
                // Chegou ao destino. Libere o inimigo para sua IA normal.
                this.isBeingRescued = false;
            }
            return; // Interrompe o resto da IA enquanto está sendo puxado.
        }


        if (this.isAlly) {
            this.allyTimer -= dt; if (this.allyTimer <= 0) { this.die(true); return; }
            let closestEnemy = null; let min_dist = Infinity;
            enemies.forEach(e => {
                if(e !== this && !e.isAlly) {
                    const dist = Math.hypot(this.x - e.x, this.y - e.y);
                    if (dist < min_dist) { min_dist = dist; closestEnemy = e; }
                }
            });
            if (closestEnemy) {
                const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                this.x += Math.cos(angle) * this.speed * 0.7; this.y += Math.sin(angle) * this.speed * 0.7;
                this.shootTimer -= dt;
                if (this.shootTimer <= 0) { this.shoot(closestEnemy, true); this.shootTimer = this.shootCooldown * 1.5; }
            }
            return;
        }

        let target = p;
        if(mirageClones.length > 0 && !this.isAlly) {
            let closestDist = Math.hypot(this.x - p.x, this.y - p.y);
            let closestTarget = p;
            mirageClones.forEach(clone => {
                const dist = Math.hypot(this.x - clone.x, this.y - clone.y);
                if(dist < closestDist) {
                    closestDist = dist;
                    closestTarget = clone;
                }
            });
            target = closestTarget;
        }
        
        this.behaviorTimer -= dt;
        if(this.behaviorTimer <= 0) {
            if(this.behavior === 'teleporting') {
                const oldX = this.x, oldY = this.y;
                this.x = target.x + (Math.random() - 0.5) * 300; this.y = target.y + (Math.random() - 0.5) * 200;
                if (VISUAL_SETTINGS.particleIntensity > 0) {
                    particles.push(...createParticleBurst(oldX, oldY, 20, this.color, 0.5));
                    particles.push(...createParticleBurst(this.x, this.y, 20, this.color));
                }
                this.behaviorTimer = 3000;
            }
            if(this.behavior === 'support') { // Healer
                enemies.forEach(e => {
                    if (e !== this && !e.isAlly && e.hp < e.maxHp && Math.hypot(this.x - e.x, this.y - e.y) < 100) {
                        e.hp = Math.min(e.maxHp, e.hp + 10);
                        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new LifestealParticle(this.x, this.y, e, '#4caf50'));
                    }
                });
                this.behaviorTimer = 2500;
            }
        }
        
        const angle = Math.atan2(target.y - this.y, target.x - this.x);
        if (this.behavior === 'flying' || this.behavior === 'teleporting') {
            this.x += Math.cos(angle) * this.speed * 0.5; this.y += Math.sin(angle) * this.speed * 0.5;
        } else if (this.behavior !== 'support') {
            this.vx = Math.cos(angle) * this.speed * 0.5; this.vy += CONFIG.GRAVITY; this.x += this.vx; this.y += this.vy;
            const groundY = getGroundHeightAt(this.x + this.width / 2);
            if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; }
        }
        if (this.shootTimer > 0) this.shootTimer -= dt; 
        if(this.shootTimer <= 0 && this.type !== 'exploder' && target === p){ this.shoot(p, false); this.shootTimer = this.shootCooldown; } 
        if(this.isBoss){ this.specialTimer -= dt; if(this.specialTimer <= 0) { this.useSpecialAttack(p); this.specialTimer = this.specialCooldown; }}
    } 
    draw(ctx){ 
        ctx.fillStyle = this.isAlly ? '#4caf50' : this.color; if(this.isFrozen) ctx.fillStyle = '#add8e6';
        if(this.isAlly) {
            ctx.save();
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
        }
        ctx.shadowColor = this.isAlly ? '#4caf50' : this.color; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0; 
        
        // Custom shapes
        switch(this.type) {
            case 'tank': ctx.fillRect(this.x, this.y, this.width * 1.2, this.height * 0.8); break;
            case 'flyer': drawShapeTriangle(ctx, this.x, this.y, this.width, this.height, ctx.fillStyle); break;
            case 'elite': drawShapeHexagon(ctx, this.x, this.y, this.width, this.height, ctx.fillStyle); break;
            default: ctx.fillRect(this.x, this.y, this.width, this.height); break;
        }

        // Custom details
        if(this.type === 'healer' && Math.floor(Date.now()/200) % 2 === 0) {
             ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 5, 0, Math.PI*2); ctx.fill();
        }
        if(this.type === 'shooter' || this.type === 'bouncer') {
            const facing = (player.x > this.x) ? 1 : -1;
            ctx.fillStyle = 'black';
            ctx.fillRect(this.x + (facing > 0 ? this.width : -10), this.y + this.height/2 - 2, 10, 4);
        }
        if(this.type === 'bomber' && Math.floor(Date.now()/500) % 2 === 0) {
             ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 5, 0, Math.PI*2); ctx.fill();
        }
        if(this.isBoss) {
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + 10, this.y - 10); ctx.lineTo(this.x + 20, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width - 10, this.y - 10); ctx.lineTo(this.x + this.width - 20, this.y); ctx.fill();
        }
        if(this.isAlly) ctx.restore();

        ctx.shadowBlur = 0; 
        if(this.hp < this.maxHp){ 
            ctx.fillStyle='#555'; ctx.fillRect(this.x, this.y-10, this.width, 5); 
            ctx.fillStyle='red'; ctx.fillRect(this.x, this.y-10, this.width*(this.hp/this.maxHp), 5); 
        } 
        if (this.isBoss) { ctx.fillStyle = 'gold'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText('CHEFE', this.x + this.width/2, this.y - 15); }
    } 
    shoot(target, isAllyShot){ 
        const a = Math.atan2((target.y + target.height/2) - (this.y + this.height/2), (target.x + target.width/2) - (this.x + this.width/2));
        const color = isAllyShot ? '#00ff00' : CONFIG.COLOR_ENEMY_PROJECTILE;
        const damage = isAllyShot ? 10 : this.damageValue;
        const pStats = this.type === 'bouncer' ? {ricochet: {enabled: true, maxBounces: 2, chance: 1}} : {};
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createMuzzleFlash(this.x + this.width/2, this.y + this.height/2, a, 5));
        projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height/2, Math.cos(a)*8, Math.sin(a)*8, damage, false, 5, color, isAllyShot, pStats)); 
    } 
    useSpecialAttack(target){
        switch(this.specialAttack) {
            case 'frost_nova':
                damageZones.push(new DamageZone(this.x, this.y, this.size * 3, this.size * 3, 500, 5, true, 'rgba(173, 216, 230, 0.5)'));
                player.isFrozen = true;
                setTimeout(() => { player.isFrozen = false; }, 2000);
                break;
            case 'summon_minions':
                for(let i=0; i<3; i++) {
                    enemies.push(new Enemy(this.x + (i-1)*50, this.y - 20, 'grunt'));
                }
                break;
            case 'fire_trail':
                damageZones.push(new DamageZone(this.x, this.y, this.width, this.height, 3000, 2, false, 'rgba(255, 69, 0, 0.5)'));
                break;
            case 'laser_beam':
                damageZones.push(new DamageZone(0, this.y, CONFIG.WIDTH, 20, 1500, 25, false, 'rgba(255, 0, 0, 0.6)'));
                break;
            case 'pollen_cloud':
                 damageZones.push(new DamageZone(this.x - 50, this.y - 50, 100, 100, 4000, 1, true, 'rgba(255, 220, 120, 0.3)'));
                 break;
            case 'crystal_shot':
                 for(let i=0; i < 5; i++){
                    const angle = Math.atan2(target.y - this.y, target.x - this.x) + (i - 2) * 0.3;
                    projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height/2, Math.cos(angle)*6, Math.sin(angle)*6, this.damageValue * 0.7, false, 4, this.color, false, {}));
                 }
                 break;
        }
    }
    takeDamage(am, byPlayer=true, fromBlackHole=false){ 
        // MODIFIED [v7.9]: Simplificado para sempre atualizar o tempo e cancelar o resgate.
        this.isBeingRescued = false;
        this.lastDamageTime = gameManager.gameTime;

        if (this.isAlly && byPlayer) { this.die(false); return; }
        if (this.isAlly && !byPlayer) return; 
        
        this.hp -= am; 
        
        if (byPlayer && player.stats.quantumEntanglement.enabled) {
            const sharedDamage = am * player.stats.quantumEntanglement.sharePercent;
            const otherEnemies = enemies.filter(e => e.active && !e.isAlly && e !== this);
            for(let i=0; i < player.stats.quantumEntanglement.targets && otherEnemies.length > 0; i++) {
                const targetIndex = Math.floor(Math.random() * otherEnemies.length);
                const target = otherEnemies.splice(targetIndex, 1)[0];
                target.takeDamage(sharedDamage, false);
                createDamageIndicator(target.x + target.width/2, target.y, sharedDamage);
                if (VISUAL_SETTINGS.cardEffectIntensity > 0) createTetherEffect(this.x, this.y, target.x, target.y, 'rgba(156, 39, 176, 0.7)');
            }
        }

        if(VISUAL_SETTINGS.blood) createBloodSplatter(this.x + this.width/2, this.y + this.height/2, am * 5); 
        createDamageIndicator(this.x + this.width/2, this.y, am); this.vy = -5; 
        if (VISUAL_SETTINGS.particleIntensity > 0) {
            for (let i = 0; i < am * 2; i++) particles.push(new BloodParticle(this.x+this.width/2, this.y+this.height/2, (Math.random()-0.5)*3, (Math.random()-0.5)*3 - 2, Math.random()*3+2, '#ff0000', 2000)); 
        }
        if (byPlayer && player.stats.lifesteal > 0) {
            const heal = am * player.stats.lifesteal;
            player.hp = Math.min(player.stats.maxHp, player.hp + heal);
            gameManager.healingDoneThisRun += heal; gameManager.stats.totalHealing += heal;
            checkAchievement('healing', gameManager.healingDoneThisRun); checkAchievement('total_healing', gameManager.stats.totalHealing);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(new LifestealParticle(this.x + this.width/2, this.y + this.height/2, player));
        }
        if(this.hp<=0){ 
            if (fromBlackHole) gameManager.blackHoleKillsThisRun++; checkAchievement('black_hole_kills', gameManager.blackHoleKillsThisRun);
            if (player.stats.rage.enabled && player.hp < player.stats.maxHp * 0.3) gameManager.rageKillsThisRun++; checkAchievement('rage_kills', gameManager.rageKillsThisRun);
            this.die(false); 
        } 
    }
    
    die(wasAlly) {
        if (!this.active) return; this.active = false;
        
        if (this.type === 'exploder' && !wasAlly) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            damageZones.push(new DamageZone(0, centerY - 5, CONFIG.WIDTH, 10, 2000, 15)); // Horizontal
            damageZones.push(new DamageZone(centerX - 5, 0, 10, CONFIG.HEIGHT, 2000, 15)); // Vertical
            gameManager.exploderKillsThisRun++;
            checkAchievement('exploder_kills', gameManager.exploderKillsThisRun);
        }
        if (this.type === 'splitter' && !wasAlly) {
            enemies.push(new Enemy(this.x - 10, this.y, 'grunt_mini'));
            enemies.push(new Enemy(this.x + 10, this.y, 'grunt_mini'));
        }
        
        if (wasAlly) {
            const healAmount = player.stats.maxHp * player.stats.tempAlliance.healBonus;
            player.hp = Math.min(player.stats.maxHp, player.hp + healAmount);
            gameManager.healingDoneThisRun += healAmount; checkAchievement('healing', gameManager.healingDoneThisRun);
            floatingTexts.push(new FloatingText(`+${Math.round(healAmount)}`, player.x, player.y, '#00ff00'));
        } else {
            if (player && player.stats.tempAlliance && Math.random() < player.stats.tempAlliance.chance) {
                this.active = true; this.isAlly = true; this.hp = this.maxHp / 2; this.allyTimer = player.stats.tempAlliance.duration; 
                checkAchievement('convert_enemy_type', this.type);
                return;
            }
            
            gameManager.killsThisRun++; 
            checkAchievement('kills', gameManager.killsThisRun);
            checkAchievement('first_kill_difficulty', { difficulty: gameManager.difficulty, kills: gameManager.killsThisRun });
            gameManager.runFlags.multiKillCounter++; gameManager.runFlags.multiKillTimer = 2000;
            checkAchievement('multi_kill_in_time', gameManager.runFlags.multiKillCounter);

            if(gameManager.stats.killCounts[this.type]) gameManager.stats.killCounts[this.type]++; else gameManager.stats.killCounts[this.type] = 1;
            checkAchievement('kill_type', { subtype: this.type, count: gameManager.stats.killCounts[this.type] });
            if (this.isBoss) { gameManager.bossKillsThisRun++; checkAchievement('boss_kills', gameManager.bossKillsThisRun); checkAchievement('fast_boss_kill', Date.now() - gameManager.runFlags.bossSpawnTime); }
            if (Math.random() < CONFIG.COIN_DROP_CHANCE) coins.push(new Coin(this.x + this.width/2, this.y + this.height/2));
            if (player && player.stats.bloodRitual.chance > 0 && Math.random() < player.stats.bloodRitual.chance) {
                expOrbs.push(new ExpOrb(this.x + this.width/2, this.y + this.height/2, 10, true));
            }
            expOrbs.push(new ExpOrb(this.x+this.width/2, this.y+this.height/2, this.expValue));

            if (player.stats.vampiricExplosion.enabled && Math.random() < player.stats.vampiricExplosion.chance) {
                const healAmount = player.stats.maxHp * player.stats.vampiricExplosion.healPercent;
                player.hp = Math.min(player.stats.maxHp, player.hp + healAmount);
                gameManager.healingDoneThisRun += healAmount;
                checkAchievement('healing', gameManager.healingDoneThisRun);
                if (VISUAL_SETTINGS.particleIntensity > 0) {
                    particles.push(...createParticleBurst(this.x, this.y, 20, 'rgba(255, 0, 0, 0.7)'));
                    particles.push(new LifestealParticle(this.x, this.y, player));
                }
            }
        }
        if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x+this.width/2, this.y+this.height/2, CONFIG.PARTICLE_COUNT, this.color)); 
    }
}

class Projectile extends Entity { 
    constructor(x, y, vx, vy, d, c, s, co, isPlayer, pStats, l=5000) { 
        super(x, y, s, s, co); this.vx=vx; this.vy=vy; this.damage=d; this.isPlayer=isPlayer; 
        this.isCrit=c; this.lifetime=l; this.trail=[]; 
        this.pStats = pStats;
        this.hitCount = 0;
        this.maxHitCount = this.pStats.piercing?.enabled ? this.pStats.piercing.hits : 1;
        this.ricochetBouncesLeft = this.pStats.ricochet?.enabled ? this.pStats.ricochet.maxBounces : 0;
        this.returning = false;
        this.isGhost = this.pStats.ghostBullets?.enabled && Math.random() < this.pStats.ghostBullets.chance;
    } 
    update(dt){ 
        if(VISUAL_SETTINGS.trailIntensity > 0) {
            this.trail.push({x:this.x, y:this.y}); if(this.trail.length > 10 * (VISUAL_SETTINGS.trailIntensity / 7)) this.trail.shift(); 
        }
        this.x+=this.vx; this.y+=this.vy; this.lifetime-=dt; 
        
        if (this.isPlayer && this.pStats.ouroborosRounds?.enabled && this.lifetime < 3000 && !this.returning && this.hitCount === 0) {
            if (Math.random() < this.pStats.ouroborosRounds.chance) {
                this.returning = true;
                this.lifetime = 5000;
            }
        }

        if (this.returning) {
            const dx = player.x + player.width/2 - this.x; const dy = player.y + player.height/2 - this.y;
            const dist = Math.hypot(dx, dy); if (dist < player.width) { this.active = false; }
            const speed = Math.hypot(this.vx, this.vy);
            this.vx = (dx/dist) * speed; this.vy = (dy/dist) * speed;
        }

        if(this.lifetime<=0) this.active = false;
        
        if (this.pStats.ricochet?.enabled && this.ricochetBouncesLeft > 0) {
            if ((this.x <= 0 && this.vx < 0) || (this.x >= canvas.width && this.vx > 0)) {
                this.vx *= -1; this.ricochetBouncesLeft--; this.color = '#add8e6'; if(this.isPlayer) this.aimAtNearestEnemy(); gameManager.ricochetsThisRun++; checkAchievement('ricochets', gameManager.ricochetsThisRun);
            }
            if ((this.y <= 0 && this.vy < 0) || (this.y + this.vy > getGroundHeightAt(this.x))) {                this.vy *= -1; this.ricochetBouncesLeft--; this.color = '#add8e6'; if(this.isPlayer) this.aimAtNearestEnemy(); gameManager.ricochetsThisRun++; checkAchievement('ricochets', gameManager.ricochetsThisRun);
            }
        } else if (!this.isGhost) {
             if(this.x<0 || this.x>canvas.width || this.y<0 || this.y>canvas.height) this.active = false;
        }
    } 
    
    aimAtNearestEnemy() {
        let closest = null, min_dist = Infinity;
        enemies.forEach(e => {
            if (e.active && !e.isAlly) {
                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                if (dist < min_dist) { min_dist = dist; closest = e; }
            }
        });
        if (closest) {
            const angle = Math.atan2(closest.y - this.y, closest.x - this.x); const speed = Math.hypot(this.vx, this.vy);
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        }
    }

    draw(ctx){ 
        const trailColor = (this.pStats.ricochet?.enabled && this.ricochetBouncesLeft < this.pStats.ricochet.maxBounces) ? '#add8e6' : this.color;
        const critStacks = (player?.upgrades['Precision'] || 0);
        const critSize = this.isCrit ? 1 + critStacks * 0.1 : 1;
        const effectIntensity = VISUAL_SETTINGS.cardEffectIntensity / 10;
        
        // Efeito de fogo para 'Catalyst'
        if (this.isPlayer && this.pStats.catalyst?.stacks > 0) {
             if(VISUAL_SETTINGS.trailIntensity > 0) particles.push(new Particle(this.x, this.y, 0, 0, this.width * 2, 'rgba(255,100,0,0.2)', 200));
        }
        
        ctx.globalAlpha = this.isGhost ? 0.5 : 1;

        if (VISUAL_SETTINGS.trailIntensity > 0) {
            for(let i=0;i<this.trail.length;i++){ 
                const t=this.trail[i], r=i/this.trail.length; 
                ctx.beginPath(); ctx.arc(t.x,t.y,this.width*r*critSize,0,Math.PI*2); ctx.fillStyle=trailColor; ctx.globalAlpha=r*0.5 * (this.isGhost ? 0.5 : 1) * (VISUAL_SETTINGS.trailIntensity / 7); ctx.fill(); 
            } 
        }
        ctx.globalAlpha=this.isGhost ? 0.5 : 1; ctx.fillStyle=this.color; ctx.shadowColor=this.color; 
        ctx.shadowBlur=this.isCrit && VISUAL_SETTINGS.shadows ? (30 + critStacks * 5) * effectIntensity : 0; 
        ctx.beginPath(); ctx.arc(this.x, this.y, this.width * critSize, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0; 
        ctx.globalAlpha = 1;
    } 
}

class Particle extends Entity { 
    constructor(x,y,vx,vy,s,c,l) { super(x,y,s,s,c); this.vx=vx; this.vy=vy; this.lifespan=l; this.initialLifespan=l; } 
    update(dt){ this.x+=this.vx; this.y+=this.vy; this.vy+=CONFIG.GRAVITY*0.1; this.lifespan-=dt; if(this.lifespan<=0) this.active=false; } 
    draw(ctx){ const a=this.lifespan/this.initialLifespan; ctx.globalAlpha=a; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.width*a,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; } 
}

class LifestealParticle extends Particle {
    constructor(startX, startY, target, color = 'rgba(255, 80, 80, 0.8)') {
        super(startX, startY, 0, 0, 5, color, 1000);
        this.target = target;
    }
    update(dt) {
        if (!this.target) { this.active = false; return; }
        const dx = (this.target.x + this.target.width / 2) - this.x;
        const dy = (this.target.y + this.target.height / 2) - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 10) { this.active = false; return; }
        this.vx = dx / dist * 10;
        this.vy = dy / dist * 10;
        super.update(dt);
    }
}

class BloodParticle extends Particle { 
    constructor(x, y, vx, vy, s, c, l) { super(x, y, vx, vy, s, c, l); } 
    update(dt) { this.x += this.vx; this.y += this.vy; this.vy += CONFIG.GRAVITY * 0.5; this.lifespan -= dt; if (this.lifespan <= 0) this.active = false; } 
}

class FloatingText { 
    constructor(t,x,y,c,s=20){ this.text=t; this.x=x; this.y=y; this.color=c; this.size=s; this.vy=-2; this.lifespan=1000; this.active=true; } 
    update(dt){ this.y+=this.vy; this.lifespan-=dt; if(this.lifespan<=0) this.active=false; } 
    draw(ctx){ ctx.save(); ctx.globalAlpha=this.lifespan/1000; ctx.fillStyle=this.color; ctx.font=`bold ${this.size}px 'Segoe UI'`; ctx.textAlign='center'; ctx.shadowColor='black'; ctx.shadowBlur=8; ctx.fillText(this.text,this.x,this.y); ctx.restore(); } 
}

class ExpOrb extends Entity { 
    constructor(x,y,v,h=false){ 
        const s=h?12:8, c=h?'lightgreen':'#ffd700'; super(x,y,s,s,c); this.value=v; this.isHeal=h; this.vy = -3; this.vx = (Math.random() - 0.5) * 2;
    } 
    update(dt,p){ 
        if(!this.isHeal) this.vy += CONFIG.GRAVITY * 0.3; this.x += this.vx; this.y += this.vy;
        const groundY = getGroundHeightAt(this.x);
        if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; this.vx *= 0.8; }
        const dist=Math.hypot(p.x+p.width/2-this.x, p.y+p.height/2-this.y); 
        if(dist < p.width/2 + 5){ 
            this.active=false; 
            if(this.isHeal){
                const healAmount = 10;
                p.hp=Math.min(p.stats.maxHp,p.hp+healAmount);
                gameManager.healingDoneThisRun += healAmount; checkAchievement('healing', gameManager.healingDoneThisRun);
                floatingTexts.push(new FloatingText('+10 HP', this.x, this.y, '#00ff00', 20));
            } 
            else { p.addExp(this.value); floatingTexts.push(new FloatingText(`+${this.value} XP`, this.x, this.y, '#ffd700', 20)); } 
        } 
    } 
    draw(ctx){ ctx.fillStyle=this.color; ctx.shadowColor=this.color; ctx.shadowBlur=VISUAL_SETTINGS.shadows ? 15 : 0; ctx.beginPath(); ctx.arc(this.x,this.y,this.width,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; } 
}

class Coin extends Entity {
    constructor(x, y) {
        super(x, y, 10, 10, '#ffd700'); this.value = 1; this.rotation = Math.random() * Math.PI * 2; this.vy = -3; this.vx = (Math.random() - 0.5) * 2;
    }
    update(dt, p) {
        this.rotation += dt * 0.005; this.vy += CONFIG.GRAVITY * 0.3; this.x += this.vx; this.y += this.vy;
        const groundY = getGroundHeightAt(this.x);
        if (this.y + this.height > groundY) { this.y = groundY - this.height; this.vy = 0; this.vx *= 0.8; }
        if (player) { const dist = Math.hypot(p.x + p.width/2 - this.x, p.y + p.height/2 - this.y); if (dist < p.width/2) { this.active = false; p.addCoin(this.value); } }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(this.rotation);
        ctx.fillStyle = this.color; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.beginPath(); ctx.arc(0, 0, this.width, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ffaa00'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', 0, 1); 
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class BlackHole { 
    constructor(x, y, stats) { 
        this.x = x; this.y = y;
        this.radius = stats.radius; this.duration = stats.duration;
        this.damagePercent = stats.damagePercent; this.tickRate = stats.tickRate;
        this.timer = this.duration; this.tickTimer = this.tickRate;
        this.active = true; this.glowTimer = 0; this.kills = 0;
    } 
    update(dt) { 
        this.timer -= dt; this.tickTimer -= dt;
        if (this.timer <= 0) { 
            this.active = false; 
            checkAchievement('black_hole_multikill', this.kills);
            if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 50, '#9c27b0')); 
            return; 
        } 

        let doDamage = false;
        if(this.tickTimer <= 0) {
            doDamage = true;
            this.tickTimer = this.tickRate;
        }

        enemies.forEach(e => { 
            if (e.active && !e.isAlly) { 
                const dx = this.x - (e.x + e.width/2); const dy = this.y - (e.y + e.height/2); 
                const dist = Math.hypot(dx, dy); 
                if (dist < this.radius * 2.5) { 
                    const force = 1.5 * (1 - dist/(this.radius * 2.5)); 
                    e.x += (dx/dist) * force; e.y += (dy/dist) * force; 
                    if (dist < this.radius * 0.8 && doDamage) {
                        const hpBefore = e.hp;
                        const damage = e.maxHp * this.damagePercent;
                        e.takeDamage(damage, true, true);
                        if (e.hp <= 0 && hpBefore > 0) { this.kills++; }
                    }
                } 
            } 
        }); 
    } 
    draw(ctx) { 
        const lifeRatio = this.timer / this.duration;
        const currentRadius = this.radius * Math.sin(Math.PI * (1 - lifeRatio)); // Grow and shrink
        ctx.save();
        ctx.globalAlpha = 0.8 * lifeRatio; 
        
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentRadius);
        grad.addColorStop(0, 'rgba(0,0,0,1)');
        grad.addColorStop(0.7, 'rgba(156, 39, 176, 0.5)');
        grad.addColorStop(1, 'rgba(156, 39, 176, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, currentRadius, 0, Math.PI*2); 
        ctx.fill(); 
        ctx.restore();
    } 
}

class OrbitalShield {
    constructor(player, isPet) {
        this.player = player; this.isPet = isPet; this.radius = isPet ? 8 : 12; this.color = isPet ? '#ff4081' : '#00ffff';
        this.orbitRadius = 80; this.angle = Math.random() * Math.PI * 2; this.active = true; this.shootTimer = isPet ? player.stats.laserPet.attackSpeed : 0;
    }
    update(dt) {
        if (!this.player || !this.player.active) { this.active = false; return; }
        const speed = this.isPet ? 2 : this.player.stats.orbitalShield.speed; this.angle += speed * dt * 0.001;
        const allOrbitals = orbitalShields.filter(o => o.active && o.isPet === this.isPet);
        const myIndex = allOrbitals.indexOf(this); const total = allOrbitals.length > 0 ? allOrbitals.length : 1;
        const angleOffset = (2 * Math.PI / total) * myIndex;
        this.x = this.player.x + this.player.width/2 + Math.cos(this.angle + angleOffset) * this.orbitRadius;
        this.y = this.player.y + this.player.height/2 + Math.sin(this.angle + angleOffset) * this.orbitRadius;
        if (this.isPet) {
            this.shootTimer -= dt;
            if (this.shootTimer <= 0 && enemies.length > 0) {
                 let closest = null, min_dist = Infinity;
                 const validTargets = enemies.filter(e => e.active && !e.isAlly);
                 validTargets.forEach(e => {
                     const dist = Math.hypot(this.x - e.x, this.y - e.y); if (dist < min_dist) { min_dist = dist; closest = e; }
                 });
                 if (closest) {
                     const a = Math.atan2(closest.y - this.y, closest.x - this.x);
                     projectiles.push(new Projectile(this.x, this.y, Math.cos(a)*10, Math.sin(a)*10, this.player.stats.laserPet.damage, false, 3, this.color, true, {}));
                     this.shootTimer = this.player.stats.laserPet.attackSpeed;
                 }
            }
        } else {
            projectiles.forEach(p => {
                if (p.active && !p.isPlayer && Math.hypot(this.x - p.x, this.y - p.y) < this.radius + p.width) {
                    p.active = false; if (VISUAL_SETTINGS.particleIntensity > 0) particles.push(...createParticleBurst(this.x, this.y, 10, this.color));
                }
            });
        }
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = VISUAL_SETTINGS.shadows ? 15 : 0;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class MirageClone extends Entity {
    constructor(x, y, w, h, duration) {
        super(x, y, w, h, 'rgba(0, 150, 255, 0.5)');
        this.duration = duration;
        this.timer = duration;
    }
    update(dt) {
        this.timer -= dt;
        if (this.timer <= 0) {
            this.active = false;
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = (this.timer / this.duration) * 0.5 * (VISUAL_SETTINGS.cardEffectIntensity / 10);
        renderCharacter(ctx, this.x, this.y, this.width, this.height, 1, false);
        ctx.restore();
    }
}

class GravityWell {
    constructor(x, y, radius, duration) { this.x = x; this.y = y; this.radius = radius; this.duration = duration; this.timer = this.duration; this.active = true; } 
    update(dt) {
        this.timer -= dt; if (this.timer <= 0) { this.active = false; return; }
        enemies.forEach(e => {
            if (e.active && !e.isAlly) {
                const dx = this.x - (e.x + e.width/2); const dy = this.y - (e.y + e.height/2); const dist = Math.hypot(dx, dy);
                if (dist < this.radius) { const force = 0.2 * (1 - dist/this.radius); e.x += (dx/dist) * force; e.y += (dy/dist) * force; }
            }
        });
    }
    draw(ctx) {
        ctx.save(); ctx.globalAlpha = (this.timer / this.duration) * 0.5 * (VISUAL_SETTINGS.cardEffectIntensity / 10); ctx.fillStyle = '#9c27b0';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 - (this.timer / this.duration)), 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
}

class DamageZone {
    constructor(x, y, width, height, duration, damage, isCircle = false, color = 'rgba(255, 0, 0, 0.4)') {
        this.x = x; this.y = y; this.width = width; this.height = height; this.duration = duration;
        this.damage = damage; this.isCircle = isCircle; this.color = color; this.active = true;
        this.hitCooldown = 500; this.hitTimer = 0;
    }
    update(dt) {
        this.duration -= dt; if(this.duration <= 0) this.active = false;
        this.hitTimer -= dt;
        if(this.hitTimer <= 0) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            if (player) {
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                let collided = false;
                if (this.isCircle) {
                    const dist = Math.hypot(centerX - playerCenterX, centerY - playerCenterY);
                    if (dist < this.width / 2 + player.width / 2) collided = true;
                } else {
                    if (player.x < this.x + this.width && player.x + player.width > this.x &&
                        player.y < this.y + this.height && player.y + player.height > this.y) {
                        collided = true;
                    }
                }
                if (collided) {
                    player.takeDamage(this.damage);
                    this.hitTimer = this.hitCooldown;
                }
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = (this.duration / 500) * 0.7; // Fade out effect
        ctx.fillStyle = this.color;
        if(this.isCircle) {
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        ctx.restore();
    }
}

// Funções para criação de partículas e efeitos
function createParticleBurst(x,y,c,co, alpha = 1){ 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; let b=[]; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const count = Math.floor(c * intensityFactor);
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2, s=Math.random()*5+2, vx=Math.cos(a)*s, vy=Math.sin(a)*s, si=Math.random()*3+1, l=Math.random()*800+400; const p = new Particle(x,y,vx,vy,si,co,l); p.alpha = alpha; b.push(p); } return b; 
}
function createMuzzleFlash(x, y, angle, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { const a = angle + (Math.random() - 0.5) * 0.3, s = Math.random() * 5 + 3, z = Math.random() * 2 + 1; p.push(new Particle(x, y, Math.cos(a) * s, Math.sin(a) * s, z, CONFIG.COLOR_PLAYER_PROJECTILE, 300)); } return p; 
}
function createTrailParticles(x, y, count, color) { 
    if (VISUAL_SETTINGS.trailIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.trailIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { p.push(new Particle(x + (Math.random() - 0.5) * 20, y, (Math.random()-0.5)*1, Math.random()*2, Math.random() * 2 + 1, color, 1000)); } return p; 
}
function createJumpDust(x, y, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { p.push(new Particle(x + (Math.random() - 0.5) * 30, y, (Math.random()-0.5)*3, -Math.random()*2, Math.random() * 3 + 2, '#8a8ac0', 800)); } return p; 
}
function createDeathExplosion(x, y, count) { 
    if (VISUAL_SETTINGS.particleIntensity <= 0) return []; const p = []; const intensityFactor = VISUAL_SETTINGS.particleIntensity / 7; const numParticles = Math.floor(count * intensityFactor);
    for (let i = 0; i < numParticles; i++) { const a = Math.random() * Math.PI * 2, s = Math.random() * 5 + 2; p.push(new Particle(x, y, Math.cos(a) * s, Math.sin(a) * s, Math.random() * 4 + 2, '#ff5555', 1500)); } return p; 
}
function createBloodSplatter(x, y, amount) { 
    if (!VISUAL_SETTINGS.blood) return; const s = document.createElement('div'); 
    s.className = 'blood-splatter'; const z = Math.min(200, 20 + amount * 3); s.style.width = `${z}px`; s.style.height = `${z}px`; s.style.left = `${x}px`; s.style.top = `${y}px`; 
    document.body.appendChild(s); bloodSplatters.push({element: s, time: 2000}); 
}
function createDamageIndicator(x, y, amount) {
    const indicator = document.createElement('div'); indicator.className = 'damage-indicator'; indicator.textContent = `-${Math.round(amount)}`; indicator.style.left = `${x}px`; indicator.style.top = `${y}px`;
    document.body.appendChild(indicator); setTimeout(() => { indicator.remove(); }, 1000);
}
function createLightningStrike(x, y, damage) {
    if (VISUAL_SETTINGS.cardEffectIntensity <= 0) return; const lightning = document.createElement('div');
    lightning.className = 'lightning'; lightning.style.left = `${x}px`; lightning.style.top = '0'; lightning.style.height = `${y}px`;
    document.body.appendChild(lightning);
    enemies.forEach(e => { if (e.active && Math.abs(e.x + e.width/2 - x) < 30 && e.y < y) e.takeDamage(damage, false); });
    setTimeout(() => { lightning.remove(); }, 300);
}
function createHolyBeam(x, damage) {
    if (VISUAL_SETTINGS.cardEffectIntensity <= 0) return;
    const beamY = getGroundHeightAt(x);
    const beam = document.createElement('div');
    beam.className = 'lightning'; // Re-use lightning CSS, change color
    beam.style.background = 'linear-gradient(to bottom, rgba(255,255,255,0.9) 0%, rgba(255,255,224,0.9) 100%)';
    beam.style.left = `${x}px`; beam.style.top = '0'; beam.style.height = `${beamY}px`;
    document.body.appendChild(beam);
    enemies.forEach(e => { if (e.active && Math.abs(e.x + e.width/2 - x) < 30) e.takeDamage(damage, false); });
    setTimeout(() => { beam.remove(); }, 300);
}
function createShockwaveEffect(x, y, radius) {
    if (VISUAL_SETTINGS.particleIntensity <= 0) return [];
    const p = [];
    for(let i=0; i < radius / 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        p.push(new Particle(x, y, Math.cos(angle) * i * 0.1, 0, 3, 'rgba(255, 255, 255, 0.5)', 300));
    }
    return p;
}
function createTetherEffect(x1, y1, x2, y2, color) {
    // This effect is best drawn directly on canvas for one frame
    floatingTexts.push({
        draw: (ctx) => {
            ctx.save(); ctx.globalAlpha = 0.5; ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.restore();
        },
        update: function(dt) { this.lifespan -= dt; if (this.lifespan <= 0) this.active = false; },
        lifespan: 100, active: true
    });
}

// ===================================================================================
// 5. FUNÇÕES DE LÓGICA DO JOGO (INCLUINDO CONQUISTAS E RECORDES)
// ===================================================================================

function startGame(restart = false) {
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
    gameManager.running = false;
    stopMainMenuAnimations();
    
    if (!restart) {
        if (gameManager.isCharacterRandom) {
            const characters = ['warrior', 'archer', 'mage'];
            gameManager.stats.character = characters[Math.floor(Math.random() * characters.length)];
        }
        if (gameManager.isDifficultyRandom) {
            const difficulties = ['easy', 'normal', 'hard'];
            gameManager.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
        }
        if (gameManager.isGameModeRandom) {
            const modes = ['waves', 'infinite'];
            gameManager.gameMode = modes[Math.floor(Math.random() * modes.length)];
        }
    }

    document.querySelectorAll('.ui-modal').forEach(modal => modal.style.display = 'none');
    canvas.style.display = 'block'; 
    pauseButton.style.display = 'block'; 
    if(VISUAL_SETTINGS.cheatFeaturesEnabled) cheatMenuButton.style.display = 'block';
    settingsButton.style.display = 'none';
    ingameCardsUI.style.display = 'block';
    ingameInfoDisplay.style.display = 'block';
    gameTimerDisplay.style.display = 'block';
    
    controlsHint.textContent = gameManager.controlScheme === 'desktop' ? 'Controles: A/D ou Setas para mover, Espaço para pular, Mouse para atirar' : 'Controles: Use os joysticks para mover e atirar';
    
    Object.assign(gameManager, { 
        running: true, 
        paused: false, gameOver: false, victory: false,
        killsThisRun: 0, bossKillsThisRun: 0,
        gameTime: 0, wave: 0, waveState: 'COOLDOWN', waveTimer: CONFIG.WAVE_SPAWN_COOLDOWN, 
        noDamageWaves: 0, totalExpThisRun: 0, jumpsThisRun: 0, xpOrbsCollected: 0, coinsInRun: 0,
        frozenEnemiesThisRun: 0, healingDoneThisRun: 0, blackHoleKillsThisRun: 0, ricochetsThisRun: 0,
        rageKillsThisRun: 0, simultaneousKills: 0, barrierBlocks: 0, stationaryWaveCount: 0
    });
    gameManager.stats.killCounts = {}; gameManager.stats.criticalHitsThisRun = 0; gameManager.stats.rerollsThisRun = 0; gameManager.stats.deathsThisRun = 0;
    
    groundPath = generateSmoothGround(); platforms = generatePlatforms();
    enemies = []; projectiles = []; particles = []; expOrbs = []; floatingTexts = [];
    blackHoles = []; orbitalShields = []; coins = []; mirageClones = []; gravityWells = []; damageZones = [];
    player = new Player(canvas.width / 2, 500);
    updateIngameCardsUI();
    updateIngameInfoDisplay();

    lastTime = performance.now(); lastDamageWave = -1;
    
    if (gameManager.controlScheme === 'mobile') {
        movementJoystick = new JoystickController(150, CONFIG.HEIGHT - 150, 80, 40, '255, 255, 255');
        shootingJoystick = new JoystickController(CONFIG.WIDTH - 150, CONFIG.HEIGHT - 150, 80, 40, '255, 152, 0');
    }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}

function generatePlatforms() {
    const p = [];
    for (let i = 0; i < CONFIG.PLATFORM_COUNT; i++) {
        const width = CONFIG.PLATFORM_WIDTH_MIN + Math.random() * (CONFIG.PLATFORM_WIDTH_MAX - CONFIG.PLATFORM_WIDTH_MIN);
        let x, y, validPosition = false, attempts = 0;
        while (!validPosition && attempts < 20) {
            x = Math.random() * (canvas.width - width); y = CONFIG.PLATFORM_MIN_Y + Math.random() * (CONFIG.PLATFORM_MAX_Y - CONFIG.PLATFORM_MIN_Y);
            validPosition = true;
            for (const existing of p) {
                const xDist = Math.abs((x + width / 2) - (existing.x + existing.width / 2));
                if (xDist < (width + existing.width) / 2 + 50) { validPosition = false; break; }
            }
            attempts++;
        }
        if (validPosition) p.push(new Platform(x, y, width));
    }
    return p;
}
function generateSmoothGround() {
    const path = []; const segCount = Math.ceil(CONFIG.WIDTH / CONFIG.GROUND_SEGMENT_WIDTH); let prevY = CONFIG.GROUND_BASE_HEIGHT;
    for (let i = 0; i <= segCount; i++) {
        const x = i * CONFIG.GROUND_SEGMENT_WIDTH;
        const wave1 = Math.sin(i * CONFIG.GROUND_ROUGHNESS * 2) * CONFIG.GROUND_AMPLITUDE; 
        const wave2 = Math.cos(i * CONFIG.GROUND_ROUGHNESS * 1.4) * CONFIG.GROUND_AMPLITUDE * 0.6; 
        const y = CONFIG.GROUND_BASE_HEIGHT - (wave1 + wave2);
        const smoothedY = i === 0 ? y : prevY * 0.7 + y * 0.3; path.push({ x, y: smoothedY }); prevY = smoothedY;
    } return path;
}
function getGroundHeightAt(x) {
    if (!groundPath || groundPath.length < 2) return CONFIG.HEIGHT; 
    for (let i = 0; i < groundPath.length - 1; i++) {
        if (x >= groundPath[i].x && x <= groundPath[i+1].x) { const p1 = groundPath[i], p2 = groundPath[i+1]; return p1.y + (p2.y - p1.y) * ((x - p1.x) / (p2.x - p1.x)); }
    }
    if (x < groundPath[0].x) return groundPath[0].y;
    return groundPath[groundPath.length - 1].y;
}
function createStars() {
    const starsContainer = document.getElementById('stars'); starsContainer.innerHTML = ''; 
    for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
        const star = document.createElement('div'); star.className = 'star';
        const size = Math.random() * 2 + 1, left = Math.random() * 100, top = Math.random() * 100, duration = Math.random() * 5 + 3;
        star.style.width = `${size}px`; star.style.height = `${size}px`; star.style.left = `${left}%`; star.style.top = `${top}%`;
        star.style.setProperty('--duration', `${duration}s`); starsContainer.appendChild(star);
    }
}
function lerpColor(c1, c2, factor) {
    const r1 = parseInt(c1.substr(1, 2), 16); const g1 = parseInt(c1.substr(3, 2), 16); const b1 = parseInt(c1.substr(5, 2), 16);
    const r2 = parseInt(c2.substr(1, 2), 16); const g2 = parseInt(c2.substr(3, 2), 16); const b2 = parseInt(c2.substr(5, 2), 16);
    const r = Math.round(r1 + factor * (r2 - r1)); const g = Math.round(g1 + factor * (g2 - g1)); const b = Math.round(b1 + factor * (b2 - b1));
    return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
}
function updateThemeTransition(deltaTime) {
    if (!themeTransition.active) return;
    themeTransition.progress += deltaTime;
    const factor = Math.min(themeTransition.progress / themeTransition.duration, 1);
    
    frameColors.bg[0] = lerpColor(themeTransition.from.bg[0], themeTransition.to.bg[0], factor);
    frameColors.bg[1] = lerpColor(themeTransition.from.bg[1], themeTransition.to.bg[1], factor);
    frameColors.ground = lerpColor(themeTransition.from.ground, themeTransition.to.ground, factor);
    frameColors.ground_top = lerpColor(themeTransition.from.ground_top, themeTransition.to.ground_top, factor);
    frameColors.platform = lerpColor(themeTransition.from.platform, themeTransition.to.platform, factor);

    if (factor >= 1) themeTransition.active = false;
}
function waveManager(deltaTime) { 
    if (gameManager.paused || gameManager.gameOver || gameManager.victory) return;
    if (gameManager.waveState === 'COOLDOWN') { 
        waveIndicator.textContent = `Próxima onda em: ${(gameManager.waveTimer/1000).toFixed(1)}s`;
        gameManager.waveTimer -= deltaTime; 
        if (gameManager.waveTimer <= 0) { 
            gameManager.wave++; 
            if (gameManager.wave >= 101 && gameManager.gameMode === 'waves') {
                gameManager.victory = true;
                return;
            }
            
            const themeKeys = Object.keys(THEMES);
            const themeIndex = Math.floor((gameManager.wave - 1) / 5) % themeKeys.length;
            const newTheme = THEMES[themeKeys[themeIndex]];
            if (newTheme.name !== currentTheme.name) {
                themeTransition = { active: true, progress: 0, duration: 2000, from: { ...currentTheme }, to: { ...newTheme } };
                currentTheme = newTheme;
            }
            
            if (currentTheme.name !== gameManager.runFlags.currentThemeName) {
                gameManager.runFlags.currentThemeName = currentTheme.name;
                gameManager.runFlags.wavesInCurrentTheme = 1;
            } else {
                gameManager.runFlags.wavesInCurrentTheme++;
            }
            checkAchievement('survival_in_theme', { theme: gameManager.runFlags.currentThemeName, waves: gameManager.runFlags.wavesInCurrentTheme });

            Object.assign(gameManager.runFlags, { playerMovedHorizontally: false, tookDamageThisWave: false, hpAtWaveStart: player.hp });
            gameManager.shotsFiredThisWave = 0;
            if (gameManager.wave % 5 === 0) { bossWarning.style.display = 'block'; setTimeout(() => { bossWarning.style.display = 'none'; }, 3000); gameManager.runFlags.bossSpawnTime = Date.now(); }
            
            checkAchievement('wave', gameManager.wave);
            checkAchievement('wave_in_mode', { wave: gameManager.wave, mode: gameManager.gameMode });
            checkAchievement('wave_in_difficulty', { wave: gameManager.wave, difficulty: gameManager.difficulty });
            
            if (gameManager.wave > 1 && gameManager.wave - 1 > lastDamageWave) { 
                gameManager.noDamageWaves++; 
                if(gameManager.noDamageWaves > 0) checkAchievement('no_damage_waves', gameManager.noDamageWaves); 
            } else { 
                gameManager.noDamageWaves = 0; 
            }
            if(!gameManager.runFlags.playerMovedHorizontally && gameManager.wave > 10) {
                gameManager.stationaryWaveCount++;
                checkAchievement('stationary_waves', gameManager.stationaryWaveCount);
            } else {
                gameManager.stationaryWaveCount = 0;
            }
            
            gameManager.waveState = 'SPAWNING'; 
            let spawnMultiplier = 1.0;
            if(gameManager.difficulty === 'hard') spawnMultiplier = 1.2;
            else if(gameManager.difficulty === 'easy') spawnMultiplier = 0.6;

            const totalEnemies = Math.floor((5 + gameManager.wave * CONFIG.WAVE_ENEMY_MULTIPLIER) * spawnMultiplier);
            const groundEnemyTypes = ['grunt', 'tank', 'shooter', 'bomber', 'bouncer', 'exploder', 'healer', 'teleporter', 'splitter'];
            const flyingEnemyTypes = ['flyer', 'elite'];

            for (let i = 0; i < totalEnemies; i++) {
                const isFlying = Math.random() < 0.2;
                const type = isFlying ? flyingEnemyTypes[Math.floor(Math.random() * flyingEnemyTypes.length)] : groundEnemyTypes[Math.floor(Math.random() * groundEnemyTypes.length)];
                const newEnemy = new Enemy(Math.random() * CONFIG.WIDTH, -50 - Math.random() * 100, type);
                newEnemy.lastDamageTime = gameManager.gameTime; // Inicia com o tempo atual
                enemies.push(newEnemy);
            }

            if (gameManager.wave % 5 === 0) {
                const boss = new Enemy(CONFIG.WIDTH/2, -100, currentTheme.boss_type);
                boss.lastDamageTime = gameManager.gameTime;
                enemies.push(boss);
            }
            
            floatingTexts.push(new FloatingText(`ONDA ${gameManager.wave} INICIADA!`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2, '#ff5555', 40));
        } 
    } else if (gameManager.waveState === 'SPAWNING') {
        const remainingEnemies = enemies.filter(e => e.active && !e.isAlly);
        waveIndicator.textContent = `Onda: ${gameManager.wave} | Inimigos: ${remainingEnemies.length}`;
        
        // MODIFICADO [v7.9]: Novo sistema "Resgate e Liberação"
        if (remainingEnemies.length > 0 && remainingEnemies.length <= 2) {
            const timeSinceLastDamage = gameManager.gameTime - Math.max(...remainingEnemies.map(e => e.lastDamageTime || 0), 0);
            
            const PULL_TRIGGER_TIME = (remainingEnemies.length === 1) ? 5000 : 10000;
            
            if (timeSinceLastDamage > PULL_TRIGGER_TIME) {
                remainingEnemies.forEach(e => {
                    if (!e.isBeingRescued) {
                        e.isBeingRescued = true; // Inicia o processo de puxar
                    }
                });
            }
        }

        if (remainingEnemies.length === 0) {
            gameManager.waveState = 'COOLDOWN'; gameManager.waveTimer = CONFIG.WAVE_SPAWN_COOLDOWN; 
            if (player.hp / player.stats.maxHp < 0.1) checkAchievement('clutch_wave', 1);
            if (player.hp === 1) checkAchievement('one_hp_clutch', 1);
            if (gameManager.wave > 10 && gameManager.shotsFiredThisWave === 0) checkAchievement('no_shot_wave', 1);
            if (!gameManager.runFlags.playerMovedHorizontally && gameManager.wave % 5 === 0) checkAchievement('no_move_boss_wave', 1);
            if (!gameManager.runFlags.tookDamageThisWave && gameManager.wave % 5 === 0) checkAchievement('no_damage_boss_wave', 1);
            if (gameManager.runFlags.hpAtWaveStart < player.stats.maxHp * 0.1 && player.hp > player.stats.maxHp * 0.9) checkAchievement('comeback_wave', 1);

            floatingTexts.push(new FloatingText(`ONDA ${gameManager.wave} COMPLETA!`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2, '#4caf50', 40));
            const waveBonusCoins = gameManager.wave * CONFIG.WAVE_BONUS_COIN_MULTIPLIER;
            if (player) player.addCoin(waveBonusCoins);
            floatingTexts.push(new FloatingText(`+${waveBonusCoins} Moedas (Bônus de Onda)`, canvas.width/2, canvas.height/2 + 40, '#ffd700', 20));
        }
    } 
}
function handleCollisions() { 
    projectiles.forEach(p => { 
        if (p.isPlayer && p.active) { 
            let simultaneousKillsThisFrame = 0;
            enemies.forEach(e => { 
                if (e.active && !e.isAlly && (p.x > e.x && p.x < e.x + e.width && p.y > e.y && p.y < e.y + e.height)) { 
                    const hpBefore = e.hp;
                    
                    if (p.isCrit && p.pStats.blackHole?.enabled && Math.random() < p.pStats.blackHole.chance) {
                        blackHoles.push(new BlackHole(e.x + e.width/2, e.y + e.height/2, p.pStats.blackHole));
                    }

                    e.takeDamage(p.damage, p.isPlayer);
                    
                    if (!e.active && hpBefore > 0) { simultaneousKillsThisFrame++; }
                    
                    if (p.pStats.chainLightning?.enabled && Math.random() < p.pStats.chainLightning.chance) {
                        let currentTarget = e;
                        let bounceCount = p.pStats.chainLightning.bounces;
                        let chainedEnemies = new Set([e]);
                        for(let i = 0; i < bounceCount; i++) {
                            let nextTarget = null, min_dist = 150;
                            enemies.forEach(nextE => {
                                if(nextE.active && !nextE.isAlly && !chainedEnemies.has(nextE)) {
                                    const dist = Math.hypot(currentTarget.x - nextE.x, currentTarget.y - nextE.y);
                                    if(dist < min_dist) { min_dist = dist; nextTarget = nextE; }
                                }
                            });
                            if(nextTarget) {
                                if (VISUAL_SETTINGS.cardEffectIntensity > 0) createTetherEffect(currentTarget.x, currentTarget.y, nextTarget.x, nextTarget.y, '#2196f3');
                                nextTarget.takeDamage(p.damage * p.pStats.chainLightning.damageMultiplier, true);
                                chainedEnemies.add(nextTarget);
                                currentTarget = nextTarget;
                            } else { break; }
                        }
                    }

                    if (p.pStats.gravityWell?.enabled && Math.random() < p.pStats.gravityWell.chance) {
                        gravityWells.push(new GravityWell(e.x + e.width/2, e.y + e.height/2, p.pStats.gravityWell.radius, p.pStats.gravityWell.duration));
                    }
                    p.hitCount++; if (p.hitCount >= p.maxHitCount) p.active = false; 
                }
            });
            if(simultaneousKillsThisFrame > gameManager.simultaneousKills) gameManager.simultaneousKills = simultaneousKillsThisFrame;
            checkAchievement('simultaneous_kills', gameManager.simultaneousKills);
        } 
        if (!p.isPlayer && p.active && player && (p.x > player.x && p.x < player.x + player.width && p.y > player.y && p.y < player.y + player.height)) { 
            p.active = false; player.takeDamage(10); 
        } 
    }); 
    for (let i = coins.length - 1; i >= 0; i--) { if (!coins[i].active) { coins.splice(i,1); } }
}
function showUpgradeScreen() {
    const choicesContainer = document.getElementById('upgrade-choices'); choicesContainer.innerHTML = '';
    const availableUpgrades = Object.keys(UPGRADES).filter(key => { const upgrade = UPGRADES[key]; const currentStacks = player.upgrades[key] || 0; return !upgrade.maxStacks || currentStacks < upgrade.maxStacks; });
    
    const weightedPool = [];
    availableUpgrades.forEach(key => {
        const rarity = UPGRADES[key].rarity;
        let weight = 1;
        if (rarity === 'common') weight = 10;
        if (rarity === 'uncommon') weight = 7;
        if (rarity === 'rare') weight = 4;
        if (rarity === 'epic') weight = 2;
        if (rarity === 'legendary') weight = 1;
        for(let i=0; i < weight; i++) weightedPool.push(key);
    });

    const choices = player.stats.upgradeChoices; const selectedKeys = new Set();
    while (selectedKeys.size < choices && weightedPool.length > 0) { 
        const randomIndex = Math.floor(Math.random() * weightedPool.length); 
        selectedKeys.add(weightedPool[randomIndex]);
    }

    selectedKeys.forEach(key => {
        const upgrade = UPGRADES[key]; const card = document.createElement('div'); card.className = `upgrade-card card-rarity-${upgrade.rarity}`;
        card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
        card.addEventListener('click', () => {
            player.addUpgrade(key); upgradeModal.style.opacity = '0';
            setTimeout(() => { upgradeModal.style.display = 'none'; gameManager.paused = false; }, 300);
        });
        choicesContainer.appendChild(card);
    });
    rollUpgradesButton.disabled = gameManager.stats.coins < 50;
    upgradeModal.style.display = 'flex'; setTimeout(() => upgradeModal.style.opacity = '1', 10);
}
function saveCurrentRunAsRecord() {
    if (gameManager.gameTime <= 5000) return;
    const m = Math.floor(gameManager.gameTime/60000), s = Math.floor((gameManager.gameTime % 60000) / 1000); 
    const timeStr = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    const newRecord = { 
        date: new Date().toLocaleDateString('pt-BR'), 
        time: timeStr, 
        wave: gameManager.wave, 
        kills: gameManager.killsThisRun, 
        xp: gameManager.totalExpThisRun,
        character: gameManager.stats.character,
        isCharacterRandom: gameManager.isCharacterRandom,
        difficulty: gameManager.difficulty,
        isDifficultyRandom: gameManager.isDifficultyRandom,
        mode: gameManager.gameMode,
        isGameModeRandom: gameManager.isGameModeRandom,
        device: gameManager.chosenDevice
    };
    PLAYER_RECORDS.unshift(newRecord); if(PLAYER_RECORDS.length > 50) PLAYER_RECORDS.pop(); 
    saveGameData();
    populateBestRecordDisplay();
}
function showGameOverScreen() { 
    saveCurrentRunAsRecord();
    const m = Math.floor(gameManager.gameTime/60000), s = Math.floor(gameManager.gameTime%60000/1000); 
    const timeStr = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    document.getElementById('final-stats').innerHTML = `Nickname: ${PLAYER_CUSTOMIZATION.nickname} | Tempo: ${timeStr}`;
    
    const difficultyText = gameManager.difficulty.charAt(0).toUpperCase() + gameManager.difficulty.slice(1);
    const modeText = gameManager.gameMode === 'waves' ? '100 Ondas' : 'Infinito';
    document.getElementById('game-over-details').textContent = `Modo: ${modeText} | Dificuldade: ${difficultyText}`;

    document.getElementById('final-wave').textContent = gameManager.wave;
    document.getElementById('final-kills').textContent = gameManager.killsThisRun;
    document.getElementById('final-xp').textContent = gameManager.totalExpThisRun;
    document.getElementById('final-coins').textContent = gameManager.coinsInRun; 
    gameOverScreen.style.display='flex'; setTimeout(() => gameOverScreen.style.opacity='1', 10);
}
function showVictoryScreen() { 
    gameManager.stats.coins += 250;
    gameManager.stats.totalWins++;
    checkAchievement('wave', 101);
    checkAchievement('win_condition', { difficulty: gameManager.difficulty });
    checkAchievement('win_with_card', { cardName: 'GlassCannon' });
    checkAchievement('win_no_deaths', { difficulty: gameManager.difficulty });
    checkAchievement('win_condition_no_rarity', { rarity: 'common'});
    checkAchievement('total_wins', gameManager.stats.totalWins);
    saveCurrentRunAsRecord();
    victoryModal.style.display='flex'; setTimeout(() => victoryModal.style.opacity='1', 10);
}

function checkAchievement(type, data, suppressNotification = false) {
    let unlockedAny = false;
    gameManager.achievements.forEach(ach => {
        if (ach.unlocked) return;
        if (ach.type !== type) return; 

        let conditionMet = false;
        switch(type) {
            case 'kills': case 'wave': case 'level': case 'boss_kills': case 'no_damage_waves': 
            case 'survival_time': case 'xp_orbs': case 'unique_cards': case 'frozen_enemies':
            case 'healing': case 'black_hole_kills': case 'coins_in_run': case 'ricochets':
            case 'rage_kills': case 'single_hit_damage': case 'simultaneous_kills': case 'barrier_blocks':
            case 'rerolls_in_run': case 'total_wins': case 'exploder_kills': case 'stationary_waves':
                if (data >= ach.target) conditionMet = true; 
                break;
            case 'attack_speed_milestone':
                if (data <= ach.target) conditionMet = true;
                break;
            case 'kill_type':
                if(data.subtype === ach.subtype) { 
                    if (data.count >= ach.target) conditionMet = true; 
                } 
                break;
            case 'clutch_wave': case 'death_on_boss_wave': case 'pet_and_shield':
            case 'no_shot_wave': case 'no_move_boss_wave': case 'no_damage_boss_wave':
            case 'barrier_boss_hit': case 'one_hp_clutch': case 'comeback_wave': case 'first_purchase':
                conditionMet = true; 
                break;
            case 'collect_rarity': 
                if(data.rarity === ach.subtype) conditionMet = true; 
                break;
            case 'stat_check': 
                if(data.subtype === ach.subtype && data.value >= ach.target) conditionMet = true; 
                break;
            case 'win_condition':
                if (gameManager.difficulty === ach.subtype) conditionMet = true; break;
            case 'wave_in_mode':
                if (gameManager.gameMode === ach.subtype && data.wave >= ach.target) conditionMet = true; break;
            case 'wave_in_difficulty':
                if (gameManager.difficulty === ach.subtype && data.wave >= ach.target) conditionMet = true; break;
            case 'win_with_card':
                if (player.upgrades[ach.subtype]) conditionMet = true; break;
            case 'win_no_deaths':
                 if (gameManager.difficulty === ach.subtype && gameManager.stats.deathsThisRun === 0) conditionMet = true; break;
            case 'win_condition_no_rarity':
                const hasBannedRarity = Object.keys(player.upgrades).some(cardKey => UPGRADES[cardKey]?.rarity === ach.subtype);
                if (!hasBannedRarity) conditionMet = true; break;
            case 'stat_milestone':
                if (ach.subtype === 'critChance' && data.value >= ach.target) conditionMet = true;
                if (ach.subtype === 'maxHp' && data.value >= ach.target) conditionMet = true;
                break;
            case 'card_combo':
                if (ach.subtypes.every(cardKey => player.upgrades[cardKey])) conditionMet = true; break;
            case 'convert_enemy_type':
                if (ach.subtype === data) conditionMet = true; break;
            case 'fast_boss_kill':
                if (data <= ach.target) conditionMet = true; break;
            case 'first_kill_difficulty':
                if (data.difficulty === ach.subtype && data.kills >= ach.target) conditionMet = true; break;
            case 'multi_kill_in_time':
                if (data >= ach.target) conditionMet = true; break;
            case 'stack_rarity':
                 const hasStackedCard = Object.keys(player.upgrades).some(cardKey => {
                    return UPGRADES[cardKey]?.rarity === ach.subtype && player.upgrades[cardKey] >= ach.target;
                });
                if(hasStackedCard) conditionMet = true; break;
            case 'all_rarities_in_run':
                const foundRarities = new Set(Object.keys(player.upgrades).map(k => UPGRADES[k]?.rarity));
                if (foundRarities.size >= 5) conditionMet = true; break;
            case 'survival_in_theme':
                 if (THEMES[ach.subtype] && data.theme === THEMES[ach.subtype].name && data.waves >= ach.target) conditionMet = true; break;
            case 'death_with_coins':
                if (data >= ach.target) conditionMet = true; break;
        }

        if (conditionMet) { 
            ach.unlocked = true; 
            unlockedAny = true; 
            gameManager.stats.coins += ach.reward;
            if (!suppressNotification) {
                showAchievementNotification(ach); 
            }
            if (ach.customizationReward) {
                const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                rewards.forEach(reward => {
                    const { type, id } = reward;
                    const listKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                    if (PLAYER_CUSTOMIZATION[listKey] && !PLAYER_CUSTOMIZATION[listKey].includes(id)) {
                        PLAYER_CUSTOMIZATION[listKey].push(id);
                    }
                });
            }
            if (!suppressNotification) updateMetaProgression();
        }
    });

    if (unlockedAny) {
        const allUnlocked = gameManager.achievements.filter(a => a.id !== 'ultimate').every(a => a.unlocked);
        const ultimateAchievement = gameManager.achievements.find(a => a.id === 'ultimate');
        if (allUnlocked && !ultimateAchievement.unlocked) { 
            ultimateAchievement.unlocked = true; 
            gameManager.stats.coins += ultimateAchievement.reward; 
            if (!suppressNotification) showAchievementNotification(ultimateAchievement); 
        }
        updateAchievementCounters();
        if (!suppressNotification) saveGameData();
    }
}
function checkMetaAchievements(isMassUnlock = false) {
    let unlockedAny = false;
    gameManager.achievements.forEach(ach => {
        if (ach.unlocked) return; let conditionMet = false;
        switch(ach.type) {
            case 'meta_spend': if(gameManager.stats.totalSpent >= ach.target) {
                conditionMet = true;
                if(ach.customizationReward) {
                    const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                    rewards.forEach(reward => {
                        const { type, id } = reward;
                        const ownedListKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                        if (PLAYER_CUSTOMIZATION[ownedListKey] && !PLAYER_CUSTOMIZATION[ownedListKey].includes(id)) {
                            PLAYER_CUSTOMIZATION[ownedListKey].push(id);
                        }
                    });
                }
            } break;
             case 'collect_all':
                let catalog, ownedList;
                if(ach.subtype === 'hats') { catalog = HATS_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedHats; }
                else if(ach.subtype === 'shapes') { catalog = SHAPES_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedShapes; }
                else if(ach.subtype === 'colors') { catalog = COLORS_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedColors; }
                else if(ach.subtype === 'faces') { catalog = FACES_CATALOG; ownedList = PLAYER_CUSTOMIZATION.ownedFaces; }
                if(catalog && ownedList.length >= catalog.length) conditionMet = true;
                break;
            case 'max_perm_upgrade':
                const isMaxed = Object.values(PLAYER_PERMANENT_UPGRADES).some(level => level >= 10);
                if (isMaxed) conditionMet = true;
                break;
            case 'total_healing':
                if(gameManager.stats.totalHealing >= ach.target) conditionMet = true;
                break;
        }
        if (conditionMet) { 
            ach.unlocked = true; 
            unlockedAny = true; 
            if (!isMassUnlock) {
                gameManager.stats.coins += ach.reward;
                updateMetaProgression();
            }
            showAchievementNotification(ach); 
        }
    });
     if (unlockedAny) {
        updateAchievementCounters();
        if (!isMassUnlock) saveGameData();
     }
}
function showAchievementNotification(achievement) {
    const notification = document.createElement('div');
    notification.className = 'achievement-notification';
    let rewardText = `+${achievement.reward} moedas`;
    if (achievement.customizationReward) {
        rewardText += ` & item!`;
    }
    notification.innerHTML = `<div class="achievement-icon">🏆</div><div class="achievement-text"><h4>${achievement.name}</h4><p>${achievement.description}</p><p><strong>Recompensa: ${rewardText}</strong></p></div><div class="achievement-badge">${achievement.rarity.toUpperCase()}</div>`;
    achievementNotificationContainer.appendChild(notification);
    if (VISUAL_SETTINGS.particleIntensity > 0) { const color = getColorByRarity(achievement.rarity); for (let i = 0; i < 50; i++) setTimeout(() => particles.push(new Particle(canvas.width/2, canvas.height/2, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, Math.random() * 5 + 2, color, 2000)), i * 30); }
    setTimeout(() => { notification.remove(); }, 4000);
}
function getColorByRarity(rarity) {
    switch(rarity) {
        case 'common': return '#ffffff'; case 'uncommon': return '#4caf50'; case 'rare': return '#2196f3';
        case 'epic': return '#9c27b0'; case 'legendary': return '#ff9800'; default: return '#ffffff';
    }
}
function populateAchievements() {
    achievementsList.innerHTML = '';
    const sortedAchievements = [...gameManager.achievements].sort((a,b) => b.unlocked - a.unlocked || a.name.localeCompare(b.name));
    sortedAchievements.forEach(achievement => {
        const card = document.createElement('div');
        card.className = `achievement-card ${achievement.unlocked ? 'unlocked' : ''} achievement-${achievement.rarity}`;
        let rewardHtml = '';
        if(achievement.reward > 0) rewardHtml += `💰 ${achievement.reward} Moedas`;
        if(achievement.customizationReward) {
            const cat = [...SHAPES_CATALOG, ...HATS_CATALOG, ...COLORS_CATALOG, ...FACES_CATALOG];
            const rewards = Array.isArray(achievement.customizationReward) ? achievement.customizationReward : [achievement.customizationReward];
            rewards.forEach(reward => {
                const item = cat.find(i => i.id === reward.id);
                if(item) { rewardHtml += (rewardHtml ? ' <br> ' : '') + `🎨 Item: ${item.name}`; }
            });
        }

        const statusText = achievement.unlocked 
            ? `<p class="conquista-text" style="color: #ffcc00;">CONQUISTADA!</p>` 
            : '<p class="conquista-text" style="color: #f44336;">Não desbloqueada</p>';

        card.innerHTML = `<h3>${achievement.name}</h3>
                          <p>${achievement.description}</p>
                          <p><strong>Dificuldade: ${achievement.rarity.toUpperCase()}</strong></p>
                          ${statusText}
                          <div class="reward-info"><strong>Recompensa:</strong><br>${rewardHtml || 'Nenhuma'}</div>`;
        achievementsList.appendChild(card);
    });
}
function updateMetaProgression() {
    document.getElementById('main-menu-coins-value').textContent = gameManager.stats.coins;
    customizationCoinsDisplay.textContent = `Moedas: ${gameManager.stats.coins}`;
    permanentUpgradesCoinsDisplay.textContent = `Moedas: ${gameManager.stats.coins}`;
    updateAchievementCounters();
    populateBestRecordDisplay();
}
function updateAchievementCounters() {
    const unlockedCount = gameManager.achievements.filter(a => a.unlocked).length;
    const totalCount = gameManager.achievements.length;
    const counterText = `${unlockedCount}/${totalCount}`;
    document.getElementById('main-menu-achievement-counter').textContent = counterText;
    document.getElementById('pause-menu-achievement-counter').textContent = counterText;
}

// ===================================================================================
// 6. LOOP PRINCIPAL DO JOGO E PREVIEW DO MENU
// ===================================================================================
function update(deltaTime) {
    if (gameManager.gameOver || gameManager.victory || !player) return;

    if (!gameManager.paused) {
        if (gameManager.runFlags.multiKillTimer > 0) {
            gameManager.runFlags.multiKillTimer -= deltaTime;
            if (gameManager.runFlags.multiKillTimer <= 0) {
                gameManager.runFlags.multiKillCounter = 0;
            }
        }

        if (gameManager.timeWarp.active) {
            gameManager.timeWarp.timer -= deltaTime;
            if(gameManager.timeWarp.timer <= 0) gameManager.timeWarp.active = false;
        }
        const effectiveDeltaTime = gameManager.timeWarp.active ? deltaTime * 0.5 : deltaTime;

        gameManager.gameTime += deltaTime; checkAchievement('survival_time', gameManager.gameTime);
        for (let i = bloodSplatters.length - 1; i >= 0; i--) { bloodSplatters[i].time -= deltaTime; if (bloodSplatters[i].time <= 0) { bloodSplatters[i].element.remove(); bloodSplatters.splice(i, 1); } }
        
        [enemies, projectiles, particles, expOrbs, floatingTexts, blackHoles, orbitalShields, coins, mirageClones, gravityWells, damageZones].forEach(arr => arr.forEach(e => { if (e.update) e.update(effectiveDeltaTime, player); }));
        
        handleCollisions(); waveManager(effectiveDeltaTime);
        updateThemeTransition(deltaTime);

        enemies = enemies.filter(e => e.active); projectiles = projectiles.filter(p => p.active);
        particles = particles.filter(p => p.active); expOrbs = expOrbs.filter(p => p.active);
        floatingTexts = floatingTexts.filter(t => t.active); blackHoles = blackHoles.filter(b => b.active);
        orbitalShields = orbitalShields.filter(s => s.active); coins = coins.filter(c => c.active); 
        mirageClones = mirageClones.filter(c => c.active); gravityWells = gravityWells.filter(w => w.active);
        damageZones = damageZones.filter(d => d.active);
        
        if (screenShake.duration > 0) screenShake.duration -= deltaTime;
    }

    player.update(deltaTime);
}
function draw() {
    ctx.save();
    if (screenShake.duration > 0) { const shakeIntensity = screenShake.magnitude * (screenShake.duration / 200); ctx.translate((Math.random()-0.5) * shakeIntensity, (Math.random()-0.5) * shakeIntensity); }
    
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, frameColors.bg[0]);
    bgGradient.addColorStop(1, frameColors.bg[1]);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGround(); platforms.forEach(p => p.draw(ctx));
    [particles, expOrbs, projectiles, mirageClones, gravityWells, enemies, blackHoles, coins, orbitalShields, damageZones].forEach(arr => arr.forEach(e => e.draw(ctx)));
    if (player) {
        player.draw(ctx);
        drawPlayerNametag(ctx, player);
    }
    drawAimingLine(); 
    floatingTexts.forEach(t => t.draw(ctx)); 

    if (gameManager.timeWarp.active) {
        ctx.fillStyle = "rgba(100, 100, 255, 0.2)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    drawUI();
    if (gameManager.controlScheme === 'mobile' && movementJoystick) { movementJoystick.draw(ctx); shootingJoystick.draw(ctx); }
    ctx.restore();
}
function drawAimingLine() {
    if (!gameManager.running || gameManager.paused || !player) return;
    
    let targetX, targetY;
    if (gameManager.controlScheme === 'desktop') {
        targetX = mouse.x;
        targetY = mouse.y;
    } else if (shootingJoystick && shootingJoystick.active) {
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;
        targetX = playerCenterX + Math.cos(shootingJoystick.angle) * 1000;
        targetY = playerCenterY + Math.sin(shootingJoystick.angle) * 1000;
    } else {
        return;
    }

    ctx.save();
    ctx.beginPath();
    ctx.setLineDash([5, 15]);
    ctx.moveTo(player.x + player.width / 2, player.y + player.height / 2);
    ctx.lineTo(targetX, targetY);
    ctx.strokeStyle = 'rgba(156, 39, 176, 0.4)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}
function drawGround() {
    if (!groundPath) return;
    ctx.fillStyle = frameColors.ground; ctx.strokeStyle = frameColors.ground_top; 
    ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(groundPath[0].x, groundPath[0].y);
    for (let i = 1; i < groundPath.length; i++) ctx.lineTo(groundPath[i].x, groundPath[i].y);
    ctx.stroke(); ctx.lineTo(CONFIG.WIDTH, CONFIG.HEIGHT); ctx.lineTo(0, CONFIG.HEIGHT); ctx.closePath(); ctx.fill();
}
function drawUI() {
    if (!player) return;
    const m = Math.floor(gameManager.gameTime / 60000), s = Math.floor((gameManager.gameTime % 60000) / 1000);
    gameTimerDisplay.textContent = `Tempo: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

    const barWidth = 250, barHeight = 18;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(10, 10, barWidth, barHeight);
    ctx.fillStyle = 'rgba(244, 67, 54, 0.8)'; ctx.fillRect(10, 10, barWidth * (player.hp / player.stats.maxHp), barHeight);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(10, 35, barWidth, barHeight);
    ctx.fillStyle = 'rgba(33, 150, 243, 0.8)'; ctx.fillRect(10, 35, barWidth * (player.exp / player.expToNextLevel), barHeight);
    ctx.fillStyle = '#f0f0f0'; ctx.font = "14px 'Segoe UI'"; ctx.textAlign = 'left';
    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
    ctx.fillText(`HP: ${player.hp.toFixed(0)}/${player.stats.maxHp.toFixed(0)}`, 15, 25);
    ctx.fillText(`LV: ${player.level} (${((player.exp / player.expToNextLevel)*100).toFixed(0)}%)`, 15, 50);
    ctx.fillText(`Moedas (Sessão): ${gameManager.coinsInRun}`, 15, 75); 
    ctx.shadowBlur = 0;
    if (gameManager.cheats.immortality || gameManager.cheats.autoFire || gameManager.cheats.freezeEnemies) {
        ctx.fillStyle = '#ff5555'; ctx.font = "bold 16px 'Segoe UI'"; ctx.textAlign = 'right';
        ctx.fillText('CHEATS ATIVADOS', CONFIG.WIDTH - 20, 50);
    }
}
function drawPlayerNametag(ctx, p) {
    const x = p.x + p.width / 2;
    const y = p.y - 15;
    ctx.font = "bold 14px 'Segoe UI'";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    if (VISUAL_SETTINGS.nametagStyle === 'background') {
        const textWidth = ctx.measureText(PLAYER_CUSTOMIZATION.nickname).width;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(x - textWidth / 2 - 5, y - 18, textWidth + 10, 20);
    }
    
    ctx.fillStyle = '#fff';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 4;
    ctx.fillText(PLAYER_CUSTOMIZATION.nickname, x, y);
    ctx.shadowBlur = 0;
}
function updateIngameCardsUI() {
    if(!player || !gameManager.running) { ingameCardsUI.innerHTML = ''; return; }
    let html = '';
    for(const key in player.upgrades) {
        const upgrade = UPGRADES[key]; const count = player.upgrades[key];
        if (upgrade && count > 0) { html += `<div class="ingame-card-item">${upgrade.name} <span class="count">x${count}</span></div>`; }
    }
    ingameCardsUI.innerHTML = html;
}
function updateIngameInfoDisplay() {
    if (!gameManager.running) { ingameInfoDisplay.style.display = 'none'; return; }
    const charName = gameManager.stats.character.charAt(0).toUpperCase() + gameManager.stats.character.slice(1);
    const diffName = gameManager.difficulty.charAt(0).toUpperCase() + gameManager.difficulty.slice(1);
    const modeName = gameManager.gameMode === 'waves' ? '100 Ondas' : 'Infinito';
    const deviceName = gameManager.chosenDevice === 'desktop' ? 'PC' : 'Mobile';
    
    const charText = `${charName}${gameManager.isCharacterRandom ? ' (🎲)' : ''}`;
    const diffText = `${diffName}${gameManager.isDifficultyRandom ? ' (🎲)' : ''}`;
    const modeText = `${modeName}${gameManager.isGameModeRandom ? ' (🎲)' : ''}`;

    ingameInfoDisplay.innerHTML = 
        `Herói: <span>${charText}</span> | ` +
        `Dificuldade: <span>${diffText}</span> | ` +
        `Modo: <span>${modeText}</span> | ` +
        `Disp: <span>${deviceName}</span>`;
    ingameInfoDisplay.style.display = 'block';
}
function gameLoop(timestamp) {
    if (!gameManager.running) { gameLoopId = null; return; }
    
    const deltaTime = timestamp - lastTime; lastTime = timestamp;
    update(deltaTime > 100 ? 100 : deltaTime); draw();
    if (gameManager.victory) { showVictoryScreen(); return; }
    if (gameManager.gameOver) { showGameOverScreen(); return; }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}

function drawCharacterPreview(timestamp) {
    if (!previewCtx) return;
    const w = characterPreviewCanvas.width;
    const h = characterPreviewCanvas.height;
    
    previewCtx.clearRect(0, 0, w, h);
    renderCharacter(previewCtx, w / 2 - 40, h / 2 - 50, 80, 100, 1, player?.vfx?.isGlass);
}

function animatePreview(timestamp) {
    if (mainMenuModal.style.display !== 'flex') {
        previewAnimationId = null;
        return;
    }
    drawCharacterPreview(timestamp);
    previewAnimationId = requestAnimationFrame(animatePreview);
}

// ===================================================================================
// 7. CHEAT MENU, SONS E EVENT LISTENERS
// ===================================================================================
function applyCheats() {
    gameManager.cheats.immortality = document.getElementById('immortality-cheat').checked;
    gameManager.cheats.autoFire = document.getElementById('auto-fire-cheat').checked;
    gameManager.cheats.freezeEnemies = document.getElementById('freeze-enemies').checked;
    gameManager.cheats.instantExp = document.getElementById('instant-exp').checked;
    gameManager.cheats.infiniteJumps = document.getElementById('infinite-jumps').checked;
    gameManager.cheats.playerSpeed = parseFloat(document.getElementById('player-speed').value) || 7;
    gameManager.cheats.playerDamage = parseFloat(document.getElementById('player-damage').value) || 5;
    gameManager.cheats.enemyDamage = parseFloat(document.getElementById('enemy-damage').value) || 10;
    
    const maxStacksValue = parseInt(document.getElementById('max-stacks').value, 10);
    Object.keys(UPGRADES).forEach(key => { UPGRADES[key].maxStacks = maxStacksValue; });

    if (player) { player.initStats(); }
    
    const targetWave = parseInt(document.getElementById('set-wave').value, 10);
    if (targetWave && targetWave > gameManager.wave) { jumpToWave(targetWave); }

    cheatMenu.style.display = 'none';
}

function resetCheats() {
    document.getElementById('immortality-cheat').checked = false; document.getElementById('auto-fire-cheat').checked = false;
    document.getElementById('player-speed').value = 7; document.getElementById('player-damage').value = 5;
    document.getElementById('freeze-enemies').checked = false; document.getElementById('enemy-damage').value = 10;
    document.getElementById('instant-exp').checked = false; document.getElementById('infinite-jumps').checked = false;
    document.getElementById('set-wave').value = gameManager.wave;
    document.getElementById('max-stacks').value = 50;

    gameManager.cheats = { immortality: false, autoFire: false, playerSpeed: 7, playerDamage: 5, freezeEnemies: false, enemyDamage: 10, instantExp: false, infiniteJumps: false };
    
    Object.keys(UPGRADES).forEach(key => { UPGRADES[key].maxStacks = ORIGINAL_UPGRADES[key].maxStacks; });

    if (player) { player.initStats(); }
    cheatMenu.style.display = 'none';
}

function jumpToWave(wave) {
    if (!gameManager.running || !player) return;
    gameManager.wave = Math.max(0, wave - 1);
    enemies = [];
    projectiles = [];
    gameManager.waveTimer = 100;
    waveIndicator.textContent = `Pulando para a Onda ${wave}...`;
}

function populateCheatCards() {
    cheatCardsList.innerHTML = '';
    Object.keys(UPGRADES).forEach(key => {
        const upgrade = UPGRADES[key]; const card = document.createElement('div');
        card.className = `cheat-card card-rarity-${upgrade.rarity}`; card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
        card.addEventListener('click', () => { if (player) { player.addUpgrade(key); floatingTexts.push(new FloatingText(`${upgrade.name} ATIVADA!`, canvas.width/2, canvas.height/2, 'gold', 30)); } });
        cheatCardsList.appendChild(card);
    });
}
class JoystickController {
    constructor(x, y, baseRadius, handleRadius, color) {
        this.x = x; this.y = y; this.baseRadius = baseRadius; this.handleRadius = handleRadius;
        this.color = color; this.active = false; this.touchId = null;
        this.handleX = this.x; this.handleY = this.y;
        this.angle = 0; this.strength = 0; this.deltaX = 0; this.deltaY = 0;
    }
    handleTouchStart(touch) {
        const rect = canvas.getBoundingClientRect(); const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
        const dx = x - this.x, dy = y - this.y;
        if (Math.sqrt(dx * dx + dy * dy) < this.baseRadius * 1.5) { this.active = true; this.touchId = touch.identifier; this.updateHandle(x, y); }
    }
    handleTouchMove(touch) { if (this.touchId === touch.identifier) { const rect = canvas.getBoundingClientRect(); this.updateHandle(touch.clientX - rect.left, touch.clientY - rect.top); } }
    handleTouchEnd(touch) { if (this.touchId === touch.identifier) { this.active = false; this.touchId = null; this.handleX = this.x; this.handleY = this.y; this.strength = 0; this.deltaX = 0; this.deltaY = 0; } }
    updateHandle(clientX, clientY) {
        const dx = clientX - this.x, dy = clientY - this.y, dist = Math.sqrt(dx * dx + dy * dy);
        this.angle = Math.atan2(dy, dx); this.strength = Math.min(dist / this.baseRadius, 1);
        this.deltaX = Math.cos(this.angle) * this.strength; this.deltaY = Math.sin(this.angle) * this.strength;
        if (dist > this.baseRadius) { this.handleX = this.x + Math.cos(this.angle) * this.baseRadius; this.handleY = this.y + Math.sin(this.angle) * this.baseRadius; } 
        else { this.handleX = clientX; this.handleY = clientY; }
    }
    draw(ctx) {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.baseRadius, 0, Math.PI * 2); ctx.fillStyle = `rgba(${this.color}, 0.2)`; ctx.fill();
        if (this.active) { ctx.beginPath(); ctx.arc(this.x, this.y, this.baseRadius * 1.1, 0, Math.PI * 2); ctx.strokeStyle = `rgba(${this.color}, 0.5)`; ctx.lineWidth = 3;
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(this.handleX, this.handleY, this.handleRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.color}, ${this.active ? 0.8 : 0.5})`;
        ctx.fill();
        ctx.lineWidth = 1;
    }
}

// ===================================================================================
// 8. CONTROLE DE MENUS E EVENTOS PRINCIPAIS
// ===================================================================================
const playButton = document.getElementById('play-button');
const deviceSelectionModal = document.getElementById('device-selection-modal');
const desktopButton = document.getElementById('desktop-button');
const mobileButton = document.getElementById('mobile-button');
const deviceConfirmationModal = document.getElementById('device-confirmation-modal');
const confirmDeviceYes = document.getElementById('confirm-device-yes');
const confirmDeviceNo = document.getElementById('confirm-device-no');
const pauseButton = document.getElementById('pauseButton');
const pauseModal = document.getElementById('pause-modal');
const resumeGameButton = document.getElementById('resume-game-button');
const pauseRestartButton = document.getElementById('pause-restart-button');
const returnToMenuButton = document.getElementById('return-to-menu-button');
const characterSelectionModal = document.getElementById('character-selection-modal');
const characterCards = document.getElementById('character-selection-cards');
const confirmCharacterButton = document.getElementById('confirm-character');

let tempDeviceChoice = null; let selectedCharacter = null; 
let selectedDifficulty = null; let selectedGameMode = null;

function showMainMenu() {
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
    gameManager.running = false; gameManager.paused = false; gameManager.victory = false;
    ingameCardsUI.style.display = 'none';
    ingameInfoDisplay.style.display = 'none';
    gameTimerDisplay.style.display = 'none';
    cheatMenuButton.style.display = 'none';
    settingsButton.style.display = 'none';
    document.querySelectorAll('.ui-modal').forEach(modal => modal.style.display = 'none');
    canvas.style.display = 'none'; pauseButton.style.display = 'none';
    mainMenuModal.style.display = 'flex'; 
    mainMenuNickname.textContent = PLAYER_CUSTOMIZATION.nickname;
    updateMetaProgression();
    
    if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
    animatePreview();
}

function stopMainMenuAnimations() {
    if (previewAnimationId) {
        cancelAnimationFrame(previewAnimationId);
        previewAnimationId = null;
    }
}

confirmNicknameButton.addEventListener('click', () => {
    const nick = nicknameInput.value.trim();
    if (nick.length >= 3 && nick.length <= 12) {
        PLAYER_CUSTOMIZATION.nickname = nick; nicknameError.textContent = ''; saveGameData(); showMainMenu();
    } else { nicknameError.textContent = 'O nickname deve ter entre 3 e 12 caracteres.'; }
});

nicknameInput.addEventListener('input', () => { const nick = nicknameInput.value.trim(); confirmNicknameButton.disabled = !(nick.length >= 3 && nick.length <= 12); });

playButton.addEventListener('click', () => { 
    stopMainMenuAnimations();
    mainMenuModal.style.display = 'none'; 
    characterSelectionModal.style.display = 'flex';
    const defaultCard = characterCards.querySelector('.character-card[data-character="archer"]');
    if (defaultCard) {
        characterCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedCharacter = defaultCard.dataset.character;
        gameManager.isCharacterRandom = false;
        confirmCharacterButton.disabled = false;
    } else {
        confirmCharacterButton.disabled = true;
    }
});

characterCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if (!card) return;
    characterCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected')); 
    card.classList.add('selected'); 
    selectedCharacter = card.dataset.character; 
    gameManager.isCharacterRandom = (selectedCharacter === 'random');
    confirmCharacterButton.disabled = false;
});

confirmCharacterButton.addEventListener('click', () => {
    if(!selectedCharacter) return;
    gameManager.stats.character = selectedCharacter;
    characterSelectionModal.style.display = 'none';
    difficultyModal.style.display = 'flex';
    const defaultCard = difficultySelectionCards.querySelector('.character-card[data-difficulty="normal"]');
    if (defaultCard) {
        difficultySelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedDifficulty = defaultCard.dataset.difficulty;
        gameManager.isDifficultyRandom = false;
        confirmDifficultyButton.disabled = false;
    } else {
        confirmDifficultyButton.disabled = true;
    }
});

difficultySelectionCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if(!card) return;
    difficultySelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedDifficulty = card.dataset.difficulty;
    gameManager.isDifficultyRandom = (selectedDifficulty === 'random');
    confirmDifficultyButton.disabled = false;
});

confirmDifficultyButton.addEventListener('click', () => {
    if(!selectedDifficulty) return;
    gameManager.difficulty = selectedDifficulty;
    difficultyModal.style.display = 'none';
    gamemodeModal.style.display = 'flex';
    const defaultCard = gamemodeSelectionCards.querySelector('.character-card[data-gamemode="waves"]');
    if (defaultCard) {
        gamemodeSelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
        defaultCard.classList.add('selected');
        selectedGameMode = defaultCard.dataset.gamemode;
        gameManager.isGameModeRandom = false;
        confirmGamemodeButton.disabled = false;
    } else {
        confirmGamemodeButton.disabled = true;
    }
});

gamemodeSelectionCards.addEventListener('click', e => {
    const card = e.target.closest('.character-card');
    if(!card) return;
    gamemodeSelectionCards.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedGameMode = card.dataset.gamemode;
    gameManager.isGameModeRandom = (selectedGameMode === 'random');
    confirmGamemodeButton.disabled = false;
});

confirmGamemodeButton.addEventListener('click', () => {
    if (!selectedGameMode) return;
    gameManager.gameMode = selectedGameMode;
    gamemodeModal.style.display = 'none';
    if (gameManager.chosenDevice) {
        startGame();
    } else {
        deviceSelectionModal.style.display = 'flex';
    }
});

backFromDifficultyButton.addEventListener('click', () => {
    difficultyModal.style.display = 'none';
    characterSelectionModal.style.display = 'flex';
});

backFromGamemodeButton.addEventListener('click', () => {
    gamemodeModal.style.display = 'none';
    difficultyModal.style.display = 'flex';
});


function selectDevice(device) { tempDeviceChoice = device; deviceSelectionModal.style.display = 'none'; deviceConfirmationModal.style.display = 'flex'; }
desktopButton.addEventListener('click', () => selectDevice('desktop')); mobileButton.addEventListener('click', () => selectDevice('mobile'));
confirmDeviceYes.addEventListener('click', () => { 
    deviceConfirmationModal.style.display = 'none'; 
    gameManager.chosenDevice = tempDeviceChoice; 
    gameManager.controlScheme = tempDeviceChoice;
    startGame(); 
});
confirmDeviceNo.addEventListener('click', () => { deviceConfirmationModal.style.display = 'none'; deviceSelectionModal.style.display = 'flex'; });
returnToMenuFromGameOverButton.addEventListener('click', () => { showMainMenu(); });
returnToMenuFromVictoryButton.addEventListener('click', () => { showMainMenu(); });
pauseButton.addEventListener('click', () => { if (!gameManager.running || gameManager.gameOver) return; gameManager.paused = true; pauseModal.style.display = 'flex'; ingameCardsUI.style.display = 'none'; });
resumeGameButton.addEventListener('click', () => { gameManager.paused = false; pauseModal.style.display = 'none'; ingameCardsUI.style.display = 'block'; });

pauseRestartButton.addEventListener('click', () => {
    pauseModal.style.display = 'none';
    restartConfirmationModal.style.display = 'flex';
});
confirmRestartYes.addEventListener('click', () => {
    saveCurrentRunAsRecord();
    restartConfirmationModal.style.display = 'none';
    startGame(true); 
});
confirmRestartNo.addEventListener('click', () => {
    restartConfirmationModal.style.display = 'none';
    pauseModal.style.display = 'flex';
});

returnToMenuButton.addEventListener('click', () => {
    pauseModal.style.display = 'none';
    returnToMenuConfirmationModal.style.display = 'flex';
});
confirmReturnToMenuYes.addEventListener('click', () => {
    saveCurrentRunAsRecord();
    returnToMenuConfirmationModal.style.display = 'none';
    showMainMenu();
});
confirmReturnToMenuNo.addEventListener('click', () => {
    returnToMenuConfirmationModal.style.display = 'none';
    pauseModal.style.display = 'flex';
});

backFromCharacterButton.addEventListener('click', () => { characterSelectionModal.style.display = 'none'; showMainMenu(); });
backFromDeviceButton.addEventListener('click', () => { deviceSelectionModal.style.display = 'none'; gamemodeModal.style.display = 'flex'; });


window.addEventListener('keydown', e => { if(gameManager.controlScheme === 'desktop' && player) { keys[e.key.toLowerCase()] = true; if (e.key === ' ') { e.preventDefault(); if(!gameManager.paused) player.jump(); } } });
window.addEventListener('keyup', e => { if(gameManager.controlScheme === 'desktop') keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e => { if(gameManager.controlScheme === 'desktop' && !gameManager.paused) { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; } });
canvas.addEventListener('mousedown', () => { if(gameManager.controlScheme === 'desktop' && !gameManager.paused) mouse.down = true; });
canvas.addEventListener('mouseup', () => { if(gameManager.controlScheme === 'desktop') mouse.down = false; });
canvas.addEventListener('touchstart', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile' && !gameManager.paused) { for (const touch of e.changedTouches) { movementJoystick?.handleTouchStart(touch); shootingJoystick?.handleTouchStart(touch); } } }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile' && !gameManager.paused) { for (const touch of e.changedTouches) { movementJoystick?.handleTouchMove(touch); shootingJoystick?.handleTouchMove(touch); } } }, { passive: false });
canvas.addEventListener('touchend', e => { e.preventDefault(); if (gameManager.controlScheme === 'mobile') { for (const touch of e.changedTouches) { movementJoystick?.handleTouchEnd(touch); shootingJoystick?.handleTouchEnd(touch); } } });

cheatMenuButton.addEventListener('click', () => { cheatMenu.style.display = cheatMenu.style.display === 'block' ? 'none' : 'block'; if (cheatMenu.style.display === 'block') populateCheatCards(); });
cheatCloseButton.addEventListener('click', () => { cheatMenu.style.display = 'none'; });
applyCheatsButton.addEventListener('click', applyCheats); resetCheatsButton.addEventListener('click', resetCheats);
addAllCardsButton.addEventListener('click', () => { if (!player) return; Object.keys(UPGRADES).forEach(key => player.addUpgrade(key)); floatingTexts.push(new FloatingText('TODAS AS CARTAS ATIVADAS!', canvas.width/2, canvas.height/2, 'gold', 30)); });

function openModal(modal, fromScreen) {
    previousScreen = fromScreen;
    if (fromScreen === 'mainMenu') { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; }
    if (fromScreen === 'pause') pauseModal.style.display = 'none';
    modal.style.display = 'flex';
    if(modal === badgesModal) populateAchievements();
    if(modal === infoModal) setInfoTab('info-cards');
    if(modal === recordsModal) populateRecordsTable();
}

function closeModal(modal, toScreen) {
    modal.style.display = 'none';
    if(toScreen === 'mainMenu' || previousScreen === 'mainMenu') showMainMenu();
    else if(toScreen === 'pause' || previousScreen === 'pause') pauseModal.style.display = 'flex';
}

showBadgesMainButton.addEventListener('click', () => openModal(badgesModal, 'mainMenu'));
showBadgesPauseButton.addEventListener('click', () => openModal(badgesModal, 'pause'));
badgesCloseButton.addEventListener('click', () => closeModal(badgesModal));
closeBadgesButton.addEventListener('click', () => closeModal(badgesModal));

changelogButton.addEventListener('click', () => openModal(changelogModal, 'mainMenu'));
changelogCloseButton.addEventListener('click', () => closeModal(changelogModal, 'mainMenu'));

showSettingsButton.addEventListener('click', () => {
    updateSettingsUI();
    openModal(settingsModal, 'mainMenu');
});

settingsCloseButton.addEventListener('click', () => closeModal(settingsModal, 'mainMenu'));

applySettingsButton.addEventListener('click', () => {
    VISUAL_SETTINGS.shadows = document.getElementById('shadows-setting').checked;
    VISUAL_SETTINGS.blood = document.getElementById('blood-setting').checked; 
    VISUAL_SETTINGS.screenShakeIntensity = parseInt(document.getElementById('screenshake-intensity').value);
    VISUAL_SETTINGS.particleIntensity = parseInt(document.getElementById('particle-intensity').value);
    VISUAL_SETTINGS.trailIntensity = parseInt(document.getElementById('trail-intensity').value);
    VISUAL_SETTINGS.cardEffectIntensity = parseInt(document.getElementById('card-effect-intensity').value);
    VISUAL_SETTINGS.nametagStyle = document.getElementById('nametag-style').value; 
    
    const setCoinsValue = parseInt(document.getElementById('set-coins-input').value, 10);
    if(VISUAL_SETTINGS.cheatFeaturesEnabled && !isNaN(setCoinsValue)) {
        gameManager.stats.coins = setCoinsValue;
        updateMetaProgression();
    }
    
    saveGameData();
    closeModal(settingsModal, 'mainMenu');
});

document.getElementById('unlock-all-achievements-btn').addEventListener('click', () => {
    let totalCoinsGained = 0;
    let itemsGained = 0;
    
    gameManager.achievements.forEach(ach => {
        if (!ach.unlocked) {
            ach.unlocked = true; 
            totalCoinsGained += ach.reward; 
            if (ach.customizationReward) {
                const rewards = Array.isArray(ach.customizationReward) ? ach.customizationReward : [ach.customizationReward];
                rewards.forEach(reward => {
                    itemsGained++;
                    const { type, id } = reward;
                    const listKey = `owned${type.charAt(0).toUpperCase() + type.slice(1)}s`;
                    if (PLAYER_CUSTOMIZATION[listKey] && !PLAYER_CUSTOMIZATION[listKey].includes(id)) {
                        PLAYER_CUSTOMIZATION[listKey].push(id);
                    }
                });
            }
        }
    });
    
    gameManager.stats.coins += totalCoinsGained;
    
    updateMetaProgression();
    populateAchievements();
    updateAchievementCounters();
    saveGameData();
    alert(`Todas as conquistas foram desbloqueadas! Você ganhou ${totalCoinsGained} moedas e ${itemsGained} itens cosméticos.`);
});


document.getElementById('max-all-upgrades-btn').addEventListener('click', () => {
    Object.keys(PERMANENT_UPGRADES_CATALOG).forEach(key => {
        PLAYER_PERMANENT_UPGRADES[key] = PERMANENT_UPGRADES_CATALOG[key].maxLevel;
    });
    alert('Todas as melhorias permanentes maximizadas!');
    saveGameData();
});

cheatFeaturesSettingCheckbox.addEventListener('click', (e) => {
    e.preventDefault();
    if (!VISUAL_SETTINGS.cheatFeaturesEnabled) {
        cheatFeaturesConfirmationModal.style.display = 'flex';
    } else {
        VISUAL_SETTINGS.cheatFeaturesEnabled = false;
        cheatFeaturesSettingCheckbox.checked = false;
        cheatSettingsContainer.style.display = 'none';
    }
});

confirmCheatFeaturesYes.addEventListener('click', () => {
    VISUAL_SETTINGS.cheatFeaturesEnabled = true;
    cheatFeaturesSettingCheckbox.checked = true;
    cheatSettingsContainer.style.display = 'block';
    cheatFeaturesConfirmationModal.style.display = 'none';
});

confirmCheatFeaturesNo.addEventListener('click', () => {
    VISUAL_SETTINGS.cheatFeaturesEnabled = false;
    cheatFeaturesSettingCheckbox.checked = false;
    cheatFeaturesConfirmationModal.style.display = 'none';
});

tutorialButton.addEventListener('click', () => openModal(tutorialModal, 'mainMenu'));
closeTutorialButton.addEventListener('click', () => {
    tutorialModal.style.display = 'none'; 
    showMainMenu(); 
});

rollUpgradesButton.addEventListener('click', () => {
    if (gameManager.stats.coins >= 50) {
        gameManager.stats.coins -= 50;
        gameManager.stats.rerollsThisRun++;
        checkAchievement('rerolls_in_run', gameManager.stats.rerollsThisRun);
        updateMetaProgression();
        saveGameData();
        showUpgradeScreen();
    }
});
randomUpgradeButton.addEventListener('click', () => {
    const choices = document.querySelectorAll('#upgrade-choices .upgrade-card');
    if (choices.length > 0) {
        const randomChoice = choices[Math.floor(Math.random() * choices.length)];
        randomChoice.click();
    }
});
skipUpgradeButton.addEventListener('click', () => {
    if (player) {
        player.exp = 0;
    }
    upgradeModal.style.display = 'none';
    gameManager.paused = false;
});


// ===================================================================================
// 9. CUSTOMIZATION & UPGRADES LOGIC
// ===================================================================================
customizeCharacterButton.addEventListener('click', () => { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; customizationModal.style.display = 'flex'; openCustomizationScreen(); });
backToMainMenuFromCustomizationButton.addEventListener('click', () => { customizationModal.style.display = 'none'; showMainMenu(); });
permanentUpgradesButton.addEventListener('click', () => { stopMainMenuAnimations(); mainMenuModal.style.display = 'none'; permanentUpgradesModal.style.display = 'flex'; openPermanentUpgradesScreen(); });
backToMainMenuFromUpgradesButton.addEventListener('click', () => { permanentUpgradesModal.style.display = 'none'; showMainMenu(); });

function openCustomizationScreen() {
    updateMetaProgression(); 
    setActiveTab('shapes'); 
}

function setActiveTab(tabName) {
    document.querySelectorAll('#customization-modal .customization-options-grid').forEach(el => el.style.display = 'none');
    document.querySelectorAll('#customization-modal .customization-tabs button').forEach(el => el.classList.remove('active'));
    let container, type;
    if (tabName === 'shapes') { container = shapesOptionsContainer; type = 'shapes'; shapesTabButton.classList.add('active'); }
    else if (tabName === 'hats') { container = hatsOptionsContainer; type = 'hats'; hatsTabButton.classList.add('active'); }
    else if (tabName === 'colors') { container = colorsOptionsContainer; type = 'colors'; colorsTabButton.classList.add('active'); }
    else if (tabName === 'faces') { container = facesOptionsContainer; type = 'faces'; facesTabButton.classList.add('active');}
    else return;
    container.style.display = 'grid';
    renderCustomizationOptions(type, container);
}

shapesTabButton.addEventListener('click', () => setActiveTab('shapes'));
hatsTabButton.addEventListener('click', () => setActiveTab('hats'));
colorsTabButton.addEventListener('click', () => setActiveTab('colors'));
facesTabButton.addEventListener('click', () => setActiveTab('faces'));

function renderCustomizationOptions(type, container) {
    let catalog, ownedListKey, equippedKey;
    if (type === 'shapes') { catalog = SHAPES_CATALOG; ownedListKey = 'ownedShapes'; equippedKey = 'equippedShape'; }
    else if (type === 'hats') { catalog = HATS_CATALOG; ownedListKey = 'ownedHats'; equippedKey = 'equippedHat'; }
    else if (type === 'colors') { catalog = COLORS_CATALOG; ownedListKey = 'ownedColors'; equippedKey = 'equippedColor'; }
    else if (type === 'faces') { catalog = FACES_CATALOG; ownedListKey = 'ownedFaces'; equippedKey = 'equippedFace'; }
    else return;
    container.innerHTML = '';
    catalog.forEach(item => {
        const isOwned = PLAYER_CUSTOMIZATION[ownedListKey].includes(item.id); const isEquipped = PLAYER_CUSTOMIZATION[equippedKey] === item.id;
        const isLockedByAchievement = item.unlockAchievement && !isOwned;

        const itemDiv = document.createElement('div');
        itemDiv.className = 'customization-item';
        if (isEquipped) itemDiv.classList.add('equipped'); 
        if (!isOwned) itemDiv.classList.add('locked');

        const previewDiv = document.createElement('div'); previewDiv.className = 'item-preview';
        if (type === 'hats') { previewDiv.classList.add('item-preview-emoji'); previewDiv.textContent = item.emoji; } 
        else {
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50; const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, 50, 50);
            if (type === 'shapes') item.asset(tempCtx, 5, 5, 40, 40, '#cccccc');
            else if (type === 'colors') { 
                if (Array.isArray(item.value)) {
                    const gradient = tempCtx.createLinearGradient(0, 0, 50, 50);
                    gradient.addColorStop(0, item.value[0]); gradient.addColorStop(1, item.value[1]);
                    tempCtx.fillStyle = gradient;
                } else {
                    tempCtx.fillStyle = item.value;
                }
                tempCtx.fillRect(5, 5, 40, 40); 
            }
            else if (type === 'faces') { const faceLines = item.text.split('|'); const fontSize = item.text === '0_0' ? 20 : (faceLines.length > 1 ? 16 : 24); tempCtx.fillStyle = '#000000'; tempCtx.textAlign = 'center'; tempCtx.textBaseline = 'middle'; tempCtx.font = `bold ${fontSize}px Courier New`; faceLines.forEach((line, index) => tempCtx.fillText(line, 25, 25 - (faceLines.length - 1) * fontSize * 0.4 + index * fontSize * 0.8)); }
            previewDiv.appendChild(tempCanvas);
        }
        const nameDiv = document.createElement('div'); nameDiv.className = 'item-name'; nameDiv.textContent = item.name;
        const buttonContainer = document.createElement('div'); buttonContainer.className = 'item-button-container';
        if (isLockedByAchievement) {
            const achievement = gameManager.achievements.find(a => a.id === item.unlockAchievement);
            buttonContainer.innerHTML = `<button class="item-button achievement-lock-button" title="${achievement?.description || ''}">🏆 Conquista</button>`;
        } else if (isEquipped) {
            if (type === 'hats' && item.id !== 'hat_none') { buttonContainer.innerHTML = `<button class="item-button unequip-button">Desequipar</button>`; buttonContainer.querySelector('.unequip-button').onclick = () => handleCustomizationItemClick(item, type, 'unequip'); } 
            else { buttonContainer.innerHTML = `<button class="item-button equipped-button" disabled>Equipado</button>`; }
        } else if (isOwned) { buttonContainer.innerHTML = `<button class="item-button equip-button">Equipar</button>`; buttonContainer.querySelector('.equip-button').onclick = () => handleCustomizationItemClick(item, type, 'equip'); } 
        else { buttonContainer.innerHTML = `<button class="item-button buy-button">Comprar 💰${item.price}</button>`; buttonContainer.querySelector('.buy-button').onclick = () => handleCustomizationItemClick(item, type, 'buy'); }
        itemDiv.appendChild(previewDiv); itemDiv.appendChild(nameDiv); itemDiv.appendChild(buttonContainer); container.appendChild(itemDiv);
    });
}

function handleCustomizationItemClick(item, type, action) {
    let ownedListKey, equippedKey;
    if (type === 'shapes') { ownedListKey = 'ownedShapes'; equippedKey = 'equippedShape'; }
    else if (type === 'hats') { ownedListKey = 'ownedHats'; equippedKey = 'equippedHat'; }
    else if (type === 'colors') { ownedListKey = 'ownedColors'; equippedKey = 'equippedColor'; }
    else if (type === 'faces') { ownedListKey = 'ownedFaces'; equippedKey = 'equippedFace'; }
    
    if (action === 'buy') {
        if (gameManager.stats.coins >= item.price) {
            gameManager.stats.coins -= item.price; gameManager.stats.totalSpent += item.price;
            PLAYER_CUSTOMIZATION[ownedListKey].push(item.id); PLAYER_CUSTOMIZATION[equippedKey] = item.id;
            if(!gameManager.stats.firstPurchaseMade) {
                gameManager.stats.firstPurchaseMade = true;
                checkAchievement('first_purchase', 1);
            }
            checkMetaAchievements();
        } else { return; }
    } else if (action === 'equip') { PLAYER_CUSTOMIZATION[equippedKey] = item.id; }
    else if (action === 'unequip') { if(type === 'hats') PLAYER_CUSTOMIZATION.equippedHat = 'hat_none'; }
    
    saveGameData(); 
    setActiveTab(type); 
    updateMetaProgression();
}

function renderCharacter(ctx, x, y, w, h, facingDirection, isGlass) {
    const shapeData = SHAPES_CATALOG.find(s => s.id === PLAYER_CUSTOMIZATION.equippedShape);
    const colorData = COLORS_CATALOG.find(c => c.id === PLAYER_CUSTOMIZATION.equippedColor);
    const hatData = HATS_CATALOG.find(h => h.id === PLAYER_CUSTOMIZATION.equippedHat);
    const faceData = FACES_CATALOG.find(f => f.id === PLAYER_CUSTOMIZATION.equippedFace);

    let finalColor = '#4caf50';
    if(colorData) {
        if (Array.isArray(colorData.value)) {
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            gradient.addColorStop(0, colorData.value[0]);
            gradient.addColorStop(1, colorData.value[1]);
            finalColor = gradient;
        } else {
            finalColor = colorData.value;
        }
    }
    
    if (isGlass) {
        ctx.save();
        ctx.globalAlpha = 0.5;
    }

    if (shapeData && shapeData.asset) shapeData.asset(ctx, x, y, w, h, finalColor);
    else drawShapeSquare(ctx, x, y, w, h, finalColor);

    if (isGlass) {
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }

    if (faceData) drawPlayerFace(ctx, x, y, w, h, faceData.text, '#000000', facingDirection);
    if (hatData && hatData.emoji) drawHatEmoji(ctx, x, y, w, h, hatData.emoji);
}

function openPermanentUpgradesScreen() { updateMetaProgression(); renderPermanentUpgrades(); }

function renderPermanentUpgrades() {
    permanentUpgradesListContainer.innerHTML = '';
    Object.keys(PERMANENT_UPGRADES_CATALOG).forEach(key => {
        const upgrade = PERMANENT_UPGRADES_CATALOG[key]; const currentLevel = PLAYER_PERMANENT_UPGRADES[key] || 0;
        const isMaxLevel = currentLevel >= upgrade.maxLevel; const cost = isMaxLevel ? 'MAX' : Math.floor(upgrade.cost(currentLevel));
        const itemDiv = document.createElement('div'); itemDiv.className = 'permanent-upgrade-item';
        const infoDiv = document.createElement('div'); infoDiv.className = 'permanent-upgrade-info';
        infoDiv.innerHTML = `<h4>${upgrade.name}</h4><p>${upgrade.description}</p><div class="upgrade-level">Nível: ${currentLevel} / ${upgrade.maxLevel}</div>`;
        const actionDiv = document.createElement('div'); actionDiv.className = 'permanent-upgrade-action'; const button = document.createElement('button'); button.className = 'modal-button';
        if (isMaxLevel) { button.textContent = 'NÍVEL MÁXIMO'; button.disabled = true; } 
        else { button.textContent = `Melhorar 💰${cost}`; button.disabled = gameManager.stats.coins < cost; button.onclick = () => handlePermanentUpgradePurchase(key); }
        actionDiv.appendChild(button); itemDiv.appendChild(infoDiv); itemDiv.appendChild(actionDiv); permanentUpgradesListContainer.appendChild(itemDiv);
    });
}

function handlePermanentUpgradePurchase(key) {
    const upgrade = PERMANENT_UPGRADES_CATALOG[key]; const currentLevel = PLAYER_PERMANENT_UPGRADES[key] || 0; if (currentLevel >= upgrade.maxLevel) return;
    const cost = Math.floor(upgrade.cost(currentLevel));
    if (gameManager.stats.coins >= cost) {
        gameManager.stats.coins -= cost; gameManager.stats.totalSpent += cost; PLAYER_PERMANENT_UPGRADES[key] = currentLevel + 1;
        checkMetaAchievements(); saveGameData(); renderPermanentUpgrades(); updateMetaProgression();
    }
}


// ===================================================================================
// 10. SAVE/LOAD GAME DATA
// ===================================================================================
function saveGameData() {
    try {
        const saveData = {
            version: 7.9,
            coins: gameManager.stats.coins, totalSpent: gameManager.stats.totalSpent, totalWins: gameManager.stats.totalWins,
            totalHealing: gameManager.stats.totalHealing || 0,
            firstPurchaseMade: gameManager.stats.firstPurchaseMade || false,
            achievements: gameManager.achievements,
            nickname: PLAYER_CUSTOMIZATION.nickname, ownedShapes: PLAYER_CUSTOMIZATION.ownedShapes, ownedHats: PLAYER_CUSTOMIZATION.ownedHats,
            ownedColors: PLAYER_CUSTOMIZATION.ownedColors, ownedFaces: PLAYER_CUSTOMIZATION.ownedFaces, equippedShape: PLAYER_CUSTOMIZATION.equippedShape,
            equippedHat: PLAYER_CUSTOMIZATION.equippedHat, equippedColor: PLAYER_CUSTOMIZATION.equippedColor, equippedFace: PLAYER_CUSTOMIZATION.equippedFace,
            permanentUpgrades: PLAYER_PERMANENT_UPGRADES, records: PLAYER_RECORDS,
            visualSettings: VISUAL_SETTINGS,
        };
        localStorage.setItem('cubeChaosSave', JSON.stringify(saveData));
    } catch(e) { console.error("Falha ao salvar o jogo:", e); }
}

function loadGameData() {
    const savedData = localStorage.getItem('cubeChaosSave');
    if (savedData) {
        try {
            const data = JSON.parse(savedData); 
            if (!data || !data.nickname || data.nickname.trim() === '' || data.nickname.trim() === 'Jogador') {
                 console.log("Save data invalid or nickname not set. Forcing nickname input.");
                 localStorage.removeItem('cubeChaosSave');
                 return false;
            }
            if (data.version < 7.9) { 
                 console.log("Save data from old version ("+ (data.version || 'N/A') +"), resetting for new features.");
                 localStorage.removeItem('cubeChaosSave');
                 return false;
            }
            gameManager.stats.coins = data.coins || 0; gameManager.stats.totalSpent = data.totalSpent || 0; gameManager.stats.totalWins = data.totalWins || 0;
            gameManager.stats.totalHealing = data.totalHealing || 0;
            gameManager.stats.firstPurchaseMade = data.firstPurchaseMade || false;
            if (data.achievements && data.achievements.length === ACHIEVEMENTS.length) { gameManager.achievements = data.achievements; }
            PLAYER_CUSTOMIZATION.nickname = data.nickname;
            PLAYER_CUSTOMIZATION.ownedShapes = data.ownedShapes || ['shape_square'];
            PLAYER_CUSTOMIZATION.ownedHats = data.ownedHats || ['hat_none'];
            PLAYER_CUSTOMIZATION.ownedColors = data.ownedColors || ['color_green_default'];
            PLAYER_CUSTOMIZATION.ownedFaces = data.ownedFaces || ['face_zero', 'face_smile'];
            PLAYER_CUSTOMIZATION.equippedShape = data.equippedShape || 'shape_square';
            PLAYER_CUSTOMIZATION.equippedHat = data.equippedHat || 'hat_none';
            PLAYER_CUSTOMIZATION.equippedColor = data.equippedColor || 'color_green_default';
            PLAYER_CUSTOMIZATION.equippedFace = data.equippedFace || 'face_zero';
            PLAYER_PERMANENT_UPGRADES = data.permanentUpgrades || {};
            PLAYER_RECORDS = data.records || []; 
            Object.assign(VISUAL_SETTINGS, data.visualSettings);
            
            checkRetroactiveAchievements();
            
            updateAchievementCounters();
            return true;
        } catch (e) { console.error("Erro ao carregar dados salvos, resetando:", e); localStorage.removeItem('cubeChaosSave'); }
    }
    return false;
}

function deleteSaveData() {
    localStorage.removeItem('cubeChaosSave');
    location.reload();
}

deleteDataButton.addEventListener('click', () => {
    deleteDataConfirmationModal.style.display = 'flex';
});
confirmDeleteDataYes.addEventListener('click', deleteSaveData);
confirmDeleteDataNo.addEventListener('click', () => {
    deleteDataConfirmationModal.style.display = 'none';
});

function checkRetroactiveAchievements() {
    checkMetaAchievements(true);
    if (gameManager.stats.firstPurchaseMade) {
        const firstPurchaseAch = gameManager.achievements.find(a => a.id === 'firstpurchase');
        if (firstPurchaseAch && !firstPurchaseAch.unlocked) {
            checkAchievement('first_purchase', 1, true);
        }
    }
}

// ===================================================================================
// 11. RECORDS & INFO SYSTEM LOGIC (v6.8 / v7.2)
// ===================================================================================
function populateBestRecordDisplay() {
    const bestWaveEl = document.getElementById('best-record-wave');
    const bestKillsEl = document.getElementById('best-record-kills');
    const bestTimeEl = document.getElementById('best-record-time');

    if (PLAYER_RECORDS.length === 0) {
        bestWaveEl.textContent = '--';
        bestKillsEl.textContent = '--';
        bestTimeEl.textContent = '--:--';
        return;
    }

    const bestRecord = [...PLAYER_RECORDS].sort((a, b) => {
        if (b.wave !== a.wave) return b.wave - a.wave;
        return b.kills - a.kills;
    })[0];

    bestWaveEl.textContent = bestRecord.wave;
    bestKillsEl.textContent = bestRecord.kills;
    bestTimeEl.textContent = bestRecord.time;
}

function populateRecordsTable() {
    recordsTableBody.innerHTML = '';
    if (PLAYER_RECORDS.length > 0) {
        const sortedRecords = [...PLAYER_RECORDS].sort((a, b) => {
            if (b.wave !== a.wave) return b.wave - a.wave;
            return b.kills - a.kills;
        });

        sortedRecords.forEach(record => {
            const charName = record.character ? record.character.charAt(0).toUpperCase() + record.character.slice(1) : 'N/A';
            const diffName = record.difficulty ? record.difficulty.charAt(0).toUpperCase() + record.difficulty.slice(1) : 'N/A';
            const modeName = record.mode === 'waves' ? '100 Ondas' : (record.mode === 'infinite' ? 'Infinito' : 'N/A');
            const deviceName = record.device === 'desktop' ? 'PC' : 'Mobile';

            const charText = `${charName}${record.isCharacterRandom ? ' (🎲)' : ''}`;
            const diffText = `${diffName}${record.isDifficultyRandom ? ' (🎲)' : ''}`;
            const modeText = `${modeName}${record.isGameModeRandom ? ' (🎲)' : ''}`;

            recordsTableBody.innerHTML += `<tr><td>${record.date}</td><td>${charText}</td><td>${diffText}</td><td>${modeText}</td><td>${record.wave}</td><td>${record.kills}</td><td>${record.time}</td><td>${deviceName}</td></tr>`;
        });
    } else {
        recordsTableBody.innerHTML = `<tr><td colspan="8">Nenhum histórico de partidas encontrado. Jogue para começar a registrar!</td></tr>`;
    }
}

showRecordsButton.addEventListener('click', () => openModal(recordsModal, 'mainMenu'));
recordsCloseButton.addEventListener('click', () => closeModal(recordsModal));
closeRecordsButton.addEventListener('click', () => closeModal(recordsModal));

showInfoButton.addEventListener('click', () => openModal(infoModal, 'mainMenu'));
infoCloseButton.addEventListener('click', () => closeModal(infoModal, 'mainMenu'));
document.querySelectorAll('.info-tabs button').forEach(button => { button.addEventListener('click', () => setInfoTab(button.dataset.tab)); });
function setInfoTab(tabName) {
    document.querySelectorAll('.info-tabs button').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.info-tabs button[data-tab="${tabName}"]`).classList.add('active');
    const contentPanel = document.getElementById('info-content-panel'); contentPanel.innerHTML = ''; let html = '';
    switch(tabName) {
        case 'info-cards':
            html += '<div class="info-card-grid">';
            Object.values(UPGRADES).sort((a,b) => a.name.localeCompare(b.name)).forEach(card => { 
                html += `<div class="info-card"><h4>${card.name}</h4><p>${card.description}</p><p style="font-size: 0.85em; color: #aabfff; margin-top: 10px; border-top: 1px dashed #5a6a8a; padding-top: 8px;"><strong>Efeito de Acúmulo:</strong><br>${card.scaling || 'Não possui efeitos de acúmulo adicionais.'}</p><p class="rarity" style="color:${getColorByRarity(card.rarity)}">${card.rarity.toUpperCase()}</p></div>`; 
            });
            html += '</div>';
            break;
        case 'info-enemies':
             html += '<div class="info-card-grid">';
             Object.values(ENEMY_TYPES).forEach(enemy => { html += `<div class="info-card"><h4>${enemy.name}</h4><p>${enemy.description}</p></div>`; }); 
             html += '</div>';
             break;
        case 'info-scenarios':
            html += '<div class="info-card-grid">';
            Object.values(THEMES).forEach(theme => { html += `<div class="info-card"><h4>${theme.name}</h4><p>Cores: <span style="color:${theme.ground}">Chão</span>, <span style="color:${theme.platform}">Plataformas</span></p></div>`; });
            html += '</div>';
            break;
        case 'info-tech':
             html += `<div class="info-section">
                        <h4>Fórmulas de Jogo</h4>
                        <p>Entender as mecânicas centrais pode ajudar a criar builds mais fortes.</p>
                        <ul>
                          <li><strong>Vida dos Inimigos:</strong> <code>Vida Base * (1 + (Onda - 1) * 0.1) * Modificador de Dificuldade</code>. A vida escala linearmente com as ondas.</li>
                          <li><strong>Dano do Jogador:</strong> <code>(Dano Base * Bônus Permanente + Bônus Fixo) * Modificadores Multiplicativos</code>. Cartas como 'Fúria' e 'Canhão de Vidro' são multiplicadores finais.</li>
                          <li><strong>Dano Crítico:</strong> <code>Dano Final * (1.5 + Bônus de 'Precisão')</code>. Críticos são uma fonte poderosa de dano em rajada.</li>
                          <li><strong>Velocidade de Ataque:</strong> A recarga é multiplicada por um fator redutor (ex: 0.92 para +8% de velocidade). Acumular velocidade de ataque tem retornos decrescentes, mas é sempre eficaz.</li>
                          <li><strong>Ganhos de Moedas:</strong> <code>(Moedas da Fonte + Bônus de Onda) * (1 + Bônus Permanente)</code>. Melhorias permanentes são aplicadas no final.</li>
                        </ul>
                      </div>`;
             html += `<div class="info-section">
                        <h4>Sinergias e Efeitos Visuais</h4>
                        <p>Muitas cartas não apenas mudam números, mas também adicionam efeitos visuais que indicam seu poder crescente.</p>
                        <ul>
                          <li><strong>Fogo ('Catalisador'):</strong> Deixa um rastro de fogo nos projéteis.</li>
                          <li><strong>Gelo ('Nova Congelante'):</strong> Cria uma explosão azulada ao ser atingido.</li>
                          <li><strong>Elétrico ('Corrente de Raios', 'Relâmpago'):</strong> Gera feixes de energia azul/amarela.</li>
                          <li><strong>Gravitacional ('Buraco Negro', 'Poço Gravitacional'):</strong> Cria vórtices roxos que distorcem o espaço.</li>
                          <li><strong>Fantasma ('Balas Fantasma', 'Ressonância'):</strong> Adiciona efeitos de transparência e imagens residuais.</li>
                        </ul>
                        <p>Tente combinar cartas para criar sinergias poderosas, como 'Buraco Negro' + 'Fragmentação+' para dano massivo em área.</p>
                      </div>`;
             break;
        case 'info-controls':
            html += `<div class="tutorial-section"><h3>Controles (Desktop)</h3><p><strong>A/D ou Setas ←/→:</strong> Mover o personagem.<br><strong>Barra de Espaço:</strong> Pular.<br><strong>Clique do Mouse:</strong> Atirar na direção do cursor.</p></div><div class="tutorial-section"><h3>Controles (Mobile)</h3><p><strong>Joystick Esquerdo:</strong> Mover o personagem. Puxe para baixo para pular.<br><strong>Joystick Direito:</strong> Atirar na direção apontada.</p></div>`; 
            break;
    }
    contentPanel.innerHTML = html;
}

function updateSettingsUI() {
    document.getElementById('shadows-setting').checked = VISUAL_SETTINGS.shadows;
    document.getElementById('blood-setting').checked = VISUAL_SETTINGS.blood;
    document.getElementById('screenshake-intensity').value = VISUAL_SETTINGS.screenShakeIntensity;
    document.getElementById('particle-intensity').value = VISUAL_SETTINGS.particleIntensity;
    document.getElementById('trail-intensity').value = VISUAL_SETTINGS.trailIntensity;
    document.getElementById('card-effect-intensity').value = VISUAL_SETTINGS.cardEffectIntensity;
    document.getElementById('nametag-style').value = VISUAL_SETTINGS.nametagStyle;
    
    cheatFeaturesSettingCheckbox.checked = VISUAL_SETTINGS.cheatFeaturesEnabled;
    cheatSettingsContainer.style.display = VISUAL_SETTINGS.cheatFeaturesEnabled ? 'block' : 'none';
    document.getElementById('set-coins-input').value = gameManager.stats.coins;
}

function setGraphicsPreset(preset) {
    const settings = {
        low:    { shadows: false, blood: false, shake: 2, particles: 2, trail: 2, cardFx: 3 },
        medium: { shadows: true,  blood: true,  shake: 6, particles: 6, trail: 6, cardFx: 7 },
        high:   { shadows: true,  blood: true,  shake: 8, particles: 10, trail: 10, cardFx: 10 },
    };
    const s = settings[preset];
    if (!s) return;

    VISUAL_SETTINGS.shadows = s.shadows; VISUAL_SETTINGS.blood = s.blood;
    VISUAL_SETTINGS.screenShakeIntensity = s.shake; VISUAL_SETTINGS.particleIntensity = s.particles;
    VISUAL_SETTINGS.trailIntensity = s.trail; VISUAL_SETTINGS.cardEffectIntensity = s.cardFx;
    
    updateSettingsUI();
}

document.getElementById('preset-low').addEventListener('click', () => setGraphicsPreset('low'));
document.getElementById('preset-medium').addEventListener('click', () => setGraphicsPreset('medium'));
document.getElementById('preset-high').addEventListener('click', () => setGraphicsPreset('high'));

// Inicialização
function initializeGame() {
    createStars(); 
    const hasSave = loadGameData();
    confirmNicknameButton.disabled = true; 
    
    if (hasSave) {
        showMainMenu(); 
    } else { 
        if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
        nicknameModal.style.display = 'flex'; 
    }
    updateAchievementCounters();
    populateBestRecordDisplay();
}

window.addEventListener('DOMContentLoaded', initializeGame);
window.addEventListener('beforeunload', saveGameData);

</script>
</body>
</html>
